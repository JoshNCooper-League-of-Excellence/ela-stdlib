extern fn rand() -> s32;
extern fn srand(seed: u32);
extern fn fmod(l: f32, r: f32) -> f32;
extern fn fabs(f: f64) -> f64;
extern fn isinf(arg: f64) -> bool;
extern fn isnan(arg: f64) -> bool;
extern fn pow(base: f64, exponent: f64) -> f64;
extern fn sqrt(f: f64) -> f64;
extern fn cos(f: f64) -> f64;
extern fn sin(f: f64) -> f64;

extern fn tan(f: f64) -> f64;
extern fn acos(f: f64) -> f64;
extern fn asin(f: f64) -> f64;
extern fn atan(f: f64) -> f64;
extern fn atan2(y: f64, x: f64) -> f64;
extern fn ceil(f: f64) -> f64;
extern fn floor(f: f64) -> f64;
extern fn exp(f: f64) -> f64;
extern fn log(f: f64) -> f64;
extern fn log10(f: f64) -> f64;
extern fn sinh(f: f64) -> f64;
extern fn cosh(f: f64) -> f64;
extern fn tanh(f: f64) -> f64;

// We use this struct for namespacing.
struct Random;

const RAND_MAX := 2147483647;
const PI := 3.141592653589793;

impl Random {
  fn seed(seed: u32) {
    srand(seed);
  }
  fn next(max: f32) -> f32 {
    return (rand() as f32) / (RAND_MAX as f32) * max;
  }
}

fn abs!<T>(v: T) -> T {
  if v < 0 {
    return -v;
  }
  return v;
}

fn min!<T>(a: T, b: T) -> T {
  if a > b then return b;
  return a;
}

fn max!<T>(a: T, b: T) -> T {
  if a > b then return a;
  return b;
}

fn clamp(v: f64, min: f64, max: f64) -> f64 {
  if v < min then return min;
  if v > max then return max;
  return v;
}

fn lerp(a: f32, b: f32, t: f32) -> f32 {
  return (a * (1.0 - t)) + (b * t);
}
