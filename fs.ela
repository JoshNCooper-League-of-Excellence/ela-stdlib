
import fmt;

import std::c::*;

struct File {
  fd: *mut FILE,
}

impl File {
  fn delete!<PathT>(path: PathT) -> bool where PathT: AsSlice!<u8> {
    extern fn remove(path: *const u8) -> s32;
    slice := path.as_slice();
    if slice.length == 0 {
      return false;
    }
    return remove(slice.data) == 0;
  }

  fn copy!<SourcePathT, DestPathT>(source: SourcePathT, dest: DestPathT) -> Result!<Infallible, String>
    where SourcePathT: AsSlice!<u8>, DestPathT: AsSlice!<u8> {
    type Result :: Result!<Infallible, String>;
    src := source.as_slice();
    dst := dest.as_slice();

    in_file := fopen(src.data, "r"c);
    if !in_file {
      return Result::Err(String::from("Unable to open source file"));
    }

    out_file := fopen(dst.data, "w"c);
    if !out_file {
      fclose(in_file);
      return Result::Err(String::from("Unable to open destination file"));
    }

    mut buf: [u8; 8192];

    while {
      read := fread(buf, sizeof(u8), 8192, in_file);
      if read == 0 {
        break;
      }
      written := fwrite(buf, sizeof(u8), read, out_file);
      if written != read {
        fclose(in_file);
        fclose(out_file);
        return Result::Err(String::from("Failed to write all bytes to destination"));
      }
    }

    fflush(out_file);
    fclose(in_file);
    fclose(out_file);

    return Result::Ok(Infallible.{});
  }

  fn stat(*mut self) -> Option!<Stat> {
    type Option :: Option!<Stat>;
    mut stat: Stat;
    if fstat(fileno(self.fd), &mut stat) != 0 {
      return Option::None;
    }
    return Option::Some(stat);
  }

  fn exists!<PathT>(path: PathT) -> bool where PathT: AsSlice!<u8> {
    return Stat::new(path).is_some();
  }

  fn is_valid(*self) -> bool {
    return self.fd;
  }

  fn open!<T>(path: T, flags: FileOpenFlags) -> Self where T: AsSlice!<u8> {
    slice := path.as_slice();
    mut self: Self;
    self.fd = fopen(slice.data, flags.as_str());
    return self;
  }

  fn write_raw(*mut self, data: *u8, length: u64) -> u64 {
    return fwrite(data, sizeof(u8), length, self.fd);
  }

  fn write!<Data>(*mut self, data: Data) -> u64 where Data: AsSlice!<u8> {
    slice := data.as_slice();
    return fwrite(slice.data, sizeof(u8), slice.length, self.fd);
  }

  fn read(*mut self, buffer: *mut u8, size: u64) -> u64 {
    return fread(buffer, sizeof(u8), size, self.fd);
  }


  fn seek(*mut self, offset: s64, position: SeekPosition) -> s64 {
    fd := fileno(self.fd);
    return std::c::lseek(fd, offset, position as s32);
  }

  fn position(*mut self) -> s64 {
    return self.seek(0, SeekPosition::Current);
  }

  fn rewind_file(*mut self) {
    self.seek(0, SeekPosition::Begin);
  }

  fn size(*mut self) -> u64 {
    fd := std::c::fileno(self.fd);
    current := std::c::lseek(fd, 0, SeekPosition::Current);
    end := std::c::lseek(fd, 0, SeekPosition::End);
    std::c::lseek(fd, current, SeekPosition::Set);
    return end as u64;
  }


  fn flush(*mut self) {
    fflush(self.fd);
  }

  fn close(*const self) -> void {
    fflush(self.fd);
    fclose(self.fd);
  }

  fn length(file: *mut FILE) -> u32 {
    original_pos := ftell(file);
    fseek(file, 0, SeekPosition::End);
    len := ftell(file);
    fseek(file, original_pos, SeekPosition::Current);
    return len as u32;
  }

  fn read_all!<Path>(filename_path: Path) -> Result!<String, String> where Path: AsSlice!<u8> {
    type Result :: Result!<String, String>;
    filename := filename_path.as_slice();
    file := fopen(filename.data, "r"c);

    if !file then {
      return Result::Err(fmt::format("Couldnt open file %", (filename_path,)));
    }

    mut string: String;
    string.resize(1024);
    while {
      c := fgetc(file);
      if c == EOF then break;
      string.push(c);
    }
    fclose(file);
    return Result::Ok(string);
  }
  
  fn read_bytes!<Path>(path: Path) -> Result!<List!<u8>, str> where Path: AsSlice!<u8> {
    type Result :: Result!<List!<u8>, str>;
    filename := path.as_slice();
    file := fopen(filename.data, "r"c);
    if !file then return Result::Err("Couldnt open file");
    mut bytes: List!<u8>;
    bytes.resize(1024);

    while {
      c := fgetc(file);
      if c == EOF then break;
      bytes.push(c);
    }
    
    fclose(file);
    return Result::Ok(bytes);
  }
  
  fn write_all!<Path, Data>(path: Path, data_slice: Data) -> Option!<str> 
    where Path: AsSlice!<u8>, Data: AsSlice!<u8> {
    type Option :: Option!<str>;

    filename := path.as_slice();

    data := data_slice.as_slice();

    file := fopen(filename.data, "w "c);

    if !file {
      return Option::Some("Unable to open file");
    }

    fwrite(data.data, sizeof(u8), data.length, file);

    fclose(file);

    return Option::None;
  }

  fn read_line(*mut self) -> String {
    mut line: String;
    while {
      c := fgetc(self.fd);
      if c == EOF || c == '\n' {
        break;
      }
      line.push(c);
    }
    return line;
  }
}

impl Destroy for File {
  fn destroy(*mut self, recursive: bool = true) {
    self.close();
  }
}

fn canonical_path!<Path>(path: Path) -> Option!<String> where Path: AsSlice!<u8> {
  slice := path.as_slice();
  if slice.length == 0 {
    return None();
  }

  using nt := slice.null_terminated(get_global_allocator());

  mut canonical: [u8; PATH_MAX];
  if !realpath(nt.data, canonical) {
    return None();
  }
  result := String::from_ptr(canonical);
  return Some(result);
}

/* 
  The option return _type simply says when it .is_none(), it has failed in some capacity.
  We don't have a way to interact with perror, so we don't really get much information as to why
  this has failed, just that it did fail.
*/
fn change_directory!<Path>(path: Path) -> bool where Path: AsSlice!<u8> {
  slice := path.as_slice();
  if slice.length == 0 {
    return false;
  }
  if chdir(slice.data) != 0 {
    return false;
  }
  return true;
}

fn parent_path!<Path>(path: Path) -> Option!<String> where Path: AsSlice!<u8> {
  s := path.as_slice();
  if s.length == 0 { return None(); }
  mut i := s.length;
  while i > 0 {
    i -= 1;
    if s.data![i] == '/' {
      if i == 0 { return Some(String::from("/")); }
      out: [u8] = [u8].{ data: s.data, length: i };
      return Some(String::from(out));
    }
  }
  return None();
}

struct Directory {
  path: String,
  entries: List!<String>,
}

impl Directory {
  fn delete!<PathT>(path: PathT, recursive: bool = false, force: bool = false) -> bool where PathT: AsSlice!<u8> {
    slice := path.as_slice();
    if slice.length == 0 {
      return false;
    }

    stat_opt := Stat::new(slice);
    if stat_opt.is_none() {
      return false;
    }
    stat := stat_opt.unwrap();

    if stat.is_file() || stat.is_symlink() {
      extern fn remove(path: *const u8) -> s32;
      if force {
        extern fn chmod(path: *const u8, mode: u32) -> s32;
        chmod(slice.data, 511);
      }
      return remove(slice.data) == 0;
    }

    if stat.is_dir() {
      if recursive {
        dir_opt := Directory::open(slice);
        if dir_opt.is_none() {
          return false;
        }
        dir := dir_opt.unwrap();
        for entry in dir.entries {
          if entry.as_str() == "." || entry.as_str() == ".." {
            continue;
          }
          using mut entry_path := String::from(slice);
          entry_path.push('/');
          entry_path.append(entry);
          Directory::delete(entry_path, true, force);
        }
      }
      extern fn rmdir(path: *const u8) -> s32;
      return rmdir(slice.data) == 0;
    }

    return false;
  }

  fn current() -> String {
    buffer: [u8; 256];
    getcwd(buffer, 256);
    return String::from_ptr(buffer);
  }

  fn open!<T>(path: T) -> Option!<Directory> where T: AsSlice!<u8> {
    dir := opendir(path.as_slice().data);
    if !dir => Option!<Directory>::None;

    mut entries: List!<String>;
    mut entry: *mut void;

    while entry = readdir(dir) {
      ent : *const DirEntry = entry;
      entries.push(String::from_ptr(ent.d_name));
    }

    closedir(dir);

    return Option!<Directory>::Some(.{
      path: String::from(path), 
      entries: entries
    });
  }

  fn files(*const self) -> List!<String> {
    mut files: List!<String>;
    for entry in self.entries {
      file_stat := Stat::new(entry);
      if file_stat.is_none() then continue;
      file := file_stat.unwrap();
      if file.is_file() {
        files.push(entry.clone());
      }
    }
    return files;
  }

  fn subdirectories(*const self) -> List!<String> {
    mut files: List!<String>;
    for entry in self.entries {
      dir_stat := Stat::new(entry);
      if dir_stat.is_none() then continue;
      dir := dir_stat.unwrap();
      if dir.is_dir() {
        files.push(entry.clone());
      }
    }
    return files;
  }

  fn create!<PathT>(path: PathT, create_parent_dirs: bool = false) -> bool where PathT: AsSlice!<u8> {
    mut dir_path := path.as_slice();

    if dir_path.length == 0 {
      return false;
    }

    const DEFAULT_MODE := 493;

    slice := dir_path.as_slice();

    if !create_parent_dirs {
      return mkdir(slice.data, DEFAULT_MODE) == 0;
    }

    if slice.length as u64 >= PATH_MAX as u64 {
      return false;
    }

    mut buf: [u8; PATH_MAX];
    mut i: u64 = 0;

    while i < slice.length {
      if slice[i] == '/' && i != 0 {
        mut j: u64 = 0;
        while j < i {
          buf[j] = slice[j];
          j += 1;
        }
        buf[i] = 0; 
        // >
        // attempt to create prefix (ignore errors, e.g. already exists)
        mkdir(buf, DEFAULT_MODE);
      }
      i += 1;
    }

    return mkdir(slice.data, DEFAULT_MODE) == 0;
  }

  // TODO: fix the recursive generic bug, if you use TSource and TDest here, it explodes.
  fn copy(source: String, dest: String) -> bool {
    src_slice := source.as_slice();
    dst_slice := dest.as_slice();

    src_dir_opt := Directory::open(src_slice);
    if src_dir_opt.is_none() {
      return false;
    }
    src_dir := src_dir_opt.unwrap();

    if !Directory::create(dst_slice, true) {
      return false;
    }

    for entry in src_dir.entries {
      if entry.as_str() == "." || entry.as_str() == ".." {
        continue;
      }

      using mut src_entry_path := String::from(src_slice);
      src_entry_path.push('/');
      src_entry_path.append(entry);

      using mut dst_entry_path := String::from(dst_slice);
      dst_entry_path.push('/');
      dst_entry_path.append(entry);

      stat_opt := Stat::new(src_entry_path);
      if stat_opt.is_none() {
        continue;
      }
      stat := stat_opt.unwrap();

      if stat.is_dir() {
        Directory::copy(src_entry_path, dst_entry_path);
      } else {
        File::copy(src_entry_path, dst_entry_path);
      }
    }

    return true;
  }
}

impl Destroy for Directory {
  fn destroy(*mut self, recursive: bool = true) {
    self.path.destroy();
    self.entries.destroy();
  }
}
