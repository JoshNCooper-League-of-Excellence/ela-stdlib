Shader :: struct {
  handle: u32
}

impl Shader {
  compile :: fn(kind: u32, source: c_str) -> u32 {
    shader: u32 = glCreateShader(kind);
    glShaderSource(shader, 1, &const source, null);
    glCompileShader(shader);

    mut success: s32;
    glGetShaderiv(shader, GL::COMPILE_STATUS, &mut success);
    if success == 0 {
      mut length: s32;
      glGetShaderiv(shader, GL::INFO_LOG_LENGTH, &const length);
      info_log: c_str = malloc(sizeof(c_str) * length);
      glGetShaderInfoLog(shader, length, &mut length, info_log);
      printf("Shader compilation failed: %s\n"c, info_log);
      free(info_log);
      return 0;
    }
    return shader;
  }

  compile_program :: fn(vert_source: c_str, frag_source: c_str) -> u32 {
    vertex_shader: u32 = Shader::compile(GL::VERTEX_SHADER, vert_source);
    fragment_shader: u32 = Shader::compile(GL::FRAGMENT_SHADER, frag_source);

    if vertex_shader == 0 || fragment_shader == 0 {
      return 0 as u32;
    }

    program: u32 = glCreateProgram();
    glAttachShader(program, vertex_shader);
    glAttachShader(program, fragment_shader);
    glLinkProgram(program);

    mut success: s32;
    glGetProgramiv(program, GL::LINK_STATUS, &mut success);
    if success == 0 {
      mut length: s32;
      glGetProgramiv(program, GL::INFO_LOG_LENGTH, &mut length);
      info_log: c_str = malloc(sizeof(c_str) * length);
      glGetProgramInfoLog(program, length, &mut length, info_log);
      printf("Program linking failed: %s\n"c, info_log);
      free(info_log);
      return 0 as u32;
    }

    glDeleteShader(vertex_shader);
    glDeleteShader(fragment_shader);

    return program;
  }



  use :: fn(*mut self) {
    glUseProgram(self.handle);
  }
  
  create :: fn(vertexSource: String, fragSource: String) -> #self {
    return .{
      handle: Shader::compile_program(vertexSource.data, fragSource.data),
    };
  }

  set_mat4 :: fn(*mut self, name: str, v: *const Mat4) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniformMatrix4fv(index, 1, false, v.values);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_vec4 :: fn(*mut self, name: str, v: *const Vec4) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform4fv(index, 1, v.values);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_vec3 :: fn(*mut self, name: str, v: *const Vec3) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform3fv(index, 1, v.values);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_vec2 :: fn(*mut self, name: str, v: *const Vec2) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform2fv(index, 1, v.values);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }
  
  set_float :: fn(*mut self, name: str, v: f32) {
    index := glGetUniformLocation(self.handle, name.data);
    if index != -1 {
      glUniform1f(index, v);
    } else {
      printf("failed to get uniform : %s\n"c, name.data);
    }
  }

  set :: fn!<T>(*mut self, name: str, v: T) {
    switch typeof(T) {
      typeof(f32): {
        self.set_float(name, *((&const v) as *const f32));
        return;
      }
      typeof(Vec2): {
        self.set_vec2(name, (&const v) as *const Vec2);
        return;
      }
      typeof(Vec3): {
        self.set_vec3(name, (&const v) as *const Vec3);
        return;
      }
      typeof(Vec4): {
        self.set_vec4(name, (&const v) as *const Vec4);
        return;
      }
      typeof(Mat4): {
        self.set_mat4(name, (&const v) as *const Mat4);
        return;
      }
    }
    printf("incompatible type with 'set' method on shader: only f32, Vec2/3/4, and Mat4 are currently supported\n"c);
  }
}

impl Deinit for Shader {
  deinit :: fn(*mut self) {
    glDeleteProgram(self.handle);
  }
}

Window :: struct {
  handle: *mut GLFWwindow
}

impl Window {
  create :: fn(width: s32, height: s32, title: str) -> #self {
    mut self: #self;
    
    if !glfwInit() {
      printf("Failed to initialize glfw\n"c);
      return self;
    }
    
    self.handle = glfwCreateWindow(width, height, title.data, null, null);
    
    if self.handle == null {
      printf("Failed to create window\n"c);
      glfwTerminate();
      return self;
    }
    
    glfwMakeContextCurrent(self.handle);
    
    if glewInit() != 0 {
      printf("Failed to initialize glew\n"c);
      glfwTerminate();
      return self;
    }
    
    return self;
  }
  
  should_close :: fn(*mut self) -> bool {
    return glfwWindowShouldClose(self.handle) as bool;
  }
  
  present :: fn(*mut self) {
    glfwSwapBuffers(self.handle);
    glfwPollEvents();
  }
  
  clear :: fn(flags: GL) {
    glClear(flags);
  }

  set_key_callback :: fn(*mut self, callback: fn*(*mut GLFWwindow, s32, s32, s32, s32)) {
    glfwSetKeyCallback(self.handle, callback);
  }
}

Camera :: struct {
  position: Vec3,
  target: Vec3,
  up: Vec3,
  fov: f32,
  aspect_ratio: f32,
  near: f32,
  far: f32,
  view: Mat4,
  projection: Mat4,
}

impl Camera {
  new :: fn(up: Vec3, fov: f32, aspect: f32, near: f32, far: f32) -> #self {
    return .{
      position: Vec3::zero(),
      target:   Vec3::zero(),
      up: up,
      fov: fov,
      aspect_ratio: aspect,
      near: near,
      far: far,
    }
  }

  update :: fn(*mut self) {
    self.view = Mat4::look_at(self.position, self.target, self.up);
    self.projection = Mat4::perspective(self.fov, self.aspect_ratio, self.near, self.far);
  }
}