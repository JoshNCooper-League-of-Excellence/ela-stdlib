/*
  These bindings were auto generated by 'ela-bindings-generator', from 'hmm.c' at 2025-09-21 07:28:32. 
*/

struct __m128;

union Vec2 {
  struct {
    x: f32, y: f32
  },

  struct {
    u: f32,
    v: f32,
  },

  struct {
    left: f32,
    right: f32,
  },

  struct {
    width: f32,
    height: f32,
  },

  elements: [f32; 2],
}

impl Index!<f32> for Vec2 {
  fn index(*self, index: u64) -> *f32 {
    return &self.elements[index];
  }
  fn index_mut(*mut self, index: u64) -> *mut f32 {
    return &mut self.elements[index];
  }
}

union Vec3 {
  struct {
    x: f32,
    y: f32,
    z: f32,
  },

  struct {
    U: f32,
    V: f32,
    W: f32,
  },

  struct {
    R: f32,
    G: f32,
    B: f32,
  },

  struct {
    XY: Vec2,
    _Ignored0: f32,
  },

  struct {
    _Ignored1: f32,
    YZ: Vec2,
  },

  struct {
    UV: Vec2,
    _Ignored2: f32,
  },

  struct {
    _Ignored3: f32,
    VW: Vec2,
  },

  elements: [f32; 3],
}

impl Index!<f32> for Vec3 {
  fn index(*self, index: u64) -> *f32 {
    return &self.elements[index];
  }
  fn index_mut(*mut self, index: u64) -> *mut f32 {
    return &mut self.elements[index];
  }
}

union Vec4 {
  struct {
    x: f32,
    y: f32,
    z: f32,
    w: f32,
  },

  struct {
    r: f32,
    g: f32,
    b: f32,
    a: f32,
  },

  struct {
    xyz: Vec3,
    _ignored0: f32,
  },

  struct {
    _ignored1: f32,
    yzw: Vec3,
  },

  struct {
    xy: Vec2,
    zw: Vec2,
  },

  elements: [f32; 4],
}

impl Index!<f32> for Vec4 {
  fn index(*self, index: u64) -> *f32 {
    return &self.elements[index];
  }
  fn index_mut(*mut self, index: u64) -> *mut f32 {
    return &mut self.elements[index];
  }
}

union Mat2 {
  struct {
    m00: f32, m01: f32,
    m10: f32, m11: f32,
  },

  columns: [Vec2; 2],
  elements: [[f32; 2]; 2],
}

union Mat3 {
  struct {
    m00: f32, m01: f32, m02: f32,
    m10: f32, m11: f32, m12: f32,
    m20: f32, m21: f32, m22: f32,
  },

  columns: [Vec3; 3],
  elements: [[f32; 3]; 3],
}

union Mat4 {
  struct {
    m00: f32, m01: f32, m02: f32, m03: f32,
    m10: f32, m11: f32, m12: f32, m13: f32,
    m20: f32, m21: f32, m22: f32, m23: f32,
    m30: f32, m31: f32, m32: f32, m33: f32,
  },

  columns: [Vec4; 4],
  elements: [[f32; 4]; 4],
}

struct Quat {
  x: f32,
  y: f32,
  z: f32,
  w: f32,
  elements: [f32; 4],
}


extern fn vec2_add(Left: Vec2, Right: Vec2) -> Vec2;
extern fn vec3_add(Left: Vec3, Right: Vec3) -> Vec3;
extern fn vec2_sub(Left: Vec2, Right: Vec2) -> Vec2;
extern fn vec3_sub(Left: Vec3, Right: Vec3) -> Vec3;

extern fn HMM_MulV2(Left: Vec2, Right: Vec2) -> Vec2;
extern fn HMM_MulV2F(Left: Vec2, Right: f32) -> Vec2;
extern fn HMM_MulV3(Left: Vec3, Right: Vec3) -> Vec3;
extern fn vec3_scale(Left: Vec3, Right: f32) -> Vec3;


extern fn HMM_DivV2(Left: Vec2, Right: Vec2) -> Vec2;
extern fn HMM_DivV2F(Left: Vec2, Right: f32) -> Vec2;
extern fn HMM_DivV3(Left: Vec3, Right: Vec3) -> Vec3;
extern fn HMM_DivV3F(Left: Vec3, Right: f32) -> Vec3;


extern fn HMM_DotV2(Left: Vec2, Right: Vec2) -> f32;
extern fn HMM_DotV3(Left: Vec3, Right: Vec3) -> f32;

extern fn cross(Left: Vec3, Right: Vec3) -> Vec3;
extern fn HMM_LenSqrV2(A: Vec2) -> f32;
extern fn HMM_LenSqrV3(A: Vec3) -> f32;

extern fn HMM_LenV2(A: Vec2) -> f32;
extern fn HMM_LenV3(A: Vec3) -> f32;

extern fn HMM_NormV2(A: Vec2) -> Vec2;
extern fn vec3_normalize(A: Vec3) -> Vec3;

extern fn HMM_LerpV2(A: Vec2, Time: f32, B: Vec2) -> Vec2;
extern fn HMM_LerpV3(A: Vec3, Time: f32, B: Vec3) -> Vec3;





















































extern fn HMM_RotateV3AxisAngle_LH(V: Vec3, Axis: Vec3, Angle: f32) -> Vec3;
extern fn HMM_RotateV3AxisAngle_RH(V: Vec3, Axis: Vec3, Angle: f32) -> Vec3;
extern fn __hmm_invalid_generic() -> void;
extern fn vec2_zero() -> Vec2;
extern fn vec2_one() -> Vec2;
extern fn vec3_zero() -> Vec3;
