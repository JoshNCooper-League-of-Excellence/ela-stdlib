
trait Writer!<T> {
  fn write(*mut self, value: T);
  fn write_many(*mut self, values: [T]) {
    for v in values {
      self.write(v);
    }
  }
}

trait Reader!<T> {
  fn read(*mut self) -> Option!<T>;

  // Attempt to read 'length' bytes, until the end of the stream.
  // hence 'try' because there's no guarantee that return(list.length) == param(length)
  fn try_read_many(*mut self, mut length: u32) -> List!<T> {
    mut list: List!<T>;
    list.resize(length);
    while length > 0 {
      if self.read() is Option!<T>::Some(v) {
        list.push(v);
        length -= 1;
      } else {
        break;
      }
    }
    return list;
  }
}

trait Buffered!<T> {
  fn flush(*mut self);
  fn clear(*mut self);
}
