// forward declare format symbols.
// #global just exports this module to the global module/namespace.
#global module fmt {
  struct FormatOptions;
  fn to_string!<T>(value: T, options: FormatOptions, allocator: dyn Allocator = get_global_allocator()) -> String;
  fn format!<Tuple>(fmt : str, tuple: Tuple, options: FormatOptions = .{}, allocator: dyn Allocator = get_global_allocator()) -> String where Tuple: IsTuple;  
};

//module stream;

trait Writer!<T> {
  fn write(*mut self, value: T);
  fn write_many(*mut self, values: [T]) {
    for v in values {
      self.write(v);
    }
  }
  // ! I have no idea how this is even getting FormatOptions and format!<T>, but it seems to work?
  // ! There are a ton of namespacing and module bugs.

  // ! Right now, whatever is importin gthis and calling it must define fmt and import these symbols.
  // ! it doesn't error until called without those symbols, which is even weirder.
  fn writef!<TupleT>(*mut self, fmt_string: str, tuple: TupleT, options: fmt::FormatOptions, allocator: dyn Allocator) {
    using formatted_string := fmt::format(fmt_string, tuple, options, allocator);
    self.write_many(formatted_string.as_slice());
  }
}

trait Reader!<T> {
  fn read(*mut self) -> Option!<T>;

  // Attempt to read 'length' bytes, until the end of the stream.
  // hence 'try' because there's no guarantee that return(list.length) == param(length)
  fn try_read_many(*mut self, mut length: u32) -> List!<T> {
    mut list: List!<T>;
    list.resize(length);
    while length > 0 {
      if self.read() is Option!<T>::Some(v) {
        list.push(v);
        length -= 1;
      } else {
        break;
      }
    }
    return list;
  }
}

trait Buffered!<T> {
  fn flush(*mut self);
  fn clear(*mut self);
}
