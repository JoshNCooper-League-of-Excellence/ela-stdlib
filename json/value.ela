/* 
  Refactor progress -- Compiling
*/

import fmt::{
  FormatOptions,
  stringstream::{
    StringStream,
  },
  Format,
  Formatter,
};

import map::*;

choice JsonValue {
  Null(),
  Number(f64),
  Bool(bool),
  String(String),
  Array(List!<*mut JsonValue>),
  Object(Map!<String, *mut JsonValue>)
}

impl Destroy for JsonValue {
  fn destroy(*mut self, recursive: bool = true) {
    switch is self {
      JsonValue::Object(map): {
        for key, value in map {
          key.destroy();
          value.destroy();
          std::c::free(value); // TODO: use allocator
        }
        map.destroy();
      }
      JsonValue::Array(array): {
        for val in array {
          val.destroy();
          std::c::free(val);  // TODO: use allocator
        }
        array.destroy();
      }
      JsonValue::String(s): {
        s.destroy();
      }
    }
  }
}

impl Index!<JsonValue> for JsonValue {
  fn index(*const self, index: u64) -> *const JsonValue {
    if self is JsonValue::Array(v) {
      if index < 0 || index >= v.length {
        return null;
      }
      return v[index];
    }
    return null;
  }

  fn index_mut(*mut self, index: u64) -> *mut JsonValue {
    if self is JsonValue::Array(v) {
      if index < 0 || index >= v.length {
        return null;
      }
      return v[index];
    }
    return null;
  }
}

struct Writer {
  builder: StringStream,
  options: FormatOptions,
  indentation: (u16 /* depth */, u8 /* width in spaces */),
}

impl Writer {
  fn new() -> Self {
    options := FormatOptions.{
      indented: true,
      quote_strings: true,
      // TODO: JSON spec doesn't preserve formatting of digits, it trims all trailing zeros.
      // TODO: We need a way to tell our format options to do this, it's nice anyway
      digits_after_decimal: 8,
    };
    return .{
      builder: .{},
      options: options,
      indentation: (0, 2),
    }
  }

  fn indent(*mut self, depth_change: s8) {
    if depth_change > 0  {
      self.indentation.0 += depth_change;
    } else if depth_change < 0 {
      self.indentation.0 += depth_change;
      if self.indentation.0 < 0
        then self.indentation.0 = 0;
      return;
    }

    depth, width := self.indentation;
    if depth > 0 && width > 0 {
      mut indent: String;
      for i in 0..(depth * width) {
        indent.push(' ');
      }
      self.builder.append_then_free(indent);
    }
  }

  fn newline(*mut self) {
    if self.options.indented {
      self.builder.append_byte('\n');
      self.indent(0);
    }
  }

  fn write!<DataSlice>(*mut self, data: DataSlice) where DataSlice: AsSlice!<u8> {
    self.builder.append(data);
  }

  fn writef!<Tuple>(*mut self, fmt: str, args: Tuple) where Tuple: IsTuple {
    self.builder.appendf(fmt, args, self.options);
  }

  fn write_byte(*mut self, byte: u8) {
    self.builder.append_byte(byte);
  }
}

impl Destroy for Writer {
  fn destroy(*mut self, recursive: bool = true) {
    self.builder.destroy();
  }
}

impl JsonValue {
  fn to_string(*const self, writer: *mut Writer) {
    switch is self {
      JsonValue::Object(map): {
        writer.write_byte('{');
        writer.indent(1);
        writer.newline();
        mut idx := 0;
        for key, value in map {
          if idx != 0 {
            writer.write(", ");
            writer.newline();
          }
          idx++;
          writer.writef("%", (key,));
          writer.write(": ");
          value.to_string(writer);
        }
        writer.indent(-1);
        writer.newline();
        writer.write_byte('}');
      }
      JsonValue::Array(array): {
        writer.write_byte('[');
        writer.indent(1);
        writer.newline();
        mut idx := 0;
        for val in array {
          if idx != 0 {
            writer.write(", ");
            writer.newline();
          }
          idx++;
          val.to_string(writer);
        }
        writer.indent(-1);
        writer.newline();
        writer.write_byte(']');
      }
      JsonValue::Number(num): {
        writer.writef("%", (num,));
      }
      JsonValue::String(s): {
        writer.writef("%", (s,));
      }
      JsonValue::Bool(b): {
        value : str = if b { return "true"; } else { return "false"; };
        writer.write(value);
      }
      else: {
        writer.write("null");
      }
    }
  }
}

impl JsonValue {
  fn stringify(*const self) -> String {
    mut writer := Writer::new();
    self.to_string(&mut writer);
    data := writer.builder.get_string();
    writer.destroy();
    return data;
  }

  fn get(*mut self, key: String) -> Option!<*mut JsonValue> {
    if self is JsonValue::Object(mut obj) {
      return obj.get(key);
    }
    return None();
  }

  fn is_number(*mut self)  -> bool {
    if self is JsonValue::Number {
      return true;
    }
    return false;
  }

  fn is_string(*mut self)  -> bool {
    if self is JsonValue::String {
      return true;
    }
    return false;
  }

  fn is_object(*mut self)  -> bool {
    if self is JsonValue::Object {
      return true;
    }
    return false;
  }

  fn is_array(*mut self)   -> bool {
    if self is JsonValue::Array {
      return true;
    }
    return false;
  }
    
  fn is_bool(*mut self) -> bool {
    if self is JsonValue::Bool {
      return true;
    }
    return false;
  }
  
  fn is_null(*mut self)    -> bool {
    if self is JsonValue::Null {
      return true;
    }
    return false;
  }

  fn as_number(*mut self) -> Option!<*mut f64> {
    if self is JsonValue::Number(&mut num) {
      return Some(num);
    }
    return None();
  }

  fn as_string(*mut self) -> Option!<*mut String> {
    if self is JsonValue::String(&mut s) {
      return Some(s);
    }
    return None();
  }

  fn as_object(*mut self) -> Option!<*mut Map!<String, *mut JsonValue>> {
    if self is JsonValue::Object(&mut obj) {
      return Some(obj);
    }
    return None();
  }

  fn as_array(*mut self) -> Option!<*mut List!<*mut JsonValue>> {
    if self is JsonValue::Array(&mut arr) {
      return Some(arr);
    }
    return None();
  }

  fn as_bool(*mut self) -> Option!<*mut bool> {
    if self is JsonValue::Bool(&mut b) {
      return Some(b);
    }
    return None();
  }
}

impl Format for JsonValue {
  fn format(*const self, formatter: *mut Formatter) {
    mut writer := Writer::new();
    writer.builder = *formatter.writer;
    self.to_string(&mut writer);
    *formatter.writer = writer.builder;
  }
}