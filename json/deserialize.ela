fn deserialize_any(value: *mut JsonValue, object: any) -> Option!<String>;

fn deserialize_struct(value: *mut JsonValue, object: any) -> Option!<String> {
  obj := value.as_object().unwrap();
  for key, value in *obj {
    struct_field := object.ty.get_field(key);

    if !struct_field {
      Some(format("Could not find field \"%\" in type \"%\"", (key, object.ty.name), FormatOptions::default()));
    }

    any_value : any = .{
      ptr: object.ptr as *mut u8 + object.ty.offset(struct_field.name),
      ty: struct_field.ty,
    };

    result := deserialize_any(value, any_value);

    if result.is_some() {
      return result; // TODO stop using option as an error type its confusing
    }
  }
  return None();
}

fn deserialize_scalar(value: *mut JsonValue, object: any) -> Option!<String> {
  if (!object.ty.has_no_extension()) {
    return Some(String::from("Unable to deserialize into pointer type with 'deserialize_scalar'"));
  }

  if object.ty.is_bool() {
    *(object.ptr as *mut bool) = value.as_bool().unwrap();
  } else if (object.ty.is_float()) {
    if (object.ty.size == 8) {
      *(object.ptr as *mut f64) = *(value.as_number().unwrap() as *f64);
    } else {
      *(object.ptr as *mut f32) = *(value.as_number().unwrap() as *f64);
    }
  } else if (object.ty.is_integral()) {
    is_signed := object.ty.is_signed();
    switch object.ty.size {
        8: {
          if is_signed {
            *(object.ptr as *mut s64) = *(value.as_number().unwrap() as *s64);
          } else {
            *(object.ptr as *mut u64) = *(value.as_number().unwrap() as *u64);
          }
        }
        4: {
          if is_signed {
            *(object.ptr as *mut s32) = *(value.as_number().unwrap() as *s32);
          } else {

            *(object.ptr as *mut u32) = *(value.as_number().unwrap() as *u32);
          }
        }
        2: {
          if is_signed {
            *(object.ptr as *mut s16) = *(value.as_number().unwrap() as *s16);
          } else {
            *(object.ptr as *mut u16) = *(value.as_number().unwrap() as *u16);
          }
        }
        1: {
          if is_signed {
            *(object.ptr as *mut s8) = *(value.as_number().unwrap() as *s8);
          } else {
            *(object.ptr as *mut u8) = *(value.as_number().unwrap() as *u8);
          }
        }
    }
  } else {
    return Some(format("Unable to deserialize into type \"%\"", (object.ty.name,), FormatOptions::default()));
  }
  return None();
}

fn deserialize_any(value: *mut JsonValue, object: any) -> Option!<String> {
  if object.ty.implements("Serializable") {
    dynamic := new_dyn_serializable(object);
    return dynamic.deserialize(value);
  }

  if value.is_object() {
    if object.ty.is_struct() {
      return deserialize_struct(value, object);
    } else {
      return Some(format("Type mismatch: object to %", (object.ty.name,), FormatOptions::default()));
    }
  } else if object.ty == type_of(String) {
    *(object.ptr as *mut String) = value.as_string().unwrap().clone();
    return None();
  } else if object.ty == type_of(str) {
    mut string := value.as_string().unwrap();
    cloned := string.clone();
    *(object.ptr as *mut str) = cloned.as_str();
    return None();
  }
  return deserialize_scalar(value, object);
}

fn deserialize!<T>(value: *mut JsonValue, object: *mut T) -> Option!<String> {
  where T: Serializable {
    return object.deserialize(value);
  }
  else {
    return deserialize_any(value, any.{
      ptr: object,
      ty: type_of(T),
    });
  }
}
