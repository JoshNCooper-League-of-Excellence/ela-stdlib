type JsonResult :: Result!<*mut JsonValue, String>;

fn parse(lexer: *mut JsonLexer) -> JsonResult {
  mut token_result := lexer.expect_types(.[
    TokenType::LBracket,
    TokenType::LCurly,
    TokenType::Number,
    TokenType::String,
    TokenType::True,
    TokenType::False,
    TokenType::Null,
  ]);

  if token_result.is_err()
    then return token_result.propagate();

  value := new(JsonValue::Null);

  mut token := token_result.unwrap();

  switch token._type {
    TokenType::LBracket: {
      *value = JsonValue::Array(.{});
      token = lexer.peek();

      if token._type == TokenType::RBracket {
        lexer.eat();
        return JsonResult::Ok(value);
      }

      while token._type != TokenType::RBracket {
        value_result := parse(lexer);

        if value_result.is_err() {
          return value_result.propagate();
        }

        value.as_array().unwrap().push(value_result.unwrap());

        token_result = lexer.expect_types(.[
          TokenType::RBracket, 
          TokenType::Comma
        ]);

        if token_result.is_err() {
          return token_result.propagate();
        }

        token = token_result.unwrap();
      }
    }
    TokenType::LCurly: {
      *value = JsonValue::Object(.{});

      if lexer.peek()._type == TokenType::RCurly {
        lexer.eat();
        return JsonResult::Ok(value);
      }

      while token._type != TokenType::RCurly {
        token_result = lexer.expect_type(TokenType::String);

        if token_result.is_err()  {
          return token_result.propagate();
        }
        
        key_token := token_result.unwrap();
        token_result = lexer.expect_type(TokenType::Colon);

        if token_result.is_err() {
          return token_result.propagate();
        }

        value_result := parse(lexer);

        if value_result.is_err() {
          return value_result.propagate();
        }
        
        val := value_result.unwrap();

        value.as_object().unwrap().insert(key_token.value, val);

        token_result = lexer.expect_types(.[
          TokenType::RCurly, 
          TokenType::Comma
        ]);

        if token_result.is_err() {
          return token_result.propagate();
        }

        token = token_result.unwrap();
      }
    }
  }
  
  if token._type == TokenType::Number {
    *value = JsonValue::Number(std::c::atof(token.value.data));
  } else if token._type == TokenType::String {
    *value = JsonValue::String(token.value);
  } else if token._type == TokenType::True {
    *value = JsonValue::Bool(true);
  } else if token._type == TokenType::False {
    *value = JsonValue::Bool(false);
  }

  return JsonResult::Ok(value);
}

fn parse_file(file: str) -> JsonResult {
  result := File::read_all(file);

  if result is Result!<String, String>::Err(err) {
    return JsonResult::Err(err);
  }

  mut lexer := JsonLexer::create(file, result.unwrap());
  return parse(&mut lexer);
}

fn parse_string(s: str) -> JsonResult {
  mut lexer := JsonLexer::create(":<loaded from string>:".to_string(get_global_allocator()), s.to_string(get_global_allocator()));
  return parse(&mut lexer);
}