
#ifndef FREESTANDING {
  struct Libc_Allocator {}
  impl Allocator for Libc_Allocator {
    fn allocate(*mut self, size: u64) -> *mut void {
      return malloc(size);
    }
    fn free(*mut self, ptr: *mut void) {
      free(ptr);
    }
    fn resize(*mut self, ptr: *const void, element_size: u64, new_size: u64) -> *mut void {
      return realloc(ptr, element_size * new_size);
    }
    fn allocate_array(*mut self, size: u64, n: u64) -> *mut void {
      return calloc(size, n);
    }
    fn copy(*mut self, ptr: *const void, element_size: u64, n: u64) -> *mut void {
      newptr := self.allocate_array(element_size, n);
      memcpy(newptr, ptr, n * element_size);
      return newptr;
    }
    fn deinit(*mut self) {}
  }
  impl Libc_Allocator {
    fn get() -> #self {
      #static self: #self;
      return self;
    }
  }
  struct Tracking_Allocator {
    pointers: *mut *mut void,
    length: u64,
    capacity: u64,
  }
  impl Tracking_Allocator {

    fn push_pointer(*mut self, ptr: *mut void) {
      if self.length + 1 > self.capacity {
        if self.capacity == 0 then self.capacity = 4;
        self.capacity *= 2;
        self.pointers = realloc(self.pointers, sizeof(*const void) * self.capacity);
      }
      self.pointers[self.length] = ptr;
      self.length += 1;
    }

    fn contains_pointer(self, ptr: *mut void) -> bool {
      for i in 0..self.length {
        if self.pointers[i] == ptr {
          return true;
        }
      }
      return false;
    }

    fn remove_pointer(*mut self, ptr: *const void) {
      for i in 0..self.length {
        if self.pointers[i] == ptr {
          memmove(self.pointers + i, self.pointers + i + 1, sizeof(*const void) * (self.length - i - 1));
          self.length -= 1;
          break;
        }
      }
    }
  }
  impl Allocator for Tracking_Allocator {
    fn deinit(*mut self) {
      while self.length > 0 {
        free(self.pointers[self.length - 1]);
        self.length -= 1;
      }
      free(self.pointers);
      self.pointers = null;
      self.capacity = 0;
    }

    fn allocate(*mut self, size: u64) -> *mut void {
      ptr := malloc(size);
      self.push_pointer(ptr);
      return ptr;
    }

    fn free(*mut self, ptr: *mut void) {
      self.remove_pointer(ptr);
      free(ptr);
    }

    fn allocate_array(*mut self, size: u64, n: u64) -> *mut void {
      ptr := calloc(size, n);
      self.push_pointer(ptr);
      return ptr;
    }

    fn resize(*mut self, ptr: *const void, element_size: u64, new_size: u64) -> *mut void {
      self.remove_pointer(ptr);
      pointer := realloc(ptr, element_size * new_size);
      self.push_pointer(pointer);
      return pointer;
    }

    fn copy(*mut self, ptr: *const void, element_size: u64, n: u64) -> *mut void {
      new_ptr := self.allocate_array(element_size, n);
      memcpy(new_ptr, ptr, n * element_size);
      return new_ptr;
    }
  }
}

#ifndef FREESTANDING {
  fn get_default_allocator() -> *mut dyn Allocator {
    #static mut allocator: Libc_Allocator;
    #static mut instance: *mut dyn Allocator = null;

    if !instance 
      then instance = new(dynof(&mut allocator, Allocator));
      
    return instance;
  }
} else {
  fn get_default_allocator() -> *mut dyn Allocator {
    #static mut allocator: *mut dyn Allocator;
    return allocator;
  }
}