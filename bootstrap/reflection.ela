struct Field {
  name: str,
  type: *const Type,
  size: u64,
  offset: u64,
  enum_value: s64,
};

struct Type {
  id: s32,                                                          // the integer ID used to identify this type.
  name: str,
  size: u64,                                                        // sizeof(T)
  flags: u64,                                                       // defined in reflection.ela and emit.cpp, the values of the flags.
  fields: List!<Field>,                                                  // get a list of struct fields, enum variants.
  element_type: *const Type,                                        // the type this type has a pointer to, is an array of, etc.

  generic_args: List!<*const Type>,                                 // a list of the generic arguments.
  traits: List!<*const Type>,                                       // a list of implemented traits.

  //// TODO: maybe we can make this more type safe in the future.
  methods:    List!<(str, *const void)>,                                   // a list of method function pointers, 
};

#ifndef FREESTANDING {
  impl Field {
    fn set!<T, T1>(*const self, target: *mut T, data: T1) {
      memcpy((target as *mut u8) + self.offset, (&const data) as *const u8, sizeof(T1));
    }
    fn get!<T>(*const self, source: *const T) -> *mut u8 {
      return source as *mut u8 + self.offset;
    }
  }

  _type_info: List!<*const Type>;

  impl Type {
    fn get_field!<Path>(*const self, name: Path) -> *const Field where Path: AsByteSlice {
      slice := name.as_byte_slice();
      for i in 0..self.fields.length {
        field := &mut self.fields[i];
        string : str = .{data: slice.data, length:  slice.length};
        if field.name == string {
          return field;
        }
      }
      return null;
    }

    fn offset(*const self, member: str) -> u64 {
      for field in self.fields {
        if field.name == member  {
          return field.offset;
        }
      }
      return -1;
    }
  }
}

#flags enum TypeFlags {
  INTEGER,
  FLOAT,
  BOOL,
  STRING,
  STRUCT,
  CHOICE,
  ENUM,
  TUPLE,
  ARRAY,
  FUNCTION,
  POINTER,
  SIGNED,
  UNSIGNED,
  TRAIT,
  UNION,
}

impl Type  {
  fn is_trait(*const self) -> bool {
    return self.flags & TypeFlags::TRAIT != 0;
  }
  fn is_signed(*const self) -> bool {
    return self.flags & TypeFlags::SIGNED != 0;
  }

  fn is_unsigned(*const self) -> bool {
    return self.flags & TypeFlags::UNSIGNED != 0;
  }

  fn has_no_extension(*const self) -> bool {
    return self.flags & TypeFlags::POINTER == 0 &&
          self.flags & TypeFlags::ARRAY == 0;
  }

  fn is_array(*const self) -> bool {
    return self.flags & TypeFlags::ARRAY != 0;
  }

  fn is_string(*const self) -> bool {
    return self.flags & TypeFlags::STRING != 0;
  }

  fn is_scalar(*const self) -> bool {
    return Type::has_no_extension(self) &&
          (self.flags & TypeFlags::INTEGER != 0 ||
            self.flags & TypeFlags::FLOAT != 0   ||
            self.flags & TypeFlags::BOOL != 0    ||
            self.flags & TypeFlags::STRING != 0);
  }

  fn is_struct(*const self) -> bool {
    return self.flags & TypeFlags::STRUCT != 0;
  }

  fn is_enum(*const self) -> bool {
    return self.flags & TypeFlags::ENUM != 0;
  }

  fn is_integral(*const self) -> bool {
    return self.flags & TypeFlags::INTEGER != 0;
  }

  fn is_float(*const self) -> bool {
    return self.flags & TypeFlags::FLOAT != 0;
  }

  fn is_bool(*const self) -> bool {
    return self.flags & TypeFlags::BOOL != 0;
  }

  fn is_tuple(*const self) -> bool {
    return self.flags & TypeFlags::TUPLE != 0;
  }

  fn is_function(*const self) -> bool {
    return self.flags & TypeFlags::FUNCTION != 0;
  }

  fn is_pointer(*const self) -> bool {
    return self.flags & TypeFlags::POINTER != 0;
  }

  fn is_choice(*const self) -> bool {
    return self.flags & TypeFlags::CHOICE != 0;
  }

  fn is_union(*const self) -> bool {
    return self.flags & TypeFlags::UNION != 0;
  }
}

impl any {
  fn from!<T>(t: *mut T) -> #self {
    return .{
      ptr: t,
      type: typeof(T),
    }
  }

  // return the pointer behind this any, or if the type isn't matched,
  // return null.
  fn cast!<T>(*const self) -> *mut T {
    if !type then type = typeof(T);
    if type != self.type then return null;
    return self.ptr as *mut T;
  }

  // an unchecked version of the 'cast' method.
  // this will return junk data, or worse, if you pass in the wrong type to cast to.
  // use cast anywhere you can, it's much more type safe.
  fn unwrap!<T>(*const self) -> T {
    return *(self.ptr as *const T);
  }
}

#ifndef FREESTANDING {
  impl any {
    fn new!<T, Alloc>(t: T, alloc: *mut Alloc) -> #self where Alloc: Allocator | Dyn_Allocator {
      ptr : *mut T = alloc.allocate(sizeof(T));
      *ptr = t;
      return .{
        ptr: ptr,
        type: typeof(T),
      }
    }
  }
  impl Deinit for any {
      // this should only be used for an any created with any::new()
    // clearly because it memcpy's it into place.
    fn deinit(*mut self) {
      free(self.ptr);
    }
  }
}

struct ElementIter {
  ptr: *mut u8,
  end: *const u8,
  element_type: *const Type,
}

impl Iterator!<any> for ElementIter {
  // Advances the iterator to the next element in the collection.
  fn next(*mut self) -> Option!<any> {
    if self.ptr >= self.end {
      return None();
    }
    value := Some(any.{ptr: self.ptr, type: self.element_type});
    self.ptr += self.element_type.size;
    return value;
  }
}

impl Type {
  fn elements(self, ptr: *const u8) -> ElementIter {
    if self.name.starts_with("List!<") {
      length_field := self.fields.find_first_of (
        fn (field: *const Field) -> bool {
          return field.name.eq("length");
        }
      );

      data_field := self.fields.find_first_of(
        fn (field: *const Field) -> bool {
          return field.name.eq("data");
        }
      )

      length := *(length_field.get(ptr) as *const u64);
      data   := *(data_field.get(ptr) as *const *const u8);

      element_type := self.generic_args[0];
      end := data + length * element_type.size;
      return .{ptr: data as *mut u8, end: end, element_type: element_type};
    } else {
      return .{
        ptr: ptr as *mut u8,
        end: ptr + self.size,
        element_type: self.element_type,
      };
    }
  }
}

struct TupleElementIter {
  ptr: *mut u8,
  element_index: u64,
  tuple_type: *const Type,
}

impl Iterator!<any> for TupleElementIter {
  fn next(*mut self) -> Option!<any> {
    if self.element_index >= self.tuple_type.fields.length {
      return None();
    }
    field := self.tuple_type.fields[self.element_index];

    element_type := field.type;
    offset := self.tuple_type.offset(field.name);
    value : any = .{
      ptr: self.ptr + offset,
      type: element_type
    };
    self.element_index++;
    return Some(value);
  }
}

impl Type {
  fn tuple_elements(*const self, instance: *mut u8) -> TupleElementIter {
    return .{
      ptr: instance,
      element_index: 0,
      tuple_type: self,
    }
  }
}

impl Type {
  fn implements(*const self, trait_name: str) -> bool {
    for _trait in self.traits {
      if _trait.name == trait_name {
        return true;
      }
    }
    return false;
  }
}