impl StringUtils for str {}

impl str {
  fn to_string!<Alloc>(self, allocator: Alloc) -> String where Alloc: Allocator | dyn Allocator {
    return .{
      data: allocator.copy(self.data, sizeof(u8), self.length),
      length: self.length,
    };
  }

  fn from_ptr(ptr: *u8, mut length: s32 = -1) -> Self {
    if length < 0 {
      length = std::string::length(ptr);
    }
    return .{
      data: ptr,
      length: length as u64
    };
  }

  fn view_from!<StringT>(v: StringT) -> Self where StringT: AsSlice!<u8> {
    slice := v.as_slice();
    return .{
      data: slice.data,
      length: slice.length
    }
  }


  fn join!<SepT>(strings: [str], separator: SepT) -> String 
    where SepT: AsSlice!<u8> 
  {
    sep := separator.as_slice();
    mut result: String;
    for i in 0..strings.length {
      result.append(strings[i]);
      if i + 1 < strings.length {
        result.append(sep);
      }
    }
    return result;
  }
}

impl Index!<u8> for str {
  fn index(*const self, idx: u64) -> *const u8 {
    return &const self.data![idx];
  }
  fn index_mut(*mut self, idx: u64) -> *mut u8 {
    return &mut self.data![idx];
  }
}

impl Slice_Index!<u8> for str {
  fn slice_index(*self, mut range: Range) -> [u8] {
    mut begin: Range::V = default();
    if range.begin is Option!<Range::V>::Some(b) {
      begin = b;
    }

    mut end: Range::V = default();
    if range.end is Option!<Range::V>::Some(e) {
      end = e;
    } else {
      end = self.length;
    }

    if end > self.length {
      panic("unable to create subslice from slice in [T][begin..start] (slice_index operator): range exceeded bounds of slice.\nWe no longer truncate invalid slices, and -1 is no longer a valid indicator for end. use 'begin..' syntax");
    }

    length := end - begin;
    
    if length <= 0 {
      panic("got a range in [T][begin..start] (slice_index operator) for which length was negative, or zero");
    }

    return .{
      data: self.data + begin,
      length: length,
    }
  }
}


// This iterator is over the bytes.
impl Iterable for str { 
  fn iter(*const self) -> Iter!<u8> {
    return .{
      ptr: self.data as *mut u8,
      end: self.data + self.length,
    }
  }
  fn iter_mut(*mut self) -> IterMut!<u8> {
    return .{
      ptr: self.data as *mut u8,
      end: (self.data + self.length),
    }
  }
}

impl PartialEq!<str> for str {
  fn eq(self, other: Self) -> bool {
    if self.length != other.length then return false;
    for idx in 0..self.length {
      if self[idx] != other[idx] then return false;
    }
    return true;
  }
}

impl Hash for str {
	fn hash(self) -> u64 {
		mut hash : u64 = 0xCBF29CE484222325;
		for byte in self {
			hash ^= byte;
			hash *= 0x100000001B3;
		}
		return hash;
	}
}

impl AsSlice!<u8> for str {
  fn as_slice(self) -> [u8] {
    return .{
      data: self.data,
      length: self.length
    }
  }
}
