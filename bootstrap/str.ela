// impl StringUtils for str {}
impl str {
  is_empty :: fn(self) -> bool => self.length == 0;

  empty :: fn() -> #self {
    return .{};
  }

  front :: fn(self) -> Option!<u8> {
    if self.length == 0 then return None();
    return Some(self.data[0]);
  }

  back :: fn(self) -> Option!<u8> {
    if self.length == 0 then return None();
    return Some(self.data[self.length - 1]);
  }

  starts_with :: fn!<Prefix>(self, prefix: Prefix) -> bool where Prefix: AsByteSlice {
    data, length := prefix.as_byte_slice();
    if self.length < length then return false;

    for i in 0..length {
      if self.data[i] != data[i] 
        then return false;
    }

    return true;
  }
  ends_with :: fn!<Prefix>(self, suffix: Prefix) -> bool where Prefix: AsByteSlice {
    data, length := suffix.as_byte_slice();
    if self.length < length then return false;
    for i in 0..length {
      if self.data[self.length - length + i] != data[i] then return false;
    }
    return true;
  }
  is_empty_or_whitespace :: fn(self) -> bool {
    for i in 0..self.length {
      ch := self.data[i];
      if !isspace(ch) {
        return false;
      }
    }
    return true;
  }
}
// ! replace the above impl with StringUtils

impl str {
  to_string :: fn!<Alloc>(self, allocator: *mut Alloc) -> String where Alloc: Allocator | Dyn_Allocator {
    return .{
      data: allocator.copy(self.data, sizeof(u8), self.length),
      length: self.length,
    };
  }
}

impl Subscript!<u8> for str {
  subscript :: fn(*const self, idx: u64) -> *const u8 {
    return &const self.data[idx];
  }
  subscript_mut :: fn(*mut self, idx: u64) -> *mut u8 {
    return &mut self.data[idx];
  }
}

impl str {
  slice :: fn(*mut self, range: Range) -> Slice!<u8> {
    start, end := (range.begin, range.end);
    length := end - start;

    if start < 0 || length < 0 || start + length > self.length {
      return .{};
    }
    
    return .{
      data: self.data + start,
      length: length,
    };
  }
}

// This iterator is over the bytes.
impl Iterable for str { 
  iter :: fn(*const self) -> Iter!<u8> {
    return .{
      ptr: self.data as *mut u8,
      end: self.data + self.length,
    }
  }
  iter_mut :: fn(*mut self) -> IterMut!<u8> {
    return .{
      ptr: self.data as *mut u8,
      end: (self.data + self.length),
    }
  }
}

impl Eq for str {
  eq :: fn(self, other: #self) -> bool {
    if self.length != other.length then return false;
    for idx in 0..self.length {
      if self[idx] != other[idx] then return false;
    }
    return true;
  }
  
  neq :: fn(self, other: #self) -> bool {
    return !self.eq(other);
  }
}

impl Hash for str {
	hash :: fn(self) -> u64 {
		mut hash : u64 = 0xCBF29CE484222325;
		for byte in self {
			hash ^= byte;
			hash *= 0x100000001B3;
		}
		return hash;
	}
}

impl AsCharSlice for str {
  as_char_slice :: fn(self) -> Slice!<u32> {
    return .{
      data: self.data,
      length: self.length,
    }
  }
}

impl AsByteSlice for str {
  as_byte_slice :: fn(self) -> Slice!<u8> {
    return .{
      data: self.data,
      length: self.length
    }
  }
}
