// Obviously, LIBC is only available when not in a freestanding environment.
// TODO: add a bunch more libc functions as needed.
// this is very limited to what i've done in the language so far and a ton is missing.
module std {
  module c {
    struct FILE;
    struct DIR;

    struct DirEntry {
      d_ino: u64,
      d_off: u64,
      d_reclen: u16,
      d_type: u8,
      d_name: [u8; 256],
    }

    const EOF := -1;

    struct Time_Spec {
      tv_sec: s64,
      tv_nsec: s64,
    };

    struct Stat {
      st_dev: u64,
      st_ino: u64,
      st_nlink: u64,
      st_mode: u32,
      st_uid: u32,
      st_gid: u32,
      __pad0: s32,
      st_rdev: u64,
      st_size: u64,
      st_blksize: s64,
      st_blocks: s64,
      st_atim: Time_Spec,
      st_mtim: Time_Spec,
      st_ctim: Time_Spec,
      __glibc_reserved: [s64; 3],
    };

    impl Stat {
      fn new!<T>(path: T) -> Option!<Self> where T: AsSlice!<u8> {
        file := fopen(path.as_slice().data, "r"c);

        if !file {
          return Option!<Self>::None;
        }

        mut stat: Self;
        fd := fileno(file);

        if fd == -1 {
          fclose(file);
          return Option!<Self>::None;
        }

        fstat(fd, &mut stat);
        fclose(file);
        return Option!<Self>::Some(stat);
      }

      fn is_dir(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0x4000;
      }
      
      fn is_file(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0x8000;
      }
      
      fn is_symlink(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0xA000;
      }
      
      fn is_block_device(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0x6000;
      }
      
      fn is_char_device(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0x2000;
      }
      
      fn is_fifo(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0x1000;
      }
      
      fn is_socket(*const self) -> bool {
          return (self.st_mode & 0xF000) == 0xC000;
      }
    }

    #flags enum FileOpenFlags {
      Read,
      Write,
    }

    impl FileOpenFlags {
      // Used to convert our flag enum to a str for fopen/fclose etc.
      // this does not ever need to be freed.
      fn as_str(self) -> c_str {
        if self == FileOpenFlags::Read {
          return "r"c;
        } else if self == FileOpenFlags::Write {
          return "w"c;
        } else if self == FileOpenFlags::Read | FileOpenFlags::Write {
          return "rw"c;
        } else {
          panic("unexpected file flags passed to a file api function");
          return null;
        }
        return null; // TODO: remove this, it's a hack to do some testing while lowering MIR.
      }
    }

    enum SeekPosition {
      Set	= 0,
      Begin = 0,
      Current	= 1,
      End	= 2,
      // We include the GNU extensions by default, but there's no guarantee that your system supports these.
      // We are kind of a linux only language (as of now), so it's probably there. check your C docs.
      Data	= 3,
      Hole	= 4,
    };

    const PATH_MAX := 4096;
    const SEEK_END: s32 = SeekPosition::End;
    const SEEK_BEGIN: s32 = SeekPosition::Begin;
    const SEEK_CUR: s32 = SeekPosition::Current;
    const SEEK_SET: s32 = SeekPosition::Set;
    const SEEK_DATA: s32 = SeekPosition::Data;
    const SEEK_HOLE: s32 = SeekPosition::Hole;

    type ProcId :: s32;
    // iovec is identical to our Slice type, so we can just use that. makes it easier to use in language, and works just fine with interop.
    type IoVec :: [u8]; 

    enum PtraceRequest {
      Traceme        = 0,
      PeekText       = 1,
      PeekData       = 2,
      PeekUser       = 3,
      PokeText       = 4,
      PokeData       = 5,
      PokeUser       = 6,
      Cont           = 7,
      Kill           = 8,
      SingleStep     = 9,
      GetRegs        = 12,
      SetRegs        = 13,
      GetFpRegs      = 14,
      SetFpRegs      = 15,
      Attach         = 16,
      Detach         = 17,
      GetFpxRegs     = 18,
      SetFpxRegs     = 19,
      Syscall        = 24,
      SetOptions     = 0x4200,
      GetEventMsg    = 0x4201,
      GetSigInfo     = 0x4202,
      SetSigInfo     = 0x4203,
    }

    // Process and System Functions
    extern {
      fn ptrace(request: s32, pid: s32, addr: *mut void, data: *mut void) -> s64;
      fn waitpid(pid: s32, status: *mut s32, options: s32) -> s32;
      fn wait(status: *mut s32) -> s32;
      fn kill(pid: s32, sig: s32) -> s32;
      fn getpid() -> s32;
      fn getppid() -> s32;
      fn fork() -> s32;
      fn execve(path: *const u8, argv: *const *const u8, envp: *const *const u8) -> s32;
      fn execvp(file: *const u8, argv: *const *const u8) -> s32;
      fn execv(path: *const u8, argv: *const *const u8) -> s32;
      fn execle(path: *const u8, argv: *const *const u8, ...) -> s32;
      fn execl(path: *const u8, ...) -> s32;
      fn execlp(file: *const u8, ...) -> s32;

      fn process_vm_writev(pid: ProcId, local: *IoVec, local_count: s64, remote: *IoVec, remote_count: s64, flags: s64) -> s64;
      fn process_vm_readv (pid: ProcId, lvec: *IoVec, l_iovec_ct: u64, rvec: *IoVec, r_iovec_ct: u64, flags: u64) -> s64;
      fn system(cmd: *const u8) -> s32;
      fn exit(code: s32);
      fn sleep(seconds: u32);
      fn usleep(c: u32);
    }

    // Memory Management
    extern {
      fn free(ptr: *const void) -> void;
      fn malloc(nbytes: u64) -> *mut void;
      fn calloc(num: u64, size: u64) -> *mut void;
      fn realloc(ptr: *const void, size: u64) -> *mut void;
      fn memmove(dest: *const void, src: *const void, nbytes: s64) -> s32;
      fn memcpy(dest: *const void, src: *const void, n: u64) -> *mut void;
      fn memset(dest: *const void, c: s32, n: u64) -> *mut void;
      fn memcmp(ptr1: *const void, ptr2: *const void, n: u64) -> s32;
    }

    // String Functions
    extern {
      fn strdup(s: *const u8) -> *mut u8;
      fn strndup(s: *const u8, n: u64) -> *mut u8;
      fn strerror(errnum: s32) -> *mut u8;
      fn strtok(s: *const u8, delim: *const u8) -> *mut u8;
      fn strcat(dest: *const u8, src: *const u8) -> *mut u8;
      fn strncat(dest: *const u8, src: *const u8, n: u64) -> *mut u8;
      fn strcpy(dest: *mut u8, src: *const u8) -> *mut u8;
      fn strncpy(dest: *mut u8, src: *const u8, n: u64) -> *mut u8;
      fn strcmpi(str1: *const u8, str2: *const u8) -> s32;
      fn strcasecmp(str1: *const u8, str2: *const u8) -> s32;
      fn strlcpy(dest: *mut u8, src: *const u8, size: u64) -> u64;
      fn strlcat(dest: *mut u8, src: *const u8, size: u64) -> u64;
      fn strncmp(s: *const u8, str2: *const u8, len: s32) -> s32;
      fn strcmp(str1: *const u8, str2: *const u8) -> s32;
      fn strlen(string: *const u8) -> u32;
    }

    // Character Functions
    extern {
      fn isalnum(c: s32) -> s32;
      fn isalpha(c: s32) -> s32;
      fn isspace(c: s32) -> s32;
      fn isdigit(c: s32) -> s32;
      fn islower(c: s32) -> s32;
      fn isupper(c: s32) -> s32;
      fn isprint(c: s32) -> s32;
      fn ispunct(c: s32) -> s32;
      fn isxdigit(c: s32) -> s32;
      fn iscntrl(c: s32) -> s32;
      fn isgraph(c: s32) -> s32;
      fn tolower(c: s32) -> s32;
      fn toupper(c: s32) -> s32;
    }

    // Conversion Functions
    extern {
      fn atoi(v: *const u8) -> s32;
      fn atof(v: *const u8) -> f64;
    }

    // Low-level File I/O (POSIX)
    extern {
      fn open(path: *const u8, flags: s32, mode: u32) -> s32;
      fn close(fd: s32) -> s32;
      fn read(fd: s32, buf: *mut void, count: u64) -> s64;
      fn write(fd: s32, buf: *const void, count: u64) -> s64;
      fn lseek(fd: s32, offset: s64, whence: s32) -> s64;
      fn fsync(fd: s32) -> s32;
      fn fdatasync(fd: s32) -> s32;
      fn dup(fd: s32) -> s32;
      fn dup2(oldfd: s32, newfd: s32) -> s32;
      fn pipe(fds: *mut s32) -> s32;
      fn fstat(fd: s32, stat: *mut Stat) -> s32;
    }

    // High-level File I/O (stdio)
    extern {
      fn fopen(fname: *const u8, flags: *const u8) -> *mut FILE;
      fn fclose(file: *mut FILE) -> void;
      fn fread(ptr: *mut void, size: u64, count: u64, stream: *mut FILE) -> u64;
      fn fwrite(ptr: *const void, size: u64, count: u64, stream: *mut FILE) -> u64;
      fn fseek(stream: *mut FILE, offset: s64, origin: s32) -> s32;
      fn ftell(stream: *const FILE) -> s64;
      fn rewind(stream: *mut FILE) -> void;
      fn fgetc(file: *mut FILE) -> s8;
      fn fflush(f: *const FILE);
      fn fileno(file: *const FILE) -> s32;
      fn feof(stream: *mut FILE) -> s32;
      fn ferror(stream: *mut FILE) -> s32;
      fn clearerr(stream: *mut FILE);
      fn setvbuf(stream: *mut FILE, buf: *mut u8, mode: s32, size: u64) -> s32;
      fn setbuf(stream: *mut FILE, buf: *mut u8);
      fn fgets(s: *mut u8, size: s32, stream: *mut FILE) -> *mut u8;
      fn fputs(s: *const u8, stream: *mut FILE) -> s32;
      fn getc(stream: *mut FILE) -> s32;
      fn putc(c: s32, stream: *mut FILE) -> s32;
      fn ungetc(c: s32, stream: *mut FILE) -> s32;
      fn getchar() -> s32;
      fn puts(s: *const u8) -> s32;
      fn perror(s: *const u8);
    }

    // Formatted I/O - printf family
    extern {
      fn printf(format: *const u8, ...) -> s32;
      fn vprintf(format: *const u8, args: va_list) -> s32;
      fn fprintf(stream: *mut FILE, format: *const u8, ...) -> s32;
      fn vfprintf(stream: *mut FILE, format: *const u8, args: va_list) -> s32;
      fn dprintf(fd: s32, format: *const u8, ...) -> s32;
      fn vdprintf(fd: s32, format: *const u8, args: va_list) -> s32;
      fn sprintf(buffer: *mut u8, format: *const u8, ...) -> s32;
      fn vsprintf(buffer: *mut u8, format: *const u8, args: va_list) -> s32;
      fn snprintf(buffer: *mut u8, buffer_size: u64, format: *const u8, ...) -> s32;
      fn vsnprintf(buffer: *mut u8, buffer_size: u64, format: *const u8, args: va_list) -> s32;
      fn asprintf(ptr: *mut *mut u8, format: *const u8, ...) -> s32;
      fn vasprintf(ptr: *mut *mut u8, format: *const u8, args: va_list) -> s32;
    }

    // Formatted I/O - scanf family
    extern {
      fn scanf(format: *const u8, ...) -> s32;
      fn vscanf(format: *const u8, args: va_list) -> s32;
      fn fscanf(stream: *mut FILE, format: *const u8, ...) -> s32;
      fn vfscanf(stream: *mut FILE, format: *const u8, args: va_list) -> s32;
      fn sscanf(buffer: *const u8, format: *const u8, ...) -> s32;
      fn vsscanf(buffer: *const u8, format: *const u8, args: va_list) -> s32;
    }

    // Directory Operations
    extern {
      fn opendir(name: *const u8) -> *mut DIR;
      fn readdir(dir: *mut DIR) -> *const DirEntry;
      fn closedir(dir: *const void) -> s32;
      fn getcwd(buf: c_str, size: u64) -> c_str;
      fn chdir(path: *const u8) -> s32;
      fn dirname(path: *const u8) -> *mut u8;
      fn realpath(path: *const u8, result: *mut u8) -> *const u8;
    }

    // File System Operations
    extern {
      fn mkdir(path: *const u8, mode: u32) -> s32;
      fn rmdir(path: *const u8) -> s32;
      fn remove(path: *const u8) -> s32;
      fn unlink(path: *const u8) -> s32;
      fn rename(oldpath: *const u8, newpath: *const u8) -> s32;
      fn chmod(path: *const u8, mode: u32) -> s32;
      fn chown(path: *const u8, owner: u32, group: u32) -> s32;
      fn access(path: *const u8, mode: s32) -> s32;
      fn utime(path: *const u8, times: *const void) -> s32;
      fn truncate(path: *const u8, length: s64) -> s32;
      fn ftruncate(fd: s32, length: s64) -> s32;
    }


    // Using fmt::format or io::println to print this will give you the enum name, which is more useful.
    // io::try_print_errno_if_bad(); will print it, if it's in an error state (non-zero)
    enum Errno {
      EPERM_OperationNotPermitted        = 1,   // EPERM: Operation not permitted
      ENOENT_NoSuchFileOrDirectory       = 2,   // ENOENT: No such file or directory
      ESRCH_NoSuchProcess                = 3,   // ESRCH: No such process
      EINTR_InterruptedSystemCall        = 4,   // EINTR: Interrupted system call
      EIO_IOError                        = 5,   // EIO: I/O error
      ENXIO_NoSuchDeviceOrAddress        = 6,   // ENXIO: No such device or address
      E2BIG_ArgumentListTooLong          = 7,   // E2BIG: Argument list too long
      ENOEXEC_ExecFormatError            = 8,   // ENOEXEC: Exec format error
      EBADF_BadFileDescriptor            = 9,   // EBADF: Bad file number
      ECHILD_NoChildProcesses            = 10,  // ECHILD: No child processes
      EAGAIN_TryAgain                    = 11,  // EAGAIN: Try again
      ENOMEM_OutOfMemory                 = 12,  // ENOMEM: Out of memory
      EACCES_PermissionDenied            = 13,  // EACCES: Permission denied
      EFAULT_BadAddress                  = 14,  // EFAULT: Bad address
      ENOTBLK_BlockDeviceRequired        = 15,  // ENOTBLK: Block device required
      EBUSY_DeviceOrResourceBusy         = 16,  // EBUSY: Device or resource busy
      EEXIST_FileExists                  = 17,  // EEXIST: File exists
      EXDEV_CrossDeviceLink              = 18,  // EXDEV: Cross-device link
      ENODEV_NoSuchDevice                = 19,  // ENODEV: No such device
      ENOTDIR_NotADirectory              = 20,  // ENOTDIR: Not a directory
      EISDIR_IsADirectory                = 21,  // EISDIR: Is a directory
      EINVAL_InvalidArgument             = 22,  // EINVAL: Invalid argument
      ENFILE_FileTableOverflow           = 23,  // ENFILE: File table overflow
      EMFILE_TooManyOpenFiles            = 24,  // EMFILE: Too many open files
      ENOTTY_NotATypewriter              = 25,  // ENOTTY: Not a typewriter
      ETXTBSY_TextFileBusy               = 26,  // ETXTBSY: Text file busy
      EFBIG_FileTooLarge                 = 27,  // EFBIG: File too large
      ENOSPC_NoSpaceLeftOnDevice         = 28,  // ENOSPC: No space left on device
      ESPIPE_IllegalSeek                 = 29,  // ESPIPE: Illegal seek
      EROFS_ReadOnlyFileSystem           = 30,  // EROFS: Read-only file system
      EMLINK_TooManyLinks                = 31,  // EMLINK: Too many links
      EPIPE_BrokenPipe                   = 32,  // EPIPE: Broken pipe
      EDOM_MathArgumentOutOfDomain       = 33,  // EDOM: Math argument out of domain of func
      ERANGE_MathResultNotRepresentable  = 34,  // ERANGE: Math result not representable
    }

    extern fn __errno_location() -> *s32;
    
    fn errno() -> Errno {
      return *__errno_location();
    }


    const SIGSET_NUM_WORDS := (1024 / (8 * sizeof(u64)))
    struct SigSet_T
    {
      val: [u32; SIGSET_NUM_WORDS],
    }

    // NOTE: this may not match your libc/glibc/musl etc.
    // This is the version of jmp_buf_t that includes the signal mask save stating,
    // which is not specified by posix, but is common in newer libraries.

    struct JmpBufTag;

    type JmpBuf :: *JmpBufTag;

    struct JmpBufTag
    {
      buf: JmpBuf,		      /* Calling environment.  */
      mask_was_saved: s32,	/* Saved the signal mask?  */
      saved_mask: SigSet_T,	/* Saved signal mask.  */
    }

    // this is just how C declares this for seemingly no reason, prefixed with underscores then a macro
    // wraps it. we just use an inline function.
    extern fn _setjmp(env: JmpBuf) -> s32;
    extern fn __sigsetjmp(env: JmpBuf, save_mask: s32) -> s32;

    @[inline]
    fn setjmp(env: JmpBuf) -> s32 {
      return _setjmp(env);
    }
    
    @[inline]
    fn sigsetjmp(env: JmpBuf, save_mask: s32) -> s32 {
      return __sigsetjmp(env, save_mask);
    }

    extern fn longjmp(env: JmpBuf, value_returned_at_setjmp_callsite: s32);
  }

  fn system(cmd: str) -> s32 {
    return c::system(cmd.data);
  }

  fn free(ptr: *const void) -> void {
    return c::free(ptr);
  }

  fn malloc!<T>() -> *mut T {
    return c::malloc(sizeof(T));
  }

  fn calloc!<T>(num: u64) -> *mut T {
    return c::calloc(num, sizeof(T));
  }

  fn realloc!<T>(ptr: *const T, n: u64) -> *mut T {
    return c::realloc(ptr, n * sizeof(T));
  }

  @[no_return]
  fn exit(code: s32) {
    return c::exit(code);
  }

  @[inline]
  fn printf!<T>(format: str, arg: T) -> s32 {
    where T: IsTuple {
      return c::printf(format.data, ...arg);
    } else {
      return c::printf(format.data, arg);
    }
  }

  fn puts!<MsgT>(msg: MsgT) {
    where MsgT: AsSlice!<u8> {
      slice := msg.as_slice();
      std::c::puts(slice.data);
    } else where MsgT: *u8 | *mut u8 {
      std::c::puts(msg);
    }
  }
  
  
  @[inline]
  fn fprintf!<T>(stream: *mut c::FILE, format: str, arg: T) -> s32 {
    where T: IsTuple {
      return c::fprintf(stream, format.data, ...arg);
    } else {
      return c::fprintf(stream, format.data, arg);
    }
  }

  @[inline]
  fn dprintf!<T>(fd: s32, format: str, arg: T) -> s32 {
    where T: IsTuple {
      return c::dprintf(fd, format.data, ...arg);
    } else {
      return c::dprintf(fd, format.data, arg);
    }
  }

  @[inline]
  fn sprintf!<T>(buffer: *mut u8, format: str, arg: T) -> s32 {
    where T: IsTuple {
      return c::sprintf(buffer, format.data, ...arg);
    } else {
      return c::sprintf(buffer, format.data, arg);
    }
  }

  @[inline]
  fn asprintf!<T>(format: str, allocator: dyn Allocator, arg: T) -> String {
    where T: IsTuple {
      length := c::snprintf(null, 0, format.data, ...arg);
    } else {
      length := c::snprintf(null, 0, format.data, arg);
    }
    if length < 0 {
      return .{};
    }

    buffer: *mut u8 = allocator.allocate((length + 1) * sizeof(u8));
    
    if buffer == null {
      return .{};
    }

    where T: IsTuple {
      c::snprintf(buffer, length + 1, format.data, arg);
    } else {
      c::snprintf(buffer, length + 1, format.data, ...arg);
    }

    return String.{
      data: buffer,
      length: length,
      allocator: allocator,
    };
  }

  @[inline]
  fn scanf!<T>(format: str, arg: T) -> s32 {
    where T: IsTuple {
    c::scanf(format.data, arg);
    } else {
    return c::scanf(format.data, ...arg);
    }
  }

  @[inline]
  fn fscanf!<T>(stream: *mut c::FILE, format: str, arg: T) -> s32 {
    where T: IsTuple {
    c::fscanf(stream, format.data, arg);
    } else {
    return c::fscanf(stream, format.data, ...arg);
    }
  }

  @[inline]
  fn sscanf!<T>(buffer: str, format: str, arg: T) -> s32 {
    where T: IsTuple {
    c::sscanf(buffer.data, format.data, arg);
    } else {
    return c::sscanf(buffer.data, format.data, ...arg);
    }
  }
}