// Obviously, LIBC is only available when not in a freestanding environment.
// TODO: add a bunch more libc functions as needed.
// this is very limited to what i've done in the language so far and a ton is missing.

#ifndef FREESTANDING {
  module std {
    module c {
      struct FILE;
      struct DIR;

      struct DirEntry {
        d_ino: u64,
        d_off: u64,
        d_reclen: u16,
        d_type: u8,
        d_name: [u8; 256],
      }

      const EOF := -1;

      struct Time_Spec {
        tv_sec: s64,
        tv_nsec: s64,
      };

      struct Stat {
        st_dev: u64,
        st_ino: u64,
        st_nlink: u64,
        st_mode: u32,
        st_uid: u32,
        st_gid: u32,
        __pad0: s32,
        st_rdev: u64,
        st_size: u64,
        st_blksize: s64,
        st_blocks: s64,
        st_atim: Time_Spec,
        st_mtim: Time_Spec,
        st_ctim: Time_Spec,
        __glibc_reserved: [s64; 3],
      };

      impl Stat {
        fn new!<T>(path: T) -> Option!<Self> where T: AsSlice!<u8> {
          file := fopen(path.as_slice().data, "r"c);

          if !file {
            return Option!<Self>::None;
          }

          mut stat: Self;
          fd := fileno(file);

          if fd == -1 {
            fclose(file);
            return Option!<Self>::None;
          }

          fstat(fd, &mut stat);
          fclose(file);
          return Option!<Self>::Some(stat);
        }

        fn is_dir(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0x4000;
        }
        
        fn is_file(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0x8000;
        }
        
        fn is_symlink(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0xA000;
        }
        
        fn is_block_device(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0x6000;
        }
        
        fn is_char_device(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0x2000;
        }
        
        fn is_fifo(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0x1000;
        }
        
        fn is_socket(*const self) -> bool {
            return (self.st_mode & 0xF000) == 0xC000;
        }
      }

      #flags enum FileOpenFlags {
        Read,
        Write,
      }

      impl FileOpenFlags {
        // Used to convert our flag enum to a str for fopen/fclose etc.
        // this does not ever need to be freed.
        fn as_str(self) -> c_str {
          if self == FileOpenFlags::Read {
            return "r"c;
          } else if self == FileOpenFlags::Write {
            return "w"c;
          } else if self == FileOpenFlags::Read | FileOpenFlags::Write {
            return "rw"c;
          } else {
            panic("unexpected file flags passed to a file api function");
            return null;
          }
        }
      }

      enum SeekPosition {
        Set	= 0,
        Begin = 0,
        Current	= 1,
        End	= 2,
        // We include the GNU extensions by default, but there's no guarantee that your system supports these.
        // We are kind of a linux only language (as of now), so it's probably there. check your C docs.
        Data	= 3,
        Hole	= 4,
      };

      const PATH_MAX := 4096;
      const SEEK_END: s32 = SeekPosition::End;
      const SEEK_BEGIN: s32 = SeekPosition::Begin;
      const SEEK_CUR: s32 = SeekPosition::Current;
      const SEEK_SET: s32 = SeekPosition::Set;
      const SEEK_DATA: s32 = SeekPosition::Data;
      const SEEK_HOLE: s32 = SeekPosition::Hole;

      extern {
        fn getcwd(buf: c_str, size: u64) -> c_str;
        fn opendir(name: *const u8) -> *mut DIR;
        fn readdir(dir: *mut DIR) -> *const DirEntry;
        fn closedir(dir: *const void) -> s32;
        fn chdir(path: *const u8) -> s32;
        fn dirname(path: *const u8) -> *mut u8;
        fn realpath(path: *const u8, result: *mut u8) -> *const u8;
        fn fstat(fd: s32, stat: *mut Stat) -> s32;
        fn fileno(file: *const FILE) -> s32;
        fn fread(ptr: *mut void, size: u64, count: u64, stream: *mut FILE) -> u64;
        fn fwrite(ptr: *const void, size: u64, count: u64, stream: *mut FILE) -> u64;
        fn fseek(stream: *mut FILE, offset: s64, origin: s32) -> s32;
        fn ftell(stream: *const FILE) -> s64;
        fn rewind(stream: *mut FILE) -> void;
        fn fopen(fname: *const u8, flags: *const u8) -> *mut FILE;
        fn fclose(file: *mut FILE) -> void;
        fn fgetc(file: *mut FILE) -> s8;
        fn putc(ch: u8, file: *mut FILE) -> void;
        fn fflush(f: *const FILE);

        fn mkdir(path: *const u8, mode: u32) -> s32;
        fn rmdir(path: *const u8) -> s32;
        fn remove(path: *const u8) -> s32;

        fn realpath(path: *const u8, result: *mut u8) -> *const u8;
        fn chdir(path: *const u8) -> s32;
        fn dirname(path: *const u8) -> *mut u8;
        fn getcwd(buf: *mut u8, size: u64) -> *mut u8;

        fn opendir(name: *const u8) -> *mut DIR;
        fn readdir(dir: *mut DIR) -> *const DirEntry;
        fn closedir(dir: *const void) -> s32;
        fn lseek(fd: s32, offset: s64, whence: s32) -> s64;
        fn unlink(path: *const u8) -> s32;
        fn rename(oldpath: *const u8, newpath: *const u8) -> s32;
        fn chmod(path: *const u8, mode: u32) -> s32;
        fn chown(path: *const u8, owner: u32, group: u32) -> s32;
        fn access(path: *const u8, mode: s32) -> s32;
        fn utime(path: *const u8, times: *const void) -> s32;
        fn truncate(path: *const u8, length: s64) -> s32;
        fn ftruncate(fd: s32, length: s64) -> s32;

        fn open(path: *const u8, flags: s32, mode: u32) -> s32;
        fn close(fd: s32) -> s32;
        fn read(fd: s32, buf: *mut void, count: u64) -> s64;
        fn write(fd: s32, buf: *const void, count: u64) -> s64;
        fn fsync(fd: s32) -> s32;
        fn fdatasync(fd: s32) -> s32;
        fn dup(fd: s32) -> s32;
        fn dup2(oldfd: s32, newfd: s32) -> s32;
        fn pipe(fds: *mut s32) -> s32;
        fn fileno(stream: *mut FILE) -> s32;
        fn fflush(stream: *mut FILE) -> s32;
        fn fclose(stream: *mut FILE) -> s32;
        fn fopen(path: *const u8, mode: *const u8) -> *mut FILE;
        fn fread(ptr: *mut void, size: u64, nmemb: u64, stream: *mut FILE) -> u64;
        fn fwrite(ptr: *const void, size: u64, nmemb: u64, stream: *mut FILE) -> u64;
        fn fseek(stream: *mut FILE, offset: s64, whence: s32) -> s32;
        fn ftell(stream: *mut FILE) -> s64;
        fn rewind(stream: *mut FILE);
        fn feof(stream: *mut FILE) -> s32;
        fn ferror(stream: *mut FILE) -> s32;
        fn clearerr(stream: *mut FILE);
        fn setvbuf(stream: *mut FILE, buf: *mut u8, mode: s32, size: u64) -> s32;
        fn setbuf(stream: *mut FILE, buf: *mut u8);
        fn perror(s: *const u8);
        fn puts(s: *const u8) -> s32;
        fn fputs(s: *const u8, stream: *mut FILE) -> s32;
        fn fgets(s: *mut u8, size: s32, stream: *mut FILE) -> *mut u8;
        fn getc(stream: *mut FILE) -> s32;
        fn putc(c: s32, stream: *mut FILE) -> s32;
        fn ungetc(c: s32, stream: *mut FILE) -> s32;
        
        fn system(cmd: *const u8) -> s32;

        fn free(ptr: *const void) -> void;
        fn malloc(nbytes: u64) -> *mut void;
        fn calloc(num: u64, size: u64) -> *mut void;
        fn realloc(ptr: *const void, size: u64) -> *mut void;

        // printf family
        fn printf(format: *const u8, ...) -> s32;
        fn vprintf(format: *const u8, args: va_list) -> s32;

        fn fprintf(stream: *mut FILE, format: *const u8, ...) -> s32;
        fn vfprintf(stream: *mut FILE, format: *const u8, args: va_list) -> s32;

        fn dprintf(fd: s32, format: *const u8, ...) -> s32;
        fn vdprintf(fd: s32, format: *const u8, args: va_list) -> s32;

        fn sprintf(buffer: *mut u8, format: *const u8, ...) -> s32;
        fn vsprintf(buffer: *mut u8, format: *const u8, args: va_list) -> s32;

        fn snprintf(buffer: *mut u8, buffer_size: u64, format: *const u8, ...) -> s32;
        fn vsnprintf(buffer: *mut u8, buffer_size: u64, format: *const u8, args: va_list) -> s32;

        fn asprintf(ptr: *mut *mut u8, format: *const u8, ...) -> s32;
        fn vasprintf(ptr: *mut *mut u8, format: *const u8, args: va_list) -> s32;

        // scanf family
        fn scanf(format: *const u8, ...) -> s32;
        fn vscanf(format: *const u8, args: va_list) -> s32;

        fn fscanf(stream: *mut FILE, format: *const u8, ...) -> s32;
        fn vfscanf(stream: *mut FILE, format: *const u8, args: va_list) -> s32;

        fn sscanf(buffer: *const u8, format: *const u8, ...) -> s32;
        fn vsscanf(buffer: *const u8, format: *const u8, args: va_list) -> s32;

        
        fn exit(code: s32);

        fn getchar() -> s32;

        fn sleep(seconds: u32);
        fn usleep(c: u32);

        fn strdup(s: *const u8) -> *mut u8;
        fn strndup(s: *const u8, n: u64) -> *mut u8;
        fn strerror(errnum: s32) -> *mut u8;

        fn strtok(s: *const u8, delim: *const u8) -> *mut u8;
        fn strcat(dest: *const u8, src: *const u8) -> *mut u8;
        fn strncat(dest: *const u8, src: *const u8, n: u64) -> *mut u8;

        fn strcpy(dest: *mut u8, src: *const u8) -> *mut u8;
        fn strncpy(dest: *mut u8, src: *const u8, n: u64) -> *mut u8;
        fn strcmpi(str1: *const u8, str2: *const u8) -> s32;
        fn strcasecmp(str1: *const u8, str2: *const u8) -> s32;
        fn strlcpy(dest: *mut u8, src: *const u8, size: u64) -> u64;
        fn strlcat(dest: *mut u8, src: *const u8, size: u64) -> u64;

        fn atoi(v: *const u8) -> s32;
        fn atof(v: *const u8) -> f64;

        fn memmove(dest: *const void, src: *const void, nbytes: s64) -> s32;
        fn memcpy(dest: *const void, src: *const void, n: u64) -> *mut void;
        fn memset(dest: *const void, c: s32, n: u64) -> *mut void;
        fn memcmp(ptr1: *const void, ptr2: *const void, n: u64) -> s32;

        fn strncmp(s: *const u8, str2: *const u8, len: s32) -> s32;
        fn strcmp(str1: *const u8, str2: *const u8) -> s32;
        fn strlen(string: *const u8) -> u32;

        fn isalnum(c: s32) -> s32;
        fn isalpha(c: s32) -> s32;
        fn isspace(c: s32) -> s32;
        fn isdigit(c: s32) -> s32;
        fn islower(c: s32) -> s32;
        fn isupper(c: s32) -> s32;
        fn isprint(c: s32) -> s32;
        fn ispunct(c: s32) -> s32;
        fn isxdigit(c: s32) -> s32;
        fn iscntrl(c: s32) -> s32;
        fn isgraph(c: s32) -> s32;
        fn tolower(c: s32) -> s32;
        fn toupper(c: s32) -> s32;
      }
    }

    fn system(cmd: str) -> s32 {
      return c::system(cmd.data);
    }

    fn free(ptr: *const void) -> void {
      return c::free(ptr);
    }

    fn malloc!<T>() -> *mut T {
      return c::malloc(sizeof(T));
    }

    fn calloc!<T>(num: u64) -> *mut T {
      return c::calloc(num, sizeof(T));
    }

    fn realloc!<T>(ptr: *const T, n: u64) -> *mut T {
      return c::realloc(ptr, n * sizeof(T));
    }

    @[no_return]
    fn exit(code: s32) {
      return c::exit(code);
    }

    @[inline]
    fn printf!<T>(format: str, arg: T) -> s32 {
      where T: IsTuple {
        return c::printf(format.data, ...arg);
      } else {
        return c::printf(format.data, arg);
      }
    }

    fn puts!<MsgT>(msg: MsgT) {
      where MsgT: AsSlice!<u8> {
        slice := msg.as_slice();
        std::c::puts(slice.data);
      } else where MsgT: *u8 | *mut u8 {
        std::c::puts(msg);
      }
    }
   
    
    @[inline]
    fn fprintf!<T>(stream: *mut c::FILE, format: str, arg: T) -> s32 {
      where T: IsTuple {
        return c::fprintf(stream, format.data, ...arg);
      } else {
        return c::fprintf(stream, format.data, arg);
      }
    }

    @[inline]
    fn dprintf!<T>(fd: s32, format: str, arg: T) -> s32 {
      where T: IsTuple {
        return c::dprintf(fd, format.data, ...arg);
      } else {
        return c::dprintf(fd, format.data, arg);
      }
    }

    @[inline]
    fn sprintf!<T>(buffer: *mut u8, format: str, arg: T) -> s32 {
      where T: IsTuple {
        return c::sprintf(buffer, format.data, ...arg);
      } else {
        return c::sprintf(buffer, format.data, arg);
      }
    }

    @[inline]
    fn asprintf!<T>(format: str, allocator: dyn Allocator, arg: T) -> String {
      where T: IsTuple {
        length := c::snprintf(null, 0, format.data, ...arg);
      } else {
        length := c::snprintf(null, 0, format.data, arg);
      }
      if length < 0 {
        return .{};
      }

      buffer: *mut u8 = allocator.allocate((length + 1) * sizeof(u8));
      
      if buffer == null {
        return .{};
      }

      where T: IsTuple {
        c::snprintf(buffer, length + 1, format.data, arg);
      } else {
        c::snprintf(buffer, length + 1, format.data, ...arg);
      }

      return String.{
        data: buffer,
        length: length,
        allocator: allocator,
      };
    }

    @[inline]
    fn scanf!<T>(format: str, arg: T) -> s32 {
      where T: IsTuple {
      c::scanf(format.data, arg);
      } else {
      return c::scanf(format.data, ...arg);
      }
    }

    @[inline]
    fn fscanf!<T>(stream: *mut c::FILE, format: str, arg: T) -> s32 {
      where T: IsTuple {
      c::fscanf(stream, format.data, arg);
      } else {
      return c::fscanf(stream, format.data, ...arg);
      }
    }

    @[inline]
    fn sscanf!<T>(buffer: str, format: str, arg: T) -> s32 {
      where T: IsTuple {
      c::sscanf(buffer.data, format.data, arg);
      } else {
      return c::sscanf(buffer.data, format.data, ...arg);
      }
    }
  }
}
