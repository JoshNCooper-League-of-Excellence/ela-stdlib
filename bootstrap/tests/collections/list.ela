import std::{
  _assert_eq as assert_eq,
  _assert as assert,
};

fn eq_s32(a: s32, b: s32) -> bool => a == b;

// #test fn test_list_new_and_push() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   assert(list.is_empty());
//   list.push(10);
//   list.push(20);
//   assert_eq(list.length, 2);
//   assert_eq(list.data![0], 10);
//   assert_eq(list.data![1], 20);
// }

// #test fn test_list_push_front_and_pop_front() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(1);
//   list.push(2);
//   list.push_front(0);
//   assert_eq(list.length, 3);
//   assert_eq(list.data![0], 0);
//   assert_eq(list.pop_front(), 0);
//   assert_eq(list.length, 2);
// }

// #test fn test_list_pop_and_back_front() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(5);
//   list.push(6);
//   assert_eq(list.back().unwrap(), 6);
//   assert_eq(list.front().unwrap(), 5);
//   assert_eq(list.pop(), 6);
//   assert_eq(list.length, 1);
// }

// #test fn test_list_resize_and_initialize() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.resize(10);
//   assert_eq(list.capacity, 10);
//   list.initialize(5);
//   assert_eq(list.length, 5);
//   for i in 0..5 {
//     assert_eq(list.data![i], 0);
//   }
// }

// #test fn test_list_subarray() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   for i in 0..5 {
//     list.push(i);
//   }
//   sub := list.subarray(.{begin: 1, end: 4});
//   assert_eq(sub.length, 3);
//   assert_eq(sub.data![0], 1);
//   assert_eq(sub.data![2], 3);
// }

// #test fn test_list_clone() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(7);
//   list.push(8);
//   clone := list.clone();
//   assert_eq(clone.length, 2);
//   assert_eq(clone.data![0], 7);
//   assert_eq(clone.data![1], 8);
// }

// #test fn test_list_init() {
//   init := InitList!<s32>.{data: &[1,2,3], length: 3};
//   list := List!<s32>::init(init);
//   assert_eq(list.length, 3);
//   assert_eq(list.data![2], 3);
// }

// #test fn test_list_iter_and_iter_mut() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   for i in 0..3 {
//     list.push(i);
//   }
//   mut sum := 0;
//   for v in list.iter() {
//     sum += v;
//   }
//   assert_eq(sum, 3);
//   for v in list.iter_mut() {
//     v += 1;
//   }
//   assert_eq(list.data![0], 1);
// }

// #test fn test_list_destroy() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(1);
//   list.push(2);
//   list.destroy();
//   assert_eq(list.length, 0);
//   assert(list.data == null);
// }

// #test fn test_list_index() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(42);
//   assert_eq(*list.index(0), 42);
//   *list.index_mut(0) = 99;
//   assert_eq(list.data![0], 99);
// }

// #test fn test_list_remove_at() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(1);
//   list.push(2);
//   list.push(3);
//   assert(list.remove_at(1));
//   assert_eq(list.length, 2);
//   assert_eq(list.data![1], 3);
// }

// #test fn test_list_find_first_of() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(10);
//   list.push(20);
//   found := list.find_first_of(fn(ptr: *s32) -> bool { *ptr == 20 });
//   assert(found != null && *found == 20);
// }

// #test fn test_list_any() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(5);
//   list.push(6);
//   result := list.any(null, fn(v: s32, _: *void) -> bool { v == 6 });
//   assert(result);
// }

// #test fn test_list_filter() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   for i in 0..5 {
//     list.push(i);
//   }
//   filtered := list.filter(fn(ptr: *const s32) -> bool { *ptr % 2 == 0 });
//   assert_eq(filtered.length, 3);
//   assert_eq(filtered.data![0], 0);
//   assert_eq(filtered.data![1], 2);
//   assert_eq(filtered.data![2], 4);
// }

// #test fn test_list_enumerate() {
//   allocator := get_global_allocator();
//   mut list := List!<s32>::new(allocator);
//   list.push(1);
//   list.push(2);
//   mut idx_sum := 0;
//   for (idx, val) in list.enumerate() {
//     idx_sum += idx + val;
//   }
//   assert_eq(idx_sum, 3);
// }

#test fn test_list_as_slice() {
  allocator := get_global_allocator();
  mut list := List!<s32>::new(allocator);
  list.push(11);
  list.push(22);
  slice := list.as_slice();
  assert_eq(slice.length, 2 as u64);
  assert_eq(slice.data![1], 22);
}

#test fn test_list_sort() {
  allocator := get_global_allocator();
  mut list := List!<s32>::new(allocator);
  list.push(3);
  list.push(1);
  list.push(2);
  list.sort(fn(a: s32, b: s32) -> bool { 
    return a < b;
  });
  // std::c::printf("test_list_sort() failed\n"c);
  assert_eq(list.data![0], 1);
  assert_eq(list.data![1], 2);
  assert_eq(list.data![2], 3);
}

#test fn test_list_contains_and_remove() {
  allocator := get_global_allocator();
  mut list := List!<s32>::new(allocator);
  list.push(7);
  list.push(8);
  assert(list.contains(8, &mut eq_s32));
  assert(list.remove(8, &mut eq_s32));
  assert_eq(list.length, 1 as u64);
  assert(!list.contains(8, &mut eq_s32));
}

#test fn test_list_retain() {
  allocator := get_global_allocator();
  mut list := List!<s32>::new(allocator);
  for i in 0..5 {
    list.push(i);
  }
  list.retain(fn(ptr: *const s32) -> bool { return *ptr > 2; });
  assert_eq(list.length, 2 as u64);
  assert_eq(list.data![0], 3);
  assert_eq(list.data![1], 4);
}

#test fn test_list_from_slice() {
  arr: InitList!<s32> = s32.[1,2,3];
  list := List!<s32>::from_slice(arr.as_slice());
  assert_eq(list.length, 3 as u64);
  assert_eq(list.data![2], 3);
}