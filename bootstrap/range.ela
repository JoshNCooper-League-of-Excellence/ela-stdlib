
// TODO: add reverse ranges?

Range_Base :: struct!<Value_Type> where Value_Type is Eq | Is_Numeric {
  begin: Value_Type,
  end:   Value_Type,
}

alias Range_s8  :: Range_Base!<s8>;
alias Range_s16 :: Range_Base!<s16>;
alias Range_s32 :: Range_Base!<s32>;
alias Range_s64 :: Range_Base!<s64>;

alias Range_u8  :: Range_Base!<u8>;
alias Range_u16 :: Range_Base!<u16>;
alias Range_u32 :: Range_Base!<u32>;
alias Range_u64 :: Range_Base!<u64>;

alias Range :: Range_s32;

impl!<T> Range_Base!<T> {
  contains :: fn(self, value: T) -> bool {
    return self.begin <= value && self.end >= value;
  }
}

Range_Iter :: struct!<Value_Type> where Value_Type is Eq | Is_Numeric {
  begin: Value_Type,
  end:   Value_Type,
  idx:   Value_Type,
}

impl!<Value_Type> Iter!<Value_Type> for Range_Iter!<Value_Type>  {
  alias Option :: Option!<Value_Type>;
  next :: fn(*mut self) -> Option {
    value := Option::Some(self.idx);
    if self.idx >= self.end {
      return Option::None();
    }
    self.idx++;
    return value;
  }
}

impl!<Value_Type> Iterable!<Value_Type> for Range_Base!<Value_Type> {
  iter :: fn(*mut self) -> Range_Iter!<Value_Type> {
    return .{
      begin: self.begin,
      end:   self.end,
      idx:          0,
    };
  }
}

impl!<Value_Type> Eq for Range_Base!<Value_Type> {
  eq :: fn(self, right: #self) -> bool {
    return self.begin == right.begin && self.end == right.end;
  }
  neq :: fn(self, right: #self) -> bool {
    return self.begin != right.begin || self.end != right.end;
  }
}
