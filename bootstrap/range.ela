
// TODO: add reverse ranges?

RangeBase :: struct!<V> where V: Eq | IsNumeric {
  begin: V,
  end:   V,
}

// default range for most things.
alias Range :: RangeBase!<s32>;

impl!<T> RangeBase!<T> {
  contains :: fn(self, value: T) -> bool {
    return self.begin <= value && self.end >= value;
  }
}

RangeIter :: struct!<V> where V: Eq | IsNumeric {
  begin: V,
  end:   V,
  idx:   V,
}

RangeIterMut :: struct!<V> {
  idx:   V,
  end:   V, // it sucks but this has to be *mut 
}

impl!<V> Iterator!<V> for RangeIter!<V>  {
  alias Option :: Option!<V>;
  next :: fn(*mut self) -> Option {
    value := Option::Some(self.idx);
    if self.idx >= self.end {
      return Option::None();
    }
    self.idx++;
    return value;
  }
}

impl!<V> Iterator!<V> for RangeIterMut!<V>  {
  alias Option :: Option!<V>;
  next :: fn(*mut self) -> Option {
    value := Option::Some(self.idx);
    if self.idx >= self.end {
      return Option::None();
    }
    self.idx++;
    return value;
  }
}

impl!<V> Iterable for RangeBase!<V> {
  iter :: fn(*const self) -> RangeIter!<V> {
    return .{
      begin: self.begin,
      end:   self.end,
      idx:          0,
    };
  }

  iter_mut :: fn(*mut self) -> RangeIterMut!<V> {
    return .{
      idx:  self.begin,
      end:  self.end,
    };
  }
}

impl!<V> Eq for RangeBase!<V> {
  eq :: fn(self, right: #self) -> bool {
    return self.begin == right.begin && self.end == right.end;
  }
  neq :: fn(self, right: #self) -> bool {
    return self.begin != right.begin || self.end != right.end;
  }
}
