
/*
  a generic iterator, can be used for 'for' loops, such as
  `for i in <my_object> {}`
  where my_object implements either Iterable!<T> (which just indicates we can be converted into an iterator)
  or my_object implements Iter!<> where it is an iterator itself.
*/
Iter :: interface!<V> {
  next :: fn(*mut self) -> Option!<V>;
}

/* 
  A basic iterator, can be used as a general purpose way to iterate over
  collections that are implemented as contiguous chunks of memory, and 
  a pointer just needs to be incremented until an end point to fully traverse it.
*/
Basic_Iter :: struct!<V> {
  ptr: *mut V,  // Pointer to the current element in the collection.
  end: *const V,  // Pointer to the end of the collection.
}

impl!<V> Iter!<*mut V> for Basic_Iter!<V> {
  alias Option :: Option!<*mut V>;
  // Advances the iterator to the next element in the collection.
  next :: fn(*mut self) -> Option {
    if self.ptr >= self.end {
      return Option::None();
    }
    value := Option::Some(self.ptr);
    self.ptr++;
    return value;
  }
}

/* 
  Iterable is a generic interface that represents a collection that can be iterated over.
  It defines a single method, iter, which returns an iterator for the collection.
*/
Iterable :: interface!<V> {
  // Returns an iterator for the collection.
  iter :: fn(*mut self) -> Iter!<V>;
}

Enumerate :: struct!<V, I> where I is Iter!<V> {
  idx: u64,
  iterator: I,
}

impl!<V, I> Iter!<V> for Enumerate!<V, I> {
  next :: fn(*mut self) -> Option!<(u64, V)> {
    index := self.idx;
    self.idx++;
    next := self.iterator.next();
    if next.has_value {
      return Option!<(u64, V)>::Some((index, next.unwrap()));
    } else {
      return Option!<(u64, V)>::None();
    }
  }
}

