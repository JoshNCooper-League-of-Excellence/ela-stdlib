/*
  a generic iterator, can be used for 'for' loops, such as
  `for i in <my_object> {}`
  where my_object implements either Iterable!<T> (which just indicates we can be converted into an iterator)
  or my_object implements Iterator!<> where it: an iterator itself.
*/
trait Iterator!<V> {
  fn next(*mut self) -> Option!<V>;
}

/* 
  A basic iterator, can be used as a general purpose way to iterate over
  collections that are implemented as contiguous chunks of memory, and 
  a pointer just needs to be incremented until an end point to fully traverse it.
*/
struct Iter!<V> {
  // Pointer to the current element in the collection.
  // Of course, this has to be mutable because we use pointer arithmetic
  // to advance the iterator.
  ptr: *mut V,  
  end: *const V,  // Pointer to the end of the collection.
}

/* 
  a mutable version of Iter!<>, where it returns a pointer to each element, instead of dereferencing it.
*/
struct IterMut!<V> {
  ptr: *mut V,  
  end: *const V,  // Pointer to the end of the collection.
}

impl!<V> Iterator!<V> for Iter!<V> {
  alias Option :: Option!<V>;
  // Advances the iterator to the next element in the collection.
  @[inline]
  fn next(*mut self) -> Option {
    if self.ptr >= self.end {
      return Option::None;
    }
    value := Option::Some(*self.ptr);
    self.ptr++;
    return value;
  }
}

impl!<V> Iterator!<*mut V> for IterMut!<V> {
  alias Option :: Option!<*mut V>;
  // Advances the iterator to the next element in the collection.
  fn next(*mut self) -> Option {
    if self.ptr >= self.end {
      return Option::None;
    }
    value := Option::Some(self.ptr);
    self.ptr++;
    return value;
  }
}

/* 
  Iterable is a generic trait that represents a collection that can be iterated over.
  It defines a single method, iter, which returns an iterator for the collection.
*/
trait Iterable {
  // Returns an iterator for the collection.
  fn iter(*const self) -> Iterator;
  fn iter_mut(*mut self) -> Iterator;
}

struct Enumerate!<V, I> where I: Iterator!<V> {
  idx: u64,
  iterator: I,
}

impl!<V, I> Iterator!<(u64, V)> for Enumerate!<V, I> {
  fn next(*mut self) -> Option!<(u64, V)> {
    index := self.idx;
    self.idx++;
    next := self.iterator.next();
    
    if next is Option!<V>::Some(v) {
      return Option!<(u64, V)>::Some((index, v));
    } else {
      return Option!<(u64, V)>::None;
    }
  }
}