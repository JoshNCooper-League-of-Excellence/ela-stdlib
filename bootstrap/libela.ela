/*

  A bunch of functions that are normally provided by libc, but we will provide our own copies
  so that we don't have to depend on libc just to get basic operations on memory and strings.

  This helps us be completely 'freestanding' compatible without compromising on providing useful types:

  List!<T>, String, str, etc, can all work freestanding, so as long as this library provides basic operations
  and an allocator is provided, which is a type erased interface that can be used regardless of build type.

  Right now, there isn't a way to disable this library, unless you compile with 'nostdlib', which has huge implications.
  'for' loops wont work due to a lack of iterators, 'str' and 'String' and Slice!<T>/SliceMut!<T> types wont be available,
  literally nothing. (this will change in the future.)

*/

/*
  There's a better assertion library with pretty printing and such, however,
  we don't have out of order compilation, so we use this for the bootstrap libraries, because
  the fmt, io, and assertion library depend on many of the types we'll be testing here.

  hence the '_' prefix. this isn't meant to be used -- use 'import assertion::*' for access to better
  asserts.
*/

fn _assert(cond: bool, msg: str = "assertion failed") {
  if !cond {
    panic(msg);
  }
}

fn _assert_eq!<T>(a: T, b: T, msg: str = "assertion failed") where T: IsInteger | IsFloat | bool | IsPointer | Eq  {
  if a != b {
    where T: IsInteger {
      std::c::printf("%d != %d\n"c, a, b);
    } else where T: IsFloat {
      std::c::printf("%f != %f\n"c, a, b);
    } else where T: bool {
      a_string : str = if a { return "true"; } else { return "false"; };
      b_string : str = if b { return "true"; } else { return "false"; };
      std::c::printf("%s != %s\n"c, a_string.data, b_string.data);
    } else where T: IsPointer {
      std::c::printf("%p != %p\n"c, a, b);
    }
    panic(msg);
  }
}


module memory {
  @[inline] // an alternative to libc's memcpy
  fn copy!<T>(dest: *mut u8, src: *u8, len: T) where T: IsInteger {
    for i in 0..len {
      dest![i] = src![i];
    }
  }

  @[inline] // an alternative to libc's memset
  fn set!<T>(dest: *mut u8, value: u8, len: T) where T: IsInteger {
    for i in 0..len {
      dest![i] = value;
    }
  }

  @[inline] // an alternative to libc's memmove
  fn move!<T>(dest: *mut u8, src: *u8, len: T) where T: IsInteger {
    if dest == src || len == 0 {
      return;
    }
    if dest < src || dest >= src + len * size_of(u8) {
      // No overlap or safe to copy forwards
      for i in 0..len {
        dest![i] = src![i];
      }
    } else {
      // Overlap, copy backwards
      mut i: T = len;
      while i > 0 {
        i -= 1;
        dest![i] = src![i];
      }
    }
  }


  fn compare!<T, T1, Size_T>(s1: *T, s2: *T1, n: Size_T) {
    p1 := s1 as *u8;
    p2 := s1 as *u8;

    for i in 0..n {
      if (p1![i] < p2![i]) {
        return -1; // s1 is less than s2
      } else if (p1![i] > p2![i]) {
        return 1;  // s1 is greater than s2
      }
    }

    return 0; // s1 and s2 are equal for the first 'n' bytes
  }

  #test fn test_copy() {
    mut src: [u8; 5] = .[1, 2, 3, 4, 5];
    mut dest: [u8; 5] = .[0, 0, 0, 0, 0];
    copy(dest, src, 5);
    for i in 0..5 {
      if dest[i] != src[i] {
        panic("dest![i] != src![i] in test_copy");
      }
    }
  }

  #test fn test_set() {
    mut arr: [u8; 4] = .[0, 0, 0, 0];
    set(arr, 7, 4);
    for i in 0..4 {
      _assert_eq(arr[i], 7, "arr[i] != 7 in test_set");
    }
  }

  #test fn test_move_no_overlap() {
    mut src: [u8; 3] = .[9, 8, 7];
    mut dest: [u8; 3] = .[0, 0, 0];
    move(dest, src, 3);
    for i in 0..3 {
      _assert_eq(dest[i], src[i], "dest[i] != src[i] in test_move_no_overlap");
    }
  }

  #test fn test_move_overlap() {
    mut arr: [u8; 6] = .[1, 2, 3, 4, 5, 6];
    move(&mut arr[2], arr, 4);
    _assert_eq(arr[2], 1, "arr[2] != 1 in test_move_overlap");
    _assert_eq(arr[3], 2, "arr[3] != 2 in test_move_overlap");
    _assert_eq(arr[4], 3, "arr[4] != 3 in test_move_overlap");
    _assert_eq(arr[5], 4, "arr[5] != 4 in test_move_overlap");
  }
}

module string {
  @[inline] // an alternative to libc's strlen
  fn length(mut s: *u8) -> u32 {
    if !s {
      return 0;
    }
    mut len: u32;
    while *s != 0 {
      len += 1;
      s += size_of(u8);
    }
    return len;
  }

  @[inline] // an alternative to libc's strcpy
  fn copy!<T>(dest: *mut u8, src: *u8, len: T) where T: IsInteger {
    memory::copy(dest, src, len);
    dest![len] = '\0';
  }

  #test fn test_length() {
    arr: [u8; 6] = .['h', 'e', 'l', 'l', 'o', '\0'];
    len := length(arr);
    _assert_eq(len, 5, "len != 5 in test_length");
  }

  #test fn test_copy() {
    src: [u8; 6] = .['w', 'o', 'r', 'l', 'd', '\0'];
    mut dest: [u8; 7] = .[0, 0, 0, 0, 0, 0, 0];
    copy(dest, src, 5);
    for i in 0..5 {
      _assert_eq(dest[i], src[i], "dest[i] != src[i] in test_string_copy");
    }
    _assert_eq(dest[5], '\0', "dest[5] != '\\0' in test_string_copy");
  }
}
