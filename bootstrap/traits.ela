// equivalent to an explicit cast operator overload in C++,
// allow an object to be constructed from another.
// Except it's not done via casting, just a call.
trait From!<T> {
  // construct a self _type from T.
  fn from(v: T) -> Self;
}

// A deep clone, versus assignment always being a shallow clone in Ela. (think C memory semantics)
trait Clone {
  // get a deep clone of self.
  fn clone(self, allocator: dyn Allocator) -> Self;
}

// Construct from an InitList!<V>. This is never done automatically/implicitly, as of now.
trait Init!<V> {
  fn init(init: InitList!<V>, allocator: dyn Allocator) -> Self;
}

// Binary arithmetic operator overloads.
trait Arithmetic!<Right> {
  fn add(self, right: Right) -> Self;       // '+' operator.
  fn sub(self, right: Right) -> Self;       // '-' operator.
  fn mul(self, right: Right) -> Self;       // '*' operator.
  fn div(self, right: Right) -> Self;       // '/' operator.
  fn modulo(self, right: Right) -> Self;    // '%' operator.
}

// Binary bitwise operator overloading.
trait Bitwise!<Right> {
  fn shr(self, right: Right) -> Self;   // '>>' operator.
  fn shl(self, right: Right) -> Self;   // '<<' operator.
  fn xor(self, right: Right) -> Self;   //  '^' operator.
  fn or(self, right: Right) -> Self;   //  '|' operator.
  fn and(self, right: Right) -> Self;   //  '&' operator.
}

trait PartialEq!<Right> {
  fn eq(self, right: Right) -> bool;
  fn neq(self, right: Right) -> bool {
    return !self.eq(right);
  }
}

trait Eq where Self: PartialEq!<Self> {}

enum Ordering {
  Less = -1,
  Equal = 0,
  Greater = 1
}

trait PartialOrd!<Right> where Right: PartialEq!<Self> {
  fn cmp(self, right: Right) -> Option!<Ordering>;

  fn lt(self, right: Right) -> bool {
    if self.cmp(right) is Option!<Ordering>::Some(order) {
      return ordering == Ordering::Less;
    } else {
      return false;
    }
  }

  fn gt(self, right: Right) -> bool {
    if self.cmp(right) is Option!<Ordering>::Some(order) {
      return ordering == Ordering::Greater;
    } else {
      return false;
    }
  }

  fn lte(self, right: Right) -> bool {
    if self.cmp(right) is Option!<Ordering>::Some(order) {
      return ordering == Ordering::Less || ordering == Ordering::Equal;
    }
    return false;
  }

  fn gte(self, right: Right) -> bool {
    if self.cmp(right) is Option!<Ordering>::Some(order) {
      return ordering == Ordering::Greater || ordering == Ordering::Equal;
    }
    return false;
  }
}

trait Ord: Eq & PartialOrd!<Self> {
  fn max(self, other: Self) -> Self {
    if self > other {
      return self;
    }
    return other;
  }
  fn min(self, other: Self) -> Self {
    if self < other {
      return self;
    }
    return other;
  }
  fn clamp(self, min: Self, max: Self) -> Self {
    return self.max(min).min(max);
  }
}

trait Index!<T> {
  fn index(*const self, index: u64) -> *const T;
  fn index_mut(*mut self, index: u64) -> *mut T {
    return self.index(index) as *mut T;
  }
}

trait Hash {
  fn hash(self) -> u64;
}

trait AsSlice!<T> {
  fn as_slice(self) -> [T];

  fn subslice(self, range: Range) -> [T] {
    return self.as_slice()[range];
  }
}

/*
  index operator that takes [some_range], such as
  list[..10];
  list[10..20];
  etc
*/
/*
  TODO: when we can support generic operators, we should take a Range_T: IsRange
  right now it's just limited to s32. (which is a dumb default that we chose a long time ago.)
  it should be u32, and collections should all use u32 as length, not u64 (overkill)
*/
trait Slice_Index!<T> {
  fn slice_index(*const self, range: Range) -> [T];
  fn slice_index_mut(*mut self, range: Range) -> mut [T] {
    slice := self.slice_index(range);
    return .{
      data: slice.data as *mut T,
      length: slice.length,
    };
  }
}
