
alias char :: u32; // this represents a single UTF-8 scalar.

alias c_str :: *const u8;

struct Type;

// This is a string literal type. "..." will return this type.
// It's meant to be an immutable constant string.

// to get a 'u8*' literal, use `"..."c` the little `c` postfix.                              ^
struct str {
  data:    c_str,
  length:  u64,
}

// This is basically just a List!<u8>
// but it has some particularly special methods for dealing with strings,
// so it gets it's own distinct type.
struct String {
  data: *mut u8,
  length: u64,
  capacity: u64,
  allocator: *mut Dyn_Allocator,
}

// This is what is produced when you do
// .[0, 1, 2, 3]
// it is stack allocated and does not need to be freed, nor
// should it ever be held on to.
struct InitList!<V> {
  data:   *const V,
  length: u64,
}

// A collection of items.
struct List!<V> {
  data:     *mut V,
  length:   u64,
  capacity: u64,
  allocator: *mut Dyn_Allocator,
}

// A semi-type-erased pointer that carries the RTTI (Runtime type information)
// with it for a way to do "duck typing" in a way.
struct any {
  ptr:  *mut void,
  type: *const Type
};

// A non-owning immutable fat pointer. This should just be a view into a pointer, that tracks length.
// very useful for efficiently passing arrays of data to functions for quick usage with a known (temporary)lifetime,
// iterating over subarrays, etc.
struct Slice!<V> {
  data:  *const V,
  length: u64,
}

// Same as above but mutable, for cheaply modifying subsets of data within ranges of memory.
struct SliceMut!<V> {
  data:  *mut V,
  length: u64,
}

const RESULT_IS_ERR: u8 =  0;
const RESULT_IS_OK: u8 =  1;

choice Result!<_Ok, _Err> {
  Ok(_Ok),
  Err(_Err),
}

choice Option!<T> {
  None,
  Some(T),
}