// flags enum utils. such as Flags trait, a default impl for simple flag manipulation methods.
#include "flags.ela";
// all of your basic types.
#include "typedef.ela"
// many more basic types, mainly traits.
#include "traits.ela";
// Option!<T>
#include "option.ela";
// Iterator<T> and Iterable<T>
#include "iter.ela";
// impls for numeric types, mostly marker traits.
#include "numeric.ela"; 
// RangeBase!<T> and Range, Range_s32... etc.
#include "range.ela";

#ifndef FREESTANDING {
  // a few libc functions that are used in most programs.
  #include "libc.ela";
}

#def LIB_ELA_IMPLEMENTATION 
// TODO: once conditionals are pushed back to type time, this will make sense. 
// for now, it's permanently enabled.
// some alternatives to libc functions, so we don't _need_ 
// to link against libc to get basic memory and string functions
#ifdef LIB_ELA_IMPLEMENTATION {
  module std {
    #include "libela.ela";
  }
}

// dynamic trait for allocator.
#include "memory.ela";

module collections { // TODO: put the typedefs in this module too.
  // List!<T>
  #include "list.ela";
  // Iterators and such for InitList!<T>
  #include "init_list.ela";
  // [T] and SliceMut!<T>, views over memory.
  #include "slice.ela";

  #ifdef TESTING {
    #include "tests/collections/list.ela";
    #include "tests/collections/init_list.ela";
    #include "tests/collections/slice.ela";
  }
}

import collections::{
  Slice,
  SliceMut,
};

// utils that both string types use, avoiding some redundancy
#include "stringutils.ela";
// str, the default type of a string literal.
#include "str.ela";
// String, heap allocated string.
#include "String.ela";
// generic utilities for reflection
#include "refl.ela";
// basic hashing functions implemented for numerical and string types.
#include "hash.ela";
// char utils
#include "char.ela";
// panic stuff
#include "panic.ela";
// Result!<Ok, Err>
#include "result.ela";

// default testing apparatus.
#ifdef TESTING {  
  #include "testing.ela";
}

struct Env {
  args_slice: [str],
};

extern fn getenv(buf: c_str) -> c_str;

impl Env {
  fn current() -> *mut Self {
    #static mut self: Self;
    return &mut self;
  }

  /* 
    The args are passed by the C runtime,
    and never need to be deallocated. Nor should they be
    mutated.
  */
  fn args() -> [str] {
    return Env::current().args_slice;
  }

  fn args_without_program_name() -> [str] {
    slice := Env::current().args_slice;
    if slice.length == 0 {
      return .{};
    }
    return slice.slice(1..slice.length);
  }
  
  fn env_strlen(s: *const u8) -> u32 {
    mut i := 0;
    while *s {
      ++i;
      ++s;
    }
    return i;
  }

  fn initialize(argc: s32, argv: *const c_str) {
    self := Env::current();

    #ifndef FREESTANDING {
      mut data : *mut str = std::c::malloc(argc * sizeof(str));
    } else {
      // This is just a hack. idk what a reasonable value to put here is.
      // 'getconf ARG_MAX' shows my shell can take over 2 million arguments, 
      // which obviously isn't possible to stack allocate here.
      // I think 2048 is a reasonable compromise -- that would almost never be exceeded, especially
      // since command line programs aren't often freestanding, and distributed programs aren't really taking
      // command line arguments (in my experience, i could easily be wrong)
      #static mut data : [str; 2048]; 
    }
    

    for i in 0..argc {
      data![i] = .{
        data: argv![i],
        length: Env::env_strlen(argv![i]),
      };
    }

    self.args_slice = .{
      data: data,
      length: argc,
    };
  }

  fn home_dir() -> String {
    mut var: c_str;
    if (var = getenv("XDG_CONFIG_HOME"c)) {
      return String::from_ptr(var);
    } else if (var = getenv("HOME"c)) {
      return String::from_ptr(var);
    } else {
      panic("Unable to get HOME or XDG_CONFIG_HOME env vars, it's likely your platform isn't supported");
    }
  }

  fn args_string() -> String {
    slice := Env::current().args_slice;
    mut out: String;
    for string in slice {
      out.append(string);
    }
    return out;
  }
}

impl AsSlice!<u8> for u32 {
  fn as_slice(self) -> [u8] {
    #static mut chars : [u8; 2] = .[
      '\0', '\0'
    ];
    chars[0] = self;
    return .{
      data: chars,
      length: 1,
    }
  }
}

fn new!<T>(initial_value: T) -> *mut T {
  ptr: *mut T = get_global_allocator().allocate(sizeof(T));
  *ptr = initial_value;
  return ptr;
}

fn default!<T>() -> T {
  where T: IsPointer {
    return null;
  } else {
    _value: T;
    return _value;
  }
}

// COMPILER IMPLEMENTED TRAITS FOR PATTERN MATCHING TYPES
/*
? Most of these are just type descriptors, and are completely self explanatory by name.
  * trait IsFnPtr {}
  * trait IsFn {}
  * trait IsTuple {}
  * trait IsStruct {}
  * trait IsEnum {}
  * trait IsChoice {}
  * trait IsDyn {}
  * trait IsUnion {}
  * trait IsArray {}
  * trait IsPointer {}
  * trait IsMutPointer {}
  * trait IsConstPointer {}
  * trait IsSlice {}
  * trait IsSliceMut {}


? These are special traits, that arent as self explanatory.
  * trait Blittable {}

   - Blittable types are those which contain no pointers or references, or any subtypes that aren't blittable.
     Meaning they can be memcpy'd into a block of memory with no special handling.

   An example of a blittable type:
    struct T {
      x: s32,
      y: s32,
      z: s32,
      f: [f32; 100]             <- Ok.
      g: AnotherBlittableType   <- Ok.
    }

    note: 
      fixed arrays are not considered a pointer since the instantiated struct has to allocate all of the memory required to store it.
      subtypes don't disqualify the parent as long as the subtype is also blittable.

   An example of a _non_ blittable type:
    struct T {
      x: s32,
      y: *s32,            <- pointer disqualifies
      list: List!<s32>    <- contains a pointer, disqualified.
    }

    The most common use cases for checking against Blittable are probably
     - binary serialization, 
     - interop into managed environments,
     - copying buffers of data into a new owned buffer, etc.
*/

