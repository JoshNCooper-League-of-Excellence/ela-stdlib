import fmt;
import fs;
import stream;

const FILE_STREAM_BUFFER_LENGTH: u16 = 1024;

struct StreamWriter {
  file: fs::File,
  position: u64,
  buffer: [u8; FILE_STREAM_BUFFER_LENGTH], // TODO: probably make this a heap buffer.
  line_buffered: bool = true // If this is true, each '\n' will force flush the stream. this is typical behaviour coming from C++ or C
}

impl StreamWriter {
  fn new!<PathT>(path: PathT, open_flags: fs::FileOpenFlags) -> Self where PathT: AsSlice!<u8> {
    return .{
      file: fs::File::open(path, open_flags),
    };
  }

  fn from(file: fs::File) -> Self {
    return .{
      file: file,
    };
  }
}

impl stream::Buffered!<u8> for StreamWriter {
  fn flush(*mut self) {
    if self.position == 0 {
      return;
    }

    self.file.write_raw(self.buffer, self.position);
    self.position = 0;
  }
  fn clear(*mut self) {
    self.position = 0;
  }
}

impl stream::Writer!<u8> for StreamWriter {
  fn write(*mut self, byte: u8) {
    if self.position >= FILE_STREAM_BUFFER_LENGTH || (self.line_buffered && byte == '\n') {
      self.flush();
    }
    self.buffer[self.position] = byte;
    self.position += 1;
  }
}

impl Destroy for StreamWriter {
  fn destroy(*mut self, recursive: bool = false) {
    self.flush();
    self.file.destroy(recursive);
  }
}


struct StreamReader {
  file: fs::File,
  buffer: List!<u8>,
  buffer_index: u64,
  buffer_capacity: u64 = 1024 
}

impl StreamReader {
  fn from(file: fs::File, capacity: u64) -> Self {
    mut self: Self = .{ file: file };
    self.buffer.resize(self.buffer_capacity = capacity);
    return self;
  }

  fn new!<PathT>(path: PathT, open_flags: fs::FileOpenFlags, capacity: u64) -> Self where PathT: AsSlice!<u8> {
    file := fs::File::open(path, open_flags);
    return StreamReader::from(file, capacity);
  }
}

impl stream::Reader!<u8> for StreamReader {
  fn read(*mut self) -> Option!<u8> {
    if self.buffer_index >= self.buffer.length {
      self.buffer.clear();
      mut buffer: [u8; 1024];
      bytes_read := self.file.read(buffer, self.buffer_capacity);

      if bytes_read == 0 {
        return None();
      }

      self.buffer.push_range([u8].{
        data: buffer,
        length: bytes_read
      });

      self.buffer_index = 0;
    }

    byte := self.buffer[self.buffer_index];
    self.buffer_index += 1;
    return Some(byte);
  }
}

impl Destroy for StreamReader {
  fn destroy(*mut self, recursive: bool = false) {
    self.file.destroy(recursive);
    self.buffer.destroy(recursive);
  }
}

#ifndef FREESTANDING {
  extern stdin: *mut fs::FILE;
  extern stdout: *mut fs::FILE;

  fn get_stdin() -> StreamReader {
    return StreamReader::from(fs::File.{
      fd: stdin
    }, 1);
  }

  fn get_stdout() -> StreamWriter {
    return StreamWriter::from(fs::File.{
      fd: stdout
    });
  }
}


fn print!<T>(message: T, options: fmt::FormatOptions = *FormatOptions::current()) {
  where T: fmt::Format {
    using mut sstream: StringStream;

    mut formatter: fmt::Formatter = .{
      writer: &mut sstream,
      options: options,
    };

    message.format(&mut formatter);
    using formatted := sstream.get_string();
    std::c::printf("%s"c, formatted.data);
    
  } else {
    mut formatted := format("%", (message,), options);
    std::c::printf("%s"c, formatted.data);
    formatted.destroy();
  }
}

fn println!<T>(message: T, options: FormatOptions = *FormatOptions::current()) {
  where T: Format {
    mut sstream: StringStream;
    mut formatter: Formatter = .{
      writer: &mut sstream,
      options: options,
    };
    message.format(&mut formatter);
    formatted := sstream.get_string();
    defer {
      formatted.destroy();
      sstream.destroy();
    }
    std::c::printf("%s\n"c, formatted.data);
  } else {
    mut formatted := format("%", (message,), options);
    std::c::printf("%s\n"c, formatted.data);
    formatted.destroy();
  }
}

fn printlnf!<Tuple>(fmt: str, tuple: Tuple, options: FormatOptions = *FormatOptions::current()) where Tuple: IsTuple | Format {
  mut formatted := format(fmt, tuple, options);
  std::c::printf("%s\n"c, formatted.data);
  formatted.destroy();
}

fn printf!<Tuple>(fmt: str, tuple: Tuple, options: FormatOptions = *FormatOptions::current()) where Tuple: IsTuple | Format {
  mut formatted := format(fmt, tuple, options);
  std::c::printf("%s"c, formatted.data);
  formatted.destroy();
}