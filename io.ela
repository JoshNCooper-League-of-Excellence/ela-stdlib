import fs;
import fmt;
import stream;

const FILE_STREAM_BUFFER_LENGTH: u16 = 1024;

struct StreamWriter {
  file: fs::File,
  position: u64,
  buffer: [u8; FILE_STREAM_BUFFER_LENGTH], // TODO: probably make this a heap buffer.
  line_buffered: bool = true // If this is true, each '\n' will force flush the stream. this is typical behaviour coming from C++ or C
}

impl StreamWriter {
  fn new!<PathT>(path: PathT, open_flags: fs::FileOpenFlags) -> Self where PathT: AsSlice!<u8> {
    return .{
      file: fs::File::open(path, open_flags),
    };
  }

  fn from(file: fs::File) -> Self {
    return .{
      file: file,
    };
  }
}

impl stream::Buffered!<u8> for StreamWriter {
  fn flush(*mut self) {
    if self.position == 0 {
      return;
    }

    self.file.write_raw(self.buffer, self.position);
    self.position = 0;
  }
  fn clear(*mut self) {
    self.position = 0;
  }
}

impl stream::Writer!<u8> for StreamWriter {
  fn write(*mut self, byte: u8) {
    if self.position >= FILE_STREAM_BUFFER_LENGTH || (self.line_buffered && byte == '\n') {
      self.flush();
    }
    self.buffer[self.position] = byte;
    self.position += 1;
  }
}


impl Destroy for StreamWriter {
  fn destroy(*mut self, recursive: bool = false) {
    self.flush();
    self.file.destroy(recursive);
  }
}

struct StreamReader {
  file: fs::File,
  buffer: List!<u8>,
  buffer_index: u64,
  buffer_capacity: u64 = 1024 
}

impl StreamReader {
  fn from(file: fs::File, capacity: u64) -> Self {
    mut self: Self = .{ file: file };
    self.buffer.resize(self.buffer_capacity = capacity);
    return self;
  }

  fn new!<PathT>(path: PathT, open_flags: fs::FileOpenFlags, capacity: u64) -> Self where PathT: AsSlice!<u8> {
    file := fs::File::open(path, open_flags);
    return StreamReader::from(file, capacity);
  }
}

impl stream::Reader!<u8> for StreamReader {
  fn read(*mut self) -> Option!<u8> {
    if self.buffer_index >= self.buffer.length {
      self.buffer.clear();
      mut buffer: [u8; 1024];
      bytes_read := self.file.read(buffer, self.buffer_capacity);

      if bytes_read == 0 {
        return None();
      }

      self.buffer.push_range([u8].{
        data: buffer,
        length: bytes_read
      });

      self.buffer_index = 0;
    }

    byte := self.buffer[self.buffer_index];
    self.buffer_index += 1;
    return Some(byte);
  }
}

struct PollFD { fd: s32, events: s16, revents: s16 };
extern fn poll(fds: *mut PollFD, nfds: u64, timeout: s32) -> s32;
extern fn fileno(file: *mut fs::FILE) -> s32;
const POLLIN: s16 = 0x001;

impl StreamReader {
  fn read_non_blocking(*mut self) -> Option!<u8> {
    fd := fileno(self.file.fd);
    mut p: PollFD = .{ fd: fd, events: POLLIN, revents: 0 };
    if poll(&mut p, 1, 0) <= 0 {
      //>
      // no data available right now
      return None(); 
    }

    // existing buffer refill logic (will now not block because poll said its ready)
    if self.buffer_index >= self.buffer.length {
      self.buffer.clear();
      mut buffer: [u8; 1024];
      bytes_read := self.file.read(buffer, self.buffer_capacity);
      if bytes_read == 0 {
        return None();
      }
      self.buffer.push_range([u8].{ data: buffer, length: bytes_read });
      self.buffer_index = 0;
    }

    byte := self.buffer[self.buffer_index];
    self.buffer_index += 1;
    return Some(byte);
  }

  fn read_line(*mut self) -> String {
    mut complete: bool;
    mut buffer: String;
    while {
      if self.read() is Option!<u8>::Some(ch) {
        if ch == '\n' {
          break;
        }
        buffer.push(ch);
      } else {
        break;
      }
    }
    return buffer;
  }
}


impl Destroy for StreamReader {
  fn destroy(*mut self, recursive: bool = false) {
    self.file.destroy(recursive);
    self.buffer.destroy(recursive);
  }
}

#ifndef FREESTANDING {
  extern stdin: *mut fs::FILE;
  extern stdout: *mut fs::FILE;

  fn get_stdin() -> StreamReader {
    return StreamReader::from(fs::File.{
      fd: stdin
    }, 1);
  }

  fn get_stdout() -> StreamWriter {
    return StreamWriter::from(fs::File.{
      fd: stdout
    });
  }
}