//module pthread;

struct pthread_attr_t;
type pthread_t :: u64;

type ThreadFunction :: fn(*mut void);
type ThreadStartRoutine :: fn(*mut void) -> *mut void;

extern fn pthread_create(thread: *mut pthread_t, attr: *const pthread_attr_t, start_routine: ThreadStartRoutine, arg: *mut void) -> s32;
extern fn pthread_join(thread: *mut pthread_t, retval: *const *const void) -> s32;

union pthread_mutex_t {
  __size: [u8; 40],
  __align: s64,
}

/* forward */ 
fn start_thread(arg: *mut void) -> *mut void;

/* Simple thread struct */
struct Thread {
  handle: pthread_t
}

impl Thread {    
  fn start(start_function: ThreadFunction, arg: *mut void) -> Result!<Self, str> {
    self: Self;
    // this memory gets deleted in start_thread();
    parameters := new((start_function, arg));
    if pthread_create(&mut self.handle, null, &mut start_thread, parameters) != 0 {
      return Result!<Self, str>::Err("failed to create thread");
    }
    return Result!<Self, str>::Ok(self);
  }
  
  fn join(*mut self) -> void {
    #static n : *mut void;
    pthread_join(&mut self.handle, &mut n);
  }
}

/* wrapper callback to init Thread struct. */ 
fn start_thread(arg: *mut void) -> *mut void {
  tuple_ptr := arg as *const (ThreadFunction, *mut void);
  tuple := *tuple_ptr;
  function, user_arg := tuple;
  function(user_arg);
  std::c::free(arg);   // allocated by Thread::start();
  return null;
}
  
extern fn pthread_mutex_init(mutex: *mut pthread_mutex_t, attr: *const void) -> s32;
extern fn pthread_mutex_lock(mutex: *mut pthread_mutex_t) -> s32;
extern fn pthread_mutex_unlock(mutex: *mut pthread_mutex_t) -> s32;
extern fn pthread_mutex_destroy(mutex: *mut pthread_mutex_t) -> s32;

/* Simple mutex */
struct SimpleMutex {
  handle: pthread_mutex_t
}

impl SimpleMutex {
  fn new() -> Self {
    self: Self;
    pthread_mutex_init(&mut self.handle, null);
    return self;
  }
  fn lock(*mut self) {
    pthread_mutex_lock(&mut self.handle);
  }
  fn unlock(*mut self) {
    pthread_mutex_unlock(&mut self.handle);
  }
  fn free(*mut self) {
    pthread_mutex_destroy(&mut self.handle);
  }
}

impl Destroy for SimpleMutex {
  fn destroy(*mut self, recursive: bool = false) {
    self.free();
  }
}


/* 
  Typed mutex which holds the data it's protecting.
*/
struct Mutex!<T> {
  handle: pthread_mutex_t,
  value: T,
}

impl!<T> Mutex!<T> {
  fn new() -> Self {
    self: Self;
    pthread_mutex_init(&mut self.handle, null);
    return self;
  }
  fn lock(*mut self) -> *mut T {
    pthread_mutex_lock(&mut self.handle);
    return &mut self.value;
  }
  fn unlock(*mut self) {
    pthread_mutex_unlock(&mut self.handle);
  }
}

impl!<T> Destroy for Mutex!<T> {
  fn destroy(*mut self, recursive: bool = false) {
    pthread_mutex_destroy(&mut self.handle);
    where T: Destroy {
      self.value.destroy(recursive);
    }
  }
}

union pthread_cond_t {
  __size: [u8; 48],
  __align: s64,
}

extern fn pthread_cond_init(cond: *mut pthread_cond_t, attr: *const void) -> s32;
extern fn pthread_cond_wait(cond: *mut pthread_cond_t, mutex: *mut pthread_mutex_t) -> s32;
extern fn pthread_cond_signal(cond: *mut pthread_cond_t) -> s32;
extern fn pthread_cond_broadcast(cond: *mut pthread_cond_t) -> s32;
extern fn pthread_cond_destroy(cond: *mut pthread_cond_t) -> s32;


/* Simple condition variable */
struct CondVar {
  handle: pthread_cond_t
}

impl CondVar {
  fn new() -> Self {
    self: Self;
    pthread_cond_init(&mut self.handle, null);
    return self;
  }
  fn wait!<T>(*mut self, mutex: *mut Mutex!<T>) {
    pthread_cond_wait(&mut self.handle, &mut mutex.handle);
  }
  fn signal(*mut self) {
    pthread_cond_signal(&mut self.handle);
  }
  fn broadcast(*mut self) {
    pthread_cond_broadcast(&mut self.handle);
  }
  fn free(*mut self) {
    pthread_cond_destroy(&mut self.handle);
  }
}

impl Destroy for CondVar {
  fn destroy(*mut self, recursive: bool = false) {
    self.free();
  }
}