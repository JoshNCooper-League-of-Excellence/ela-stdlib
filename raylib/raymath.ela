/*
  These bindings were auto generated by 'ela-bindings-generator', from 'raymath.c' at 2025-03-11 12:53:54. 
*/
Vector2 :: struct {
  x: f32,
  y: f32,
};
Vector3 :: struct {
  x: f32,
  y: f32,
  z: f32,
};
Vector4 :: struct {
  x: f32,
  y: f32,
  z: f32,
  w: f32,
};
alias Quaternion :: Vector4;
Matrix :: struct {
  m0: f32,
  m4: f32,
  m8: f32,
  m12: f32,
  m1: f32,
  m5: f32,
  m9: f32,
  m13: f32,
  m2: f32,
  m6: f32,
  m10: f32,
  m14: f32,
  m3: f32,
  m7: f32,
  m11: f32,
  m15: f32,
};
float3 :: struct {
  v: f32[3],
};
float16 :: struct {
  v: f32[16],
};
#foreign acos :: fn(__x: f64) -> f64;
#foreign asin :: fn(__x: f64) -> f64;
#foreign atan :: fn(__x: f64) -> f64;
#foreign atan2 :: fn(__y: f64, __x: f64) -> f64;
#foreign cos :: fn(__x: f64) -> f64;
#foreign sin :: fn(__x: f64) -> f64;
#foreign tan :: fn(__x: f64) -> f64;
#foreign cosh :: fn(__x: f64) -> f64;
#foreign sinh :: fn(__x: f64) -> f64;
#foreign tanh :: fn(__x: f64) -> f64;
#foreign acosh :: fn(__x: f64) -> f64;
#foreign asinh :: fn(__x: f64) -> f64;
#foreign atanh :: fn(__x: f64) -> f64;
#foreign exp :: fn(__x: f64) -> f64;
#foreign frexp :: fn(__x: f64, __exponent: *mut s32) -> f64;
#foreign ldexp :: fn(__x: f64, __exponent: s32) -> f64;
#foreign log :: fn(__x: f64) -> f64;
#foreign log10 :: fn(__x: f64) -> f64;
#foreign modf :: fn(__x: f64, __iptr: *mut f64) -> f64;
#foreign expm1 :: fn(__x: f64) -> f64;
#foreign log1p :: fn(__x: f64) -> f64;
#foreign logb :: fn(__x: f64) -> f64;
#foreign exp2 :: fn(__x: f64) -> f64;
#foreign log2 :: fn(__x: f64) -> f64;
#foreign pow :: fn(__x: f64, __y: f64) -> f64;
#foreign sqrt :: fn(__x: f64) -> f64;
#foreign hypot :: fn(__x: f64, __y: f64) -> f64;
#foreign cbrt :: fn(__x: f64) -> f64;
#foreign ceil :: fn(__x: f64) -> f64;
#foreign fabs :: fn(__x: f64) -> f64;
#foreign floor :: fn(__x: f64) -> f64;
#foreign fmod :: fn(__x: f64, __y: f64) -> f64;
#foreign isinf :: fn(__value: f64) -> s32;
#foreign finite :: fn(__value: f64) -> s32;
#foreign drem :: fn(__x: f64, __y: f64) -> f64;
#foreign significand :: fn(__x: f64) -> f64;
#foreign copysign :: fn(__x: f64, __y: f64) -> f64;
#foreign nan :: fn(__tagb: *const u8) -> f64;
#foreign isnan :: fn(__value: f64) -> s32;
#foreign j0 :: fn(param0: f64) -> f64;
#foreign j1 :: fn(param0: f64) -> f64;
#foreign jn :: fn(param0: s32, param1: f64) -> f64;
#foreign y0 :: fn(param0: f64) -> f64;
#foreign y1 :: fn(param0: f64) -> f64;
#foreign yn :: fn(param0: s32, param1: f64) -> f64;
#foreign erf :: fn(param0: f64) -> f64;
#foreign erfc :: fn(param0: f64) -> f64;
#foreign lgamma :: fn(param0: f64) -> f64;
#foreign tgamma :: fn(param0: f64) -> f64;
#foreign gamma :: fn(param0: f64) -> f64;
#foreign lgamma_r :: fn(param0: f64, __signgamp: *mut s32) -> f64;
#foreign rint :: fn(__x: f64) -> f64;
#foreign nextafter :: fn(__x: f64, __y: f64) -> f64;
#foreign nexttoward :: fn(__x: f64, __y: f64) -> f64;
#foreign remainder :: fn(__x: f64, __y: f64) -> f64;
#foreign scalbn :: fn(__x: f64, __n: s32) -> f64;
#foreign ilogb :: fn(__x: f64) -> s32;
#foreign scalbln :: fn(__x: f64, __n: s64) -> f64;
#foreign nearbyint :: fn(__x: f64) -> f64;
#foreign round :: fn(__x: f64) -> f64;
#foreign trunc :: fn(__x: f64) -> f64;
#foreign remquo :: fn(__x: f64, __y: f64, __quo: *mut s32) -> f64;
#foreign lrint :: fn(__x: f64) -> s64;
#foreign llrint :: fn(__x: f64) -> s64;
#foreign lround :: fn(__x: f64) -> s64;
#foreign llround :: fn(__x: f64) -> s64;
#foreign fdim :: fn(__x: f64, __y: f64) -> f64;
#foreign fmax :: fn(__x: f64, __y: f64) -> f64;
#foreign fmin :: fn(__x: f64, __y: f64) -> f64;
#foreign fma :: fn(__x: f64, __y: f64, __z: f64) -> f64;
#foreign scalb :: fn(__x: f64, __n: f64) -> f64;
#foreign acosf :: fn(__x: f32) -> f32;
#foreign asinf :: fn(__x: f32) -> f32;
#foreign atanf :: fn(__x: f32) -> f32;
#foreign atan2f :: fn(__y: f32, __x: f32) -> f32;
#foreign cosf :: fn(__x: f32) -> f32;
#foreign sinf :: fn(__x: f32) -> f32;
#foreign tanf :: fn(__x: f32) -> f32;
#foreign coshf :: fn(__x: f32) -> f32;
#foreign sinhf :: fn(__x: f32) -> f32;
#foreign tanhf :: fn(__x: f32) -> f32;
#foreign acoshf :: fn(__x: f32) -> f32;
#foreign asinhf :: fn(__x: f32) -> f32;
#foreign atanhf :: fn(__x: f32) -> f32;
#foreign expf :: fn(__x: f32) -> f32;
#foreign frexpf :: fn(__x: f32, __exponent: *mut s32) -> f32;
#foreign ldexpf :: fn(__x: f32, __exponent: s32) -> f32;
#foreign logf :: fn(__x: f32) -> f32;
#foreign log10f :: fn(__x: f32) -> f32;
#foreign modff :: fn(__x: f32, __iptr: *mut f32) -> f32;
#foreign expm1f :: fn(__x: f32) -> f32;
#foreign log1pf :: fn(__x: f32) -> f32;
#foreign logbf :: fn(__x: f32) -> f32;
#foreign exp2f :: fn(__x: f32) -> f32;
#foreign log2f :: fn(__x: f32) -> f32;
#foreign powf :: fn(__x: f32, __y: f32) -> f32;
#foreign sqrtf :: fn(__x: f32) -> f32;
#foreign hypotf :: fn(__x: f32, __y: f32) -> f32;
#foreign cbrtf :: fn(__x: f32) -> f32;
#foreign ceilf :: fn(__x: f32) -> f32;
#foreign fabsf :: fn(__x: f32) -> f32;
#foreign floorf :: fn(__x: f32) -> f32;
#foreign fmodf :: fn(__x: f32, __y: f32) -> f32;
#foreign isinff :: fn(__value: f32) -> s32;
#foreign finitef :: fn(__value: f32) -> s32;
#foreign dremf :: fn(__x: f32, __y: f32) -> f32;
#foreign significandf :: fn(__x: f32) -> f32;
#foreign copysignf :: fn(__x: f32, __y: f32) -> f32;
#foreign nanf :: fn(__tagb: *const u8) -> f32;
#foreign isnanf :: fn(__value: f32) -> s32;
#foreign j0f :: fn(param0: f32) -> f32;
#foreign j1f :: fn(param0: f32) -> f32;
#foreign jnf :: fn(param0: s32, param1: f32) -> f32;
#foreign y0f :: fn(param0: f32) -> f32;
#foreign y1f :: fn(param0: f32) -> f32;
#foreign ynf :: fn(param0: s32, param1: f32) -> f32;
#foreign erff :: fn(param0: f32) -> f32;
#foreign erfcf :: fn(param0: f32) -> f32;
#foreign lgammaf :: fn(param0: f32) -> f32;
#foreign tgammaf :: fn(param0: f32) -> f32;
#foreign gammaf :: fn(param0: f32) -> f32;
#foreign lgammaf_r :: fn(param0: f32, __signgamp: *mut s32) -> f32;
#foreign rintf :: fn(__x: f32) -> f32;
#foreign nextafterf :: fn(__x: f32, __y: f32) -> f32;
#foreign nexttowardf :: fn(__x: f32, __y: f64) -> f32;
#foreign remainderf :: fn(__x: f32, __y: f32) -> f32;
#foreign scalbnf :: fn(__x: f32, __n: s32) -> f32;
#foreign ilogbf :: fn(__x: f32) -> s32;
#foreign scalblnf :: fn(__x: f32, __n: s64) -> f32;
#foreign nearbyintf :: fn(__x: f32) -> f32;
#foreign roundf :: fn(__x: f32) -> f32;
#foreign truncf :: fn(__x: f32) -> f32;
#foreign remquof :: fn(__x: f32, __y: f32, __quo: *mut s32) -> f32;
#foreign lrintf :: fn(__x: f32) -> s64;
#foreign llrintf :: fn(__x: f32) -> s64;
#foreign lroundf :: fn(__x: f32) -> s64;
#foreign llroundf :: fn(__x: f32) -> s64;
#foreign fdimf :: fn(__x: f32, __y: f32) -> f32;
#foreign fmaxf :: fn(__x: f32, __y: f32) -> f32;
#foreign fminf :: fn(__x: f32, __y: f32) -> f32;
#foreign fmaf :: fn(__x: f32, __y: f32, __z: f32) -> f32;
#foreign scalbf :: fn(__x: f32, __n: f32) -> f32;
#foreign acosl :: fn(__x: f64) -> f64;
#foreign asinl :: fn(__x: f64) -> f64;
#foreign atanl :: fn(__x: f64) -> f64;
#foreign atan2l :: fn(__y: f64, __x: f64) -> f64;
#foreign cosl :: fn(__x: f64) -> f64;
#foreign sinl :: fn(__x: f64) -> f64;
#foreign tanl :: fn(__x: f64) -> f64;
#foreign coshl :: fn(__x: f64) -> f64;
#foreign sinhl :: fn(__x: f64) -> f64;
#foreign tanhl :: fn(__x: f64) -> f64;
#foreign acoshl :: fn(__x: f64) -> f64;
#foreign asinhl :: fn(__x: f64) -> f64;
#foreign atanhl :: fn(__x: f64) -> f64;
#foreign expl :: fn(__x: f64) -> f64;
#foreign frexpl :: fn(__x: f64, __exponent: *mut s32) -> f64;
#foreign ldexpl :: fn(__x: f64, __exponent: s32) -> f64;
#foreign logl :: fn(__x: f64) -> f64;
#foreign log10l :: fn(__x: f64) -> f64;
#foreign modfl :: fn(__x: f64, __iptr: *mut f64) -> f64;
#foreign expm1l :: fn(__x: f64) -> f64;
#foreign log1pl :: fn(__x: f64) -> f64;
#foreign logbl :: fn(__x: f64) -> f64;
#foreign exp2l :: fn(__x: f64) -> f64;
#foreign log2l :: fn(__x: f64) -> f64;
#foreign powl :: fn(__x: f64, __y: f64) -> f64;
#foreign sqrtl :: fn(__x: f64) -> f64;
#foreign hypotl :: fn(__x: f64, __y: f64) -> f64;
#foreign cbrtl :: fn(__x: f64) -> f64;
#foreign ceill :: fn(__x: f64) -> f64;
#foreign fabsl :: fn(__x: f64) -> f64;
#foreign floorl :: fn(__x: f64) -> f64;
#foreign fmodl :: fn(__x: f64, __y: f64) -> f64;
#foreign isinfl :: fn(__value: f64) -> s32;
#foreign finitel :: fn(__value: f64) -> s32;
#foreign dreml :: fn(__x: f64, __y: f64) -> f64;
#foreign significandl :: fn(__x: f64) -> f64;
#foreign copysignl :: fn(__x: f64, __y: f64) -> f64;
#foreign nanl :: fn(__tagb: *const u8) -> f64;
#foreign isnanl :: fn(__value: f64) -> s32;
#foreign j0l :: fn(param0: f64) -> f64;
#foreign j1l :: fn(param0: f64) -> f64;
#foreign jnl :: fn(param0: s32, param1: f64) -> f64;
#foreign y0l :: fn(param0: f64) -> f64;
#foreign y1l :: fn(param0: f64) -> f64;
#foreign ynl :: fn(param0: s32, param1: f64) -> f64;
#foreign erfl :: fn(param0: f64) -> f64;
#foreign erfcl :: fn(param0: f64) -> f64;
#foreign lgammal :: fn(param0: f64) -> f64;
#foreign tgammal :: fn(param0: f64) -> f64;
#foreign gammal :: fn(param0: f64) -> f64;
#foreign lgammal_r :: fn(param0: f64, __signgamp: *mut s32) -> f64;
#foreign rintl :: fn(__x: f64) -> f64;
#foreign nextafterl :: fn(__x: f64, __y: f64) -> f64;
#foreign nexttowardl :: fn(__x: f64, __y: f64) -> f64;
#foreign remainderl :: fn(__x: f64, __y: f64) -> f64;
#foreign scalbnl :: fn(__x: f64, __n: s32) -> f64;
#foreign ilogbl :: fn(__x: f64) -> s32;
#foreign scalblnl :: fn(__x: f64, __n: s64) -> f64;
#foreign nearbyintl :: fn(__x: f64) -> f64;
#foreign roundl :: fn(__x: f64) -> f64;
#foreign truncl :: fn(__x: f64) -> f64;
#foreign remquol :: fn(__x: f64, __y: f64, __quo: *mut s32) -> f64;
#foreign lrintl :: fn(__x: f64) -> s64;
#foreign llrintl :: fn(__x: f64) -> s64;
#foreign lroundl :: fn(__x: f64) -> s64;
#foreign llroundl :: fn(__x: f64) -> s64;
#foreign fdiml :: fn(__x: f64, __y: f64) -> f64;
#foreign fmaxl :: fn(__x: f64, __y: f64) -> f64;
#foreign fminl :: fn(__x: f64, __y: f64) -> f64;
#foreign fmal :: fn(__x: f64, __y: f64, __z: f64) -> f64;
#foreign scalbl :: fn(__x: f64, __n: f64) -> f64;
#foreign Clamp :: fn(value: f32, min: f32, max: f32) -> f32;
#foreign Lerp :: fn(start: f32, end: f32, amount: f32) -> f32;
#foreign Normalize :: fn(value: f32, start: f32, end: f32) -> f32;
#foreign Remap :: fn(value: f32, inputStart: f32, inputEnd: f32, outputStart: f32, outputEnd: f32) -> f32;
#foreign Wrap :: fn(value: f32, min: f32, max: f32) -> f32;
#foreign FloatEquals :: fn(x: f32, y: f32) -> s32;
#foreign Vector2Zero :: fn() -> Vector2;
#foreign Vector2One :: fn() -> Vector2;
#foreign Vector2Add :: fn(v1: Vector2, v2: Vector2) -> Vector2;
#foreign Vector2AddValue :: fn(v: Vector2, add: f32) -> Vector2;
#foreign Vector2Subtract :: fn(v1: Vector2, v2: Vector2) -> Vector2;
#foreign Vector2SubtractValue :: fn(v: Vector2, sub: f32) -> Vector2;
#foreign Vector2Length :: fn(v: Vector2) -> f32;
#foreign Vector2LengthSqr :: fn(v: Vector2) -> f32;
#foreign Vector2DotProduct :: fn(v1: Vector2, v2: Vector2) -> f32;
#foreign Vector2CrossProduct :: fn(v1: Vector2, v2: Vector2) -> f32;
#foreign Vector2Distance :: fn(v1: Vector2, v2: Vector2) -> f32;
#foreign Vector2DistanceSqr :: fn(v1: Vector2, v2: Vector2) -> f32;
#foreign Vector2Angle :: fn(v1: Vector2, v2: Vector2) -> f32;
#foreign Vector2LineAngle :: fn(start: Vector2, end: Vector2) -> f32;
#foreign Vector2Scale :: fn(v: Vector2, scale: f32) -> Vector2;
#foreign Vector2Multiply :: fn(v1: Vector2, v2: Vector2) -> Vector2;
#foreign Vector2Negate :: fn(v: Vector2) -> Vector2;
#foreign Vector2Divide :: fn(v1: Vector2, v2: Vector2) -> Vector2;
#foreign Vector2Normalize :: fn(v: Vector2) -> Vector2;
#foreign Vector2Transform :: fn(v: Vector2, mat: Matrix) -> Vector2;
#foreign Vector2Lerp :: fn(v1: Vector2, v2: Vector2, amount: f32) -> Vector2;
#foreign Vector2Reflect :: fn(v: Vector2, normal: Vector2) -> Vector2;
#foreign Vector2Min :: fn(v1: Vector2, v2: Vector2) -> Vector2;
#foreign Vector2Max :: fn(v1: Vector2, v2: Vector2) -> Vector2;
#foreign Vector2Rotate :: fn(v: Vector2, angle: f32) -> Vector2;
#foreign Vector2MoveTowards :: fn(v: Vector2, target: Vector2, maxDistance: f32) -> Vector2;
#foreign Vector2Invert :: fn(v: Vector2) -> Vector2;
#foreign Vector2Clamp :: fn(v: Vector2, min: Vector2, max: Vector2) -> Vector2;
#foreign Vector2ClampValue :: fn(v: Vector2, min: f32, max: f32) -> Vector2;
#foreign Vector2Equals :: fn(p: Vector2, q: Vector2) -> s32;
#foreign Vector2Refract :: fn(v: Vector2, n: Vector2, r: f32) -> Vector2;
#foreign Vector3Zero :: fn() -> Vector3;
#foreign Vector3One :: fn() -> Vector3;
#foreign Vector3Add :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3AddValue :: fn(v: Vector3, add: f32) -> Vector3;
#foreign Vector3Subtract :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3SubtractValue :: fn(v: Vector3, sub: f32) -> Vector3;
#foreign Vector3Scale :: fn(v: Vector3, scalar: f32) -> Vector3;
#foreign Vector3Multiply :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3CrossProduct :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3Perpendicular :: fn(v: Vector3) -> Vector3;
#foreign Vector3Length :: fn(v: Vector3) -> f32;
#foreign Vector3LengthSqr :: fn(v: Vector3) -> f32;
#foreign Vector3DotProduct :: fn(v1: Vector3, v2: Vector3) -> f32;
#foreign Vector3Distance :: fn(v1: Vector3, v2: Vector3) -> f32;
#foreign Vector3DistanceSqr :: fn(v1: Vector3, v2: Vector3) -> f32;
#foreign Vector3Angle :: fn(v1: Vector3, v2: Vector3) -> f32;
#foreign Vector3Negate :: fn(v: Vector3) -> Vector3;
#foreign Vector3Divide :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3Normalize :: fn(v: Vector3) -> Vector3;
#foreign Vector3Project :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3Reject :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3OrthoNormalize :: fn(v1: *mut Vector3, v2: *mut Vector3) -> void;
#foreign Vector3Transform :: fn(v: Vector3, mat: Matrix) -> Vector3;
#foreign Vector3RotateByQuaternion :: fn(v: Vector3, q: Quaternion) -> Vector3;
#foreign Vector3RotateByAxisAngle :: fn(v: Vector3, axis: Vector3, angle: f32) -> Vector3;
#foreign Vector3MoveTowards :: fn(v: Vector3, target: Vector3, maxDistance: f32) -> Vector3;
#foreign Vector3Lerp :: fn(v1: Vector3, v2: Vector3, amount: f32) -> Vector3;
#foreign Vector3CubicHermite :: fn(v1: Vector3, tangent1: Vector3, v2: Vector3, tangent2: Vector3, amount: f32) -> Vector3;
#foreign Vector3Reflect :: fn(v: Vector3, normal: Vector3) -> Vector3;
#foreign Vector3Min :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3Max :: fn(v1: Vector3, v2: Vector3) -> Vector3;
#foreign Vector3Barycenter :: fn(p: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Vector3;
#foreign Vector3Unproject :: fn(source: Vector3, projection: Matrix, view: Matrix) -> Vector3;
#foreign Vector3ToFloatV :: fn(v: Vector3) -> float3;
#foreign Vector3Invert :: fn(v: Vector3) -> Vector3;
#foreign Vector3Clamp :: fn(v: Vector3, min: Vector3, max: Vector3) -> Vector3;
#foreign Vector3ClampValue :: fn(v: Vector3, min: f32, max: f32) -> Vector3;
#foreign Vector3Equals :: fn(p: Vector3, q: Vector3) -> s32;
#foreign Vector3Refract :: fn(v: Vector3, n: Vector3, r: f32) -> Vector3;
#foreign Vector4Zero :: fn() -> Vector4;
#foreign Vector4One :: fn() -> Vector4;
#foreign Vector4Add :: fn(v1: Vector4, v2: Vector4) -> Vector4;
#foreign Vector4AddValue :: fn(v: Vector4, add: f32) -> Vector4;
#foreign Vector4Subtract :: fn(v1: Vector4, v2: Vector4) -> Vector4;
#foreign Vector4SubtractValue :: fn(v: Vector4, add: f32) -> Vector4;
#foreign Vector4Length :: fn(v: Vector4) -> f32;
#foreign Vector4LengthSqr :: fn(v: Vector4) -> f32;
#foreign Vector4DotProduct :: fn(v1: Vector4, v2: Vector4) -> f32;
#foreign Vector4Distance :: fn(v1: Vector4, v2: Vector4) -> f32;
#foreign Vector4DistanceSqr :: fn(v1: Vector4, v2: Vector4) -> f32;
#foreign Vector4Scale :: fn(v: Vector4, scale: f32) -> Vector4;
#foreign Vector4Multiply :: fn(v1: Vector4, v2: Vector4) -> Vector4;
#foreign Vector4Negate :: fn(v: Vector4) -> Vector4;
#foreign Vector4Divide :: fn(v1: Vector4, v2: Vector4) -> Vector4;
#foreign Vector4Normalize :: fn(v: Vector4) -> Vector4;
#foreign Vector4Min :: fn(v1: Vector4, v2: Vector4) -> Vector4;
#foreign Vector4Max :: fn(v1: Vector4, v2: Vector4) -> Vector4;
#foreign Vector4Lerp :: fn(v1: Vector4, v2: Vector4, amount: f32) -> Vector4;
#foreign Vector4MoveTowards :: fn(v: Vector4, target: Vector4, maxDistance: f32) -> Vector4;
#foreign Vector4Invert :: fn(v: Vector4) -> Vector4;
#foreign Vector4Equals :: fn(p: Vector4, q: Vector4) -> s32;
#foreign MatrixDeterminant :: fn(mat: Matrix) -> f32;
#foreign MatrixTrace :: fn(mat: Matrix) -> f32;
#foreign MatrixTranspose :: fn(mat: Matrix) -> Matrix;
#foreign MatrixInvert :: fn(mat: Matrix) -> Matrix;
#foreign MatrixIdentity :: fn() -> Matrix;
#foreign MatrixAdd :: fn(left: Matrix, right: Matrix) -> Matrix;
#foreign MatrixSubtract :: fn(left: Matrix, right: Matrix) -> Matrix;
#foreign MatrixMultiply :: fn(left: Matrix, right: Matrix) -> Matrix;
#foreign MatrixTranslate :: fn(x: f32, y: f32, z: f32) -> Matrix;
#foreign MatrixRotate :: fn(axis: Vector3, angle: f32) -> Matrix;
#foreign MatrixRotateX :: fn(angle: f32) -> Matrix;
#foreign MatrixRotateY :: fn(angle: f32) -> Matrix;
#foreign MatrixRotateZ :: fn(angle: f32) -> Matrix;
#foreign MatrixRotateXYZ :: fn(angle: Vector3) -> Matrix;
#foreign MatrixRotateZYX :: fn(angle: Vector3) -> Matrix;
#foreign MatrixScale :: fn(x: f32, y: f32, z: f32) -> Matrix;
#foreign MatrixFrustum :: fn(left: f64, right: f64, bottom: f64, top: f64, nearPlane: f64, farPlane: f64) -> Matrix;
#foreign MatrixPerspective :: fn(fovY: f64, aspect: f64, nearPlane: f64, farPlane: f64) -> Matrix;
#foreign MatrixOrtho :: fn(left: f64, right: f64, bottom: f64, top: f64, nearPlane: f64, farPlane: f64) -> Matrix;
#foreign MatrixLookAt :: fn(eye: Vector3, target: Vector3, up: Vector3) -> Matrix;
#foreign MatrixToFloatV :: fn(mat: Matrix) -> float16;
#foreign QuaternionAdd :: fn(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign QuaternionAddValue :: fn(q: Quaternion, add: f32) -> Quaternion;
#foreign QuaternionSubtract :: fn(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign QuaternionSubtractValue :: fn(q: Quaternion, sub: f32) -> Quaternion;
#foreign QuaternionIdentity :: fn() -> Quaternion;
#foreign QuaternionLength :: fn(q: Quaternion) -> f32;
#foreign QuaternionNormalize :: fn(q: Quaternion) -> Quaternion;
#foreign QuaternionInvert :: fn(q: Quaternion) -> Quaternion;
#foreign QuaternionMultiply :: fn(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign QuaternionScale :: fn(q: Quaternion, mul: f32) -> Quaternion;
#foreign QuaternionDivide :: fn(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign QuaternionLerp :: fn(q1: Quaternion, q2: Quaternion, amount: f32) -> Quaternion;
#foreign QuaternionNlerp :: fn(q1: Quaternion, q2: Quaternion, amount: f32) -> Quaternion;
#foreign QuaternionSlerp :: fn(q1: Quaternion, q2: Quaternion, amount: f32) -> Quaternion;
#foreign QuaternionCubicHermiteSpline :: fn(q1: Quaternion, outTangent1: Quaternion, q2: Quaternion, inTangent2: Quaternion, t: f32) -> Quaternion;
#foreign QuaternionFromVector3ToVector3 :: fn(from: Vector3, to: Vector3) -> Quaternion;
#foreign QuaternionFromMatrix :: fn(mat: Matrix) -> Quaternion;
#foreign QuaternionToMatrix :: fn(q: Quaternion) -> Matrix;
#foreign QuaternionFromAxisAngle :: fn(axis: Vector3, angle: f32) -> Quaternion;
#foreign QuaternionToAxisAngle :: fn(q: Quaternion, outAxis: *mut Vector3, outAngle: *mut f32) -> void;
#foreign QuaternionFromEuler :: fn(pitch: f32, yaw: f32, roll: f32) -> Quaternion;
#foreign QuaternionToEuler :: fn(q: Quaternion) -> Vector3;
#foreign QuaternionTransform :: fn(q: Quaternion, mat: Matrix) -> Quaternion;
#foreign QuaternionEquals :: fn(p: Quaternion, q: Quaternion) -> s32;
#foreign MatrixDecompose :: fn(mat: Matrix, translation: *mut Vector3, rotation: *mut Quaternion, scale: *mut Vector3) -> void;
