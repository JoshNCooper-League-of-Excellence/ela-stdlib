/*
  These bindings were auto generated by 'ela-bindings-generator', from 'raymath.c' at 2025-03-11 12:53:54. 
*/
struct Vector2 {
  x: f32,
  y: f32,
};
struct Vector3 {
  x: f32,
  y: f32,
  z: f32,
};
struct Vector4 {
  x: f32,
  y: f32,
  z: f32,
  w: f32,
};
alias Quaternion :: Vector4;
struct Matrix {
  m0: f32,
  m4: f32,
  m8: f32,
  m12: f32,
  m1: f32,
  m5: f32,
  m9: f32,
  m13: f32,
  m2: f32,
  m6: f32,
  m10: f32,
  m14: f32,
  m3: f32,
  m7: f32,
  m11: f32,
  m15: f32,
};
struct float3 {
  v: f32[3],
};
struct float16 {
  v: f32[16],
};
#foreign fn acos(__x: f64) -> f64;
#foreign fn asin(__x: f64) -> f64;
#foreign fn atan(__x: f64) -> f64;
#foreign fn atan2(__y: f64, __x: f64) -> f64;
#foreign fn cos(__x: f64) -> f64;
#foreign fn sin(__x: f64) -> f64;
#foreign fn tan(__x: f64) -> f64;
#foreign fn cosh(__x: f64) -> f64;
#foreign fn sinh(__x: f64) -> f64;
#foreign fn tanh(__x: f64) -> f64;
#foreign fn acosh(__x: f64) -> f64;
#foreign fn asinh(__x: f64) -> f64;
#foreign fn atanh(__x: f64) -> f64;
#foreign fn exp(__x: f64) -> f64;
#foreign fn frexp(__x: f64, __exponent: *mut s32) -> f64;
#foreign fn ldexp(__x: f64, __exponent: s32) -> f64;
#foreign fn log(__x: f64) -> f64;
#foreign fn log10(__x: f64) -> f64;
#foreign fn modf(__x: f64, __iptr: *mut f64) -> f64;
#foreign fn expm1(__x: f64) -> f64;
#foreign fn log1p(__x: f64) -> f64;
#foreign fn logb(__x: f64) -> f64;
#foreign fn exp2(__x: f64) -> f64;
#foreign fn log2(__x: f64) -> f64;
#foreign fn pow(__x: f64, __y: f64) -> f64;
#foreign fn sqrt(__x: f64) -> f64;
#foreign fn hypot(__x: f64, __y: f64) -> f64;
#foreign fn cbrt(__x: f64) -> f64;
#foreign fn ceil(__x: f64) -> f64;
#foreign fn fabs(__x: f64) -> f64;
#foreign fn floor(__x: f64) -> f64;
#foreign fn fmod(__x: f64, __y: f64) -> f64;
#foreign fn isinf(__value: f64) -> s32;
#foreign fn finite(__value: f64) -> s32;
#foreign fn drem(__x: f64, __y: f64) -> f64;
#foreign fn significand(__x: f64) -> f64;
#foreign fn copysign(__x: f64, __y: f64) -> f64;
#foreign fn nan(__tagb: *const u8) -> f64;
#foreign fn isnan(__value: f64) -> s32;
#foreign fn j0(param0: f64) -> f64;
#foreign fn j1(param0: f64) -> f64;
#foreign fn jn(param0: s32, param1: f64) -> f64;
#foreign fn y0(param0: f64) -> f64;
#foreign fn y1(param0: f64) -> f64;
#foreign fn yn(param0: s32, param1: f64) -> f64;
#foreign fn erf(param0: f64) -> f64;
#foreign fn erfc(param0: f64) -> f64;
#foreign fn lgamma(param0: f64) -> f64;
#foreign fn tgamma(param0: f64) -> f64;
#foreign fn gamma(param0: f64) -> f64;
#foreign fn lgamma_r(param0: f64, __signgamp: *mut s32) -> f64;
#foreign fn rint(__x: f64) -> f64;
#foreign fn nextafter(__x: f64, __y: f64) -> f64;
#foreign fn nexttoward(__x: f64, __y: f64) -> f64;
#foreign fn remainder(__x: f64, __y: f64) -> f64;
#foreign fn scalbn(__x: f64, __n: s32) -> f64;
#foreign fn ilogb(__x: f64) -> s32;
#foreign fn scalbln(__x: f64, __n: s64) -> f64;
#foreign fn nearbyint(__x: f64) -> f64;
#foreign fn round(__x: f64) -> f64;
#foreign fn trunc(__x: f64) -> f64;
#foreign fn remquo(__x: f64, __y: f64, __quo: *mut s32) -> f64;
#foreign fn lrint(__x: f64) -> s64;
#foreign fn llrint(__x: f64) -> s64;
#foreign fn lround(__x: f64) -> s64;
#foreign fn llround(__x: f64) -> s64;
#foreign fn fdim(__x: f64, __y: f64) -> f64;
#foreign fn fmax(__x: f64, __y: f64) -> f64;
#foreign fn fmin(__x: f64, __y: f64) -> f64;
#foreign fn fma(__x: f64, __y: f64, __z: f64) -> f64;
#foreign fn scalb(__x: f64, __n: f64) -> f64;
#foreign fn acosf(__x: f32) -> f32;
#foreign fn asinf(__x: f32) -> f32;
#foreign fn atanf(__x: f32) -> f32;
#foreign fn atan2f(__y: f32, __x: f32) -> f32;
#foreign fn cosf(__x: f32) -> f32;
#foreign fn sinf(__x: f32) -> f32;
#foreign fn tanf(__x: f32) -> f32;
#foreign fn coshf(__x: f32) -> f32;
#foreign fn sinhf(__x: f32) -> f32;
#foreign fn tanhf(__x: f32) -> f32;
#foreign fn acoshf(__x: f32) -> f32;
#foreign fn asinhf(__x: f32) -> f32;
#foreign fn atanhf(__x: f32) -> f32;
#foreign fn expf(__x: f32) -> f32;
#foreign fn frexpf(__x: f32, __exponent: *mut s32) -> f32;
#foreign fn ldexpf(__x: f32, __exponent: s32) -> f32;
#foreign fn logf(__x: f32) -> f32;
#foreign fn log10f(__x: f32) -> f32;
#foreign fn modff(__x: f32, __iptr: *mut f32) -> f32;
#foreign fn expm1f(__x: f32) -> f32;
#foreign fn log1pf(__x: f32) -> f32;
#foreign fn logbf(__x: f32) -> f32;
#foreign fn exp2f(__x: f32) -> f32;
#foreign fn log2f(__x: f32) -> f32;
#foreign fn powf(__x: f32, __y: f32) -> f32;
#foreign fn sqrtf(__x: f32) -> f32;
#foreign fn hypotf(__x: f32, __y: f32) -> f32;
#foreign fn cbrtf(__x: f32) -> f32;
#foreign fn ceilf(__x: f32) -> f32;
#foreign fn fabsf(__x: f32) -> f32;
#foreign fn floorf(__x: f32) -> f32;
#foreign fn fmodf(__x: f32, __y: f32) -> f32;
#foreign fn isinff(__value: f32) -> s32;
#foreign fn finitef(__value: f32) -> s32;
#foreign fn dremf(__x: f32, __y: f32) -> f32;
#foreign fn significandf(__x: f32) -> f32;
#foreign fn copysignf(__x: f32, __y: f32) -> f32;
#foreign fn nanf(__tagb: *const u8) -> f32;
#foreign fn isnanf(__value: f32) -> s32;
#foreign fn j0f(param0: f32) -> f32;
#foreign fn j1f(param0: f32) -> f32;
#foreign fn jnf(param0: s32, param1: f32) -> f32;
#foreign fn y0f(param0: f32) -> f32;
#foreign fn y1f(param0: f32) -> f32;
#foreign fn ynf(param0: s32, param1: f32) -> f32;
#foreign fn erff(param0: f32) -> f32;
#foreign fn erfcf(param0: f32) -> f32;
#foreign fn lgammaf(param0: f32) -> f32;
#foreign fn tgammaf(param0: f32) -> f32;
#foreign fn gammaf(param0: f32) -> f32;
#foreign fn lgammaf_r(param0: f32, __signgamp: *mut s32) -> f32;
#foreign fn rintf(__x: f32) -> f32;
#foreign fn nextafterf(__x: f32, __y: f32) -> f32;
#foreign fn nexttowardf(__x: f32, __y: f64) -> f32;
#foreign fn remainderf(__x: f32, __y: f32) -> f32;
#foreign fn scalbnf(__x: f32, __n: s32) -> f32;
#foreign fn ilogbf(__x: f32) -> s32;
#foreign fn scalblnf(__x: f32, __n: s64) -> f32;
#foreign fn nearbyintf(__x: f32) -> f32;
#foreign fn roundf(__x: f32) -> f32;
#foreign fn truncf(__x: f32) -> f32;
#foreign fn remquof(__x: f32, __y: f32, __quo: *mut s32) -> f32;
#foreign fn lrintf(__x: f32) -> s64;
#foreign fn llrintf(__x: f32) -> s64;
#foreign fn lroundf(__x: f32) -> s64;
#foreign fn llroundf(__x: f32) -> s64;
#foreign fn fdimf(__x: f32, __y: f32) -> f32;
#foreign fn fmaxf(__x: f32, __y: f32) -> f32;
#foreign fn fminf(__x: f32, __y: f32) -> f32;
#foreign fn fmaf(__x: f32, __y: f32, __z: f32) -> f32;
#foreign fn scalbf(__x: f32, __n: f32) -> f32;
#foreign fn acosl(__x: f64) -> f64;
#foreign fn asinl(__x: f64) -> f64;
#foreign fn atanl(__x: f64) -> f64;
#foreign fn atan2l(__y: f64, __x: f64) -> f64;
#foreign fn cosl(__x: f64) -> f64;
#foreign fn sinl(__x: f64) -> f64;
#foreign fn tanl(__x: f64) -> f64;
#foreign fn coshl(__x: f64) -> f64;
#foreign fn sinhl(__x: f64) -> f64;
#foreign fn tanhl(__x: f64) -> f64;
#foreign fn acoshl(__x: f64) -> f64;
#foreign fn asinhl(__x: f64) -> f64;
#foreign fn atanhl(__x: f64) -> f64;
#foreign fn expl(__x: f64) -> f64;
#foreign fn frexpl(__x: f64, __exponent: *mut s32) -> f64;
#foreign fn ldexpl(__x: f64, __exponent: s32) -> f64;
#foreign fn logl(__x: f64) -> f64;
#foreign fn log10l(__x: f64) -> f64;
#foreign fn modfl(__x: f64, __iptr: *mut f64) -> f64;
#foreign fn expm1l(__x: f64) -> f64;
#foreign fn log1pl(__x: f64) -> f64;
#foreign fn logbl(__x: f64) -> f64;
#foreign fn exp2l(__x: f64) -> f64;
#foreign fn log2l(__x: f64) -> f64;
#foreign fn powl(__x: f64, __y: f64) -> f64;
#foreign fn sqrtl(__x: f64) -> f64;
#foreign fn hypotl(__x: f64, __y: f64) -> f64;
#foreign fn cbrtl(__x: f64) -> f64;
#foreign fn ceill(__x: f64) -> f64;
#foreign fn fabsl(__x: f64) -> f64;
#foreign fn floorl(__x: f64) -> f64;
#foreign fn fmodl(__x: f64, __y: f64) -> f64;
#foreign fn isinfl(__value: f64) -> s32;
#foreign fn finitel(__value: f64) -> s32;
#foreign fn dreml(__x: f64, __y: f64) -> f64;
#foreign fn significandl(__x: f64) -> f64;
#foreign fn copysignl(__x: f64, __y: f64) -> f64;
#foreign fn nanl(__tagb: *const u8) -> f64;
#foreign fn isnanl(__value: f64) -> s32;
#foreign fn j0l(param0: f64) -> f64;
#foreign fn j1l(param0: f64) -> f64;
#foreign fn jnl(param0: s32, param1: f64) -> f64;
#foreign fn y0l(param0: f64) -> f64;
#foreign fn y1l(param0: f64) -> f64;
#foreign fn ynl(param0: s32, param1: f64) -> f64;
#foreign fn erfl(param0: f64) -> f64;
#foreign fn erfcl(param0: f64) -> f64;
#foreign fn lgammal(param0: f64) -> f64;
#foreign fn tgammal(param0: f64) -> f64;
#foreign fn gammal(param0: f64) -> f64;
#foreign fn lgammal_r(param0: f64, __signgamp: *mut s32) -> f64;
#foreign fn rintl(__x: f64) -> f64;
#foreign fn nextafterl(__x: f64, __y: f64) -> f64;
#foreign fn nexttowardl(__x: f64, __y: f64) -> f64;
#foreign fn remainderl(__x: f64, __y: f64) -> f64;
#foreign fn scalbnl(__x: f64, __n: s32) -> f64;
#foreign fn ilogbl(__x: f64) -> s32;
#foreign fn scalblnl(__x: f64, __n: s64) -> f64;
#foreign fn nearbyintl(__x: f64) -> f64;
#foreign fn roundl(__x: f64) -> f64;
#foreign fn truncl(__x: f64) -> f64;
#foreign fn remquol(__x: f64, __y: f64, __quo: *mut s32) -> f64;
#foreign fn lrintl(__x: f64) -> s64;
#foreign fn llrintl(__x: f64) -> s64;
#foreign fn lroundl(__x: f64) -> s64;
#foreign fn llroundl(__x: f64) -> s64;
#foreign fn fdiml(__x: f64, __y: f64) -> f64;
#foreign fn fmaxl(__x: f64, __y: f64) -> f64;
#foreign fn fminl(__x: f64, __y: f64) -> f64;
#foreign fn fmal(__x: f64, __y: f64, __z: f64) -> f64;
#foreign fn scalbl(__x: f64, __n: f64) -> f64;
#foreign fn Clamp(value: f32, min: f32, max: f32) -> f32;
#foreign fn Lerp(start: f32, end: f32, amount: f32) -> f32;
#foreign fn Normalize(value: f32, start: f32, end: f32) -> f32;
#foreign fn Remap(value: f32, inputStart: f32, inputEnd: f32, outputStart: f32, outputEnd: f32) -> f32;
#foreign fn Wrap(value: f32, min: f32, max: f32) -> f32;
#foreign fn FloatEquals(x: f32, y: f32) -> s32;
#foreign fn Vector2Zero() -> Vector2;
#foreign fn Vector2One() -> Vector2;
#foreign fn Vector2Add(v1: Vector2, v2: Vector2) -> Vector2;
#foreign fn Vector2AddValue(v: Vector2, add: f32) -> Vector2;
#foreign fn Vector2Subtract(v1: Vector2, v2: Vector2) -> Vector2;
#foreign fn Vector2SubtractValue(v: Vector2, sub: f32) -> Vector2;
#foreign fn Vector2Length(v: Vector2) -> f32;
#foreign fn Vector2LengthSqr(v: Vector2) -> f32;
#foreign fn Vector2DotProduct(v1: Vector2, v2: Vector2) -> f32;
#foreign fn Vector2CrossProduct(v1: Vector2, v2: Vector2) -> f32;
#foreign fn Vector2Distance(v1: Vector2, v2: Vector2) -> f32;
#foreign fn Vector2DistanceSqr(v1: Vector2, v2: Vector2) -> f32;
#foreign fn Vector2Angle(v1: Vector2, v2: Vector2) -> f32;
#foreign fn Vector2LineAngle(start: Vector2, end: Vector2) -> f32;
#foreign fn Vector2Scale(v: Vector2, scale: f32) -> Vector2;
#foreign fn Vector2Multiply(v1: Vector2, v2: Vector2) -> Vector2;
#foreign fn Vector2Negate(v: Vector2) -> Vector2;
#foreign fn Vector2Divide(v1: Vector2, v2: Vector2) -> Vector2;
#foreign fn Vector2Normalize(v: Vector2) -> Vector2;
#foreign fn Vector2Transform(v: Vector2, mat: Matrix) -> Vector2;
#foreign fn Vector2Lerp(v1: Vector2, v2: Vector2, amount: f32) -> Vector2;
#foreign fn Vector2Reflect(v: Vector2, normal: Vector2) -> Vector2;
#foreign fn Vector2Min(v1: Vector2, v2: Vector2) -> Vector2;
#foreign fn Vector2Max(v1: Vector2, v2: Vector2) -> Vector2;
#foreign fn Vector2Rotate(v: Vector2, angle: f32) -> Vector2;
#foreign fn Vector2MoveTowards(v: Vector2, target: Vector2, maxDistance: f32) -> Vector2;
#foreign fn Vector2Invert(v: Vector2) -> Vector2;
#foreign fn Vector2Clamp(v: Vector2, min: Vector2, max: Vector2) -> Vector2;
#foreign fn Vector2ClampValue(v: Vector2, min: f32, max: f32) -> Vector2;
#foreign fn Vector2Equals(p: Vector2, q: Vector2) -> s32;
#foreign fn Vector2Refract(v: Vector2, n: Vector2, r: f32) -> Vector2;
#foreign fn Vector3Zero() -> Vector3;
#foreign fn Vector3One() -> Vector3;
#foreign fn Vector3Add(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3AddValue(v: Vector3, add: f32) -> Vector3;
#foreign fn Vector3Subtract(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3SubtractValue(v: Vector3, sub: f32) -> Vector3;
#foreign fn Vector3Scale(v: Vector3, scalar: f32) -> Vector3;
#foreign fn Vector3Multiply(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3CrossProduct(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3Perpendicular(v: Vector3) -> Vector3;
#foreign fn Vector3Length(v: Vector3) -> f32;
#foreign fn Vector3LengthSqr(v: Vector3) -> f32;
#foreign fn Vector3DotProduct(v1: Vector3, v2: Vector3) -> f32;
#foreign fn Vector3Distance(v1: Vector3, v2: Vector3) -> f32;
#foreign fn Vector3DistanceSqr(v1: Vector3, v2: Vector3) -> f32;
#foreign fn Vector3Angle(v1: Vector3, v2: Vector3) -> f32;
#foreign fn Vector3Negate(v: Vector3) -> Vector3;
#foreign fn Vector3Divide(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3Normalize(v: Vector3) -> Vector3;
#foreign fn Vector3Project(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3Reject(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3OrthoNormalize(v1: *mut Vector3, v2: *mut Vector3) -> void;
#foreign fn Vector3Transform(v: Vector3, mat: Matrix) -> Vector3;
#foreign fn Vector3RotateByQuaternion(v: Vector3, q: Quaternion) -> Vector3;
#foreign fn Vector3RotateByAxisAngle(v: Vector3, axis: Vector3, angle: f32) -> Vector3;
#foreign fn Vector3MoveTowards(v: Vector3, target: Vector3, maxDistance: f32) -> Vector3;
#foreign fn Vector3Lerp(v1: Vector3, v2: Vector3, amount: f32) -> Vector3;
#foreign fn Vector3CubicHermite(v1: Vector3, tangent1: Vector3, v2: Vector3, tangent2: Vector3, amount: f32) -> Vector3;
#foreign fn Vector3Reflect(v: Vector3, normal: Vector3) -> Vector3;
#foreign fn Vector3Min(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3Max(v1: Vector3, v2: Vector3) -> Vector3;
#foreign fn Vector3Barycenter(p: Vector3, a: Vector3, b: Vector3, c: Vector3) -> Vector3;
#foreign fn Vector3Unproject(source: Vector3, projection: Matrix, view: Matrix) -> Vector3;
#foreign fn Vector3ToFloatV(v: Vector3) -> float3;
#foreign fn Vector3Invert(v: Vector3) -> Vector3;
#foreign fn Vector3Clamp(v: Vector3, min: Vector3, max: Vector3) -> Vector3;
#foreign fn Vector3ClampValue(v: Vector3, min: f32, max: f32) -> Vector3;
#foreign fn Vector3Equals(p: Vector3, q: Vector3) -> s32;
#foreign fn Vector3Refract(v: Vector3, n: Vector3, r: f32) -> Vector3;
#foreign fn Vector4Zero() -> Vector4;
#foreign fn Vector4One() -> Vector4;
#foreign fn Vector4Add(v1: Vector4, v2: Vector4) -> Vector4;
#foreign fn Vector4AddValue(v: Vector4, add: f32) -> Vector4;
#foreign fn Vector4Subtract(v1: Vector4, v2: Vector4) -> Vector4;
#foreign fn Vector4SubtractValue(v: Vector4, add: f32) -> Vector4;
#foreign fn Vector4Length(v: Vector4) -> f32;
#foreign fn Vector4LengthSqr(v: Vector4) -> f32;
#foreign fn Vector4DotProduct(v1: Vector4, v2: Vector4) -> f32;
#foreign fn Vector4Distance(v1: Vector4, v2: Vector4) -> f32;
#foreign fn Vector4DistanceSqr(v1: Vector4, v2: Vector4) -> f32;
#foreign fn Vector4Scale(v: Vector4, scale: f32) -> Vector4;
#foreign fn Vector4Multiply(v1: Vector4, v2: Vector4) -> Vector4;
#foreign fn Vector4Negate(v: Vector4) -> Vector4;
#foreign fn Vector4Divide(v1: Vector4, v2: Vector4) -> Vector4;
#foreign fn Vector4Normalize(v: Vector4) -> Vector4;
#foreign fn Vector4Min(v1: Vector4, v2: Vector4) -> Vector4;
#foreign fn Vector4Max(v1: Vector4, v2: Vector4) -> Vector4;
#foreign fn Vector4Lerp(v1: Vector4, v2: Vector4, amount: f32) -> Vector4;
#foreign fn Vector4MoveTowards(v: Vector4, target: Vector4, maxDistance: f32) -> Vector4;
#foreign fn Vector4Invert(v: Vector4) -> Vector4;
#foreign fn Vector4Equals(p: Vector4, q: Vector4) -> s32;
#foreign fn MatrixDeterminant(mat: Matrix) -> f32;
#foreign fn MatrixTrace(mat: Matrix) -> f32;
#foreign fn MatrixTranspose(mat: Matrix) -> Matrix;
#foreign fn MatrixInvert(mat: Matrix) -> Matrix;
#foreign fn MatrixIdentity() -> Matrix;
#foreign fn MatrixAdd(left: Matrix, right: Matrix) -> Matrix;
#foreign fn MatrixSubtract(left: Matrix, right: Matrix) -> Matrix;
#foreign fn MatrixMultiply(left: Matrix, right: Matrix) -> Matrix;
#foreign fn MatrixTranslate(x: f32, y: f32, z: f32) -> Matrix;
#foreign fn MatrixRotate(axis: Vector3, angle: f32) -> Matrix;
#foreign fn MatrixRotateX(angle: f32) -> Matrix;
#foreign fn MatrixRotateY(angle: f32) -> Matrix;
#foreign fn MatrixRotateZ(angle: f32) -> Matrix;
#foreign fn MatrixRotateXYZ(angle: Vector3) -> Matrix;
#foreign fn MatrixRotateZYX(angle: Vector3) -> Matrix;
#foreign fn MatrixScale(x: f32, y: f32, z: f32) -> Matrix;
#foreign fn MatrixFrustum(left: f64, right: f64, bottom: f64, top: f64, nearPlane: f64, farPlane: f64) -> Matrix;
#foreign fn MatrixPerspective(fovY: f64, aspect: f64, nearPlane: f64, farPlane: f64) -> Matrix;
#foreign fn MatrixOrtho(left: f64, right: f64, bottom: f64, top: f64, nearPlane: f64, farPlane: f64) -> Matrix;
#foreign fn MatrixLookAt(eye: Vector3, target: Vector3, up: Vector3) -> Matrix;
#foreign fn MatrixToFloatV(mat: Matrix) -> float16;
#foreign fn QuaternionAdd(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign fn QuaternionAddValue(q: Quaternion, add: f32) -> Quaternion;
#foreign fn QuaternionSubtract(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign fn QuaternionSubtractValue(q: Quaternion, sub: f32) -> Quaternion;
#foreign fn QuaternionIdentity() -> Quaternion;
#foreign fn QuaternionLength(q: Quaternion) -> f32;
#foreign fn QuaternionNormalize(q: Quaternion) -> Quaternion;
#foreign fn QuaternionInvert(q: Quaternion) -> Quaternion;
#foreign fn QuaternionMultiply(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign fn QuaternionScale(q: Quaternion, mul: f32) -> Quaternion;
#foreign fn QuaternionDivide(q1: Quaternion, q2: Quaternion) -> Quaternion;
#foreign fn QuaternionLerp(q1: Quaternion, q2: Quaternion, amount: f32) -> Quaternion;
#foreign fn QuaternionNlerp(q1: Quaternion, q2: Quaternion, amount: f32) -> Quaternion;
#foreign fn QuaternionSlerp(q1: Quaternion, q2: Quaternion, amount: f32) -> Quaternion;
#foreign fn QuaternionCubicHermiteSpline(q1: Quaternion, outTangent1: Quaternion, q2: Quaternion, inTangent2: Quaternion, t: f32) -> Quaternion;
#foreign fn QuaternionFromVector3ToVector3(from: Vector3, to: Vector3) -> Quaternion;
#foreign fn QuaternionFromMatrix(mat: Matrix) -> Quaternion;
#foreign fn QuaternionToMatrix(q: Quaternion) -> Matrix;
#foreign fn QuaternionFromAxisAngle(axis: Vector3, angle: f32) -> Quaternion;
#foreign fn QuaternionToAxisAngle(q: Quaternion, outAxis: *mut Vector3, outAngle: *mut f32) -> void;
#foreign fn QuaternionFromEuler(pitch: f32, yaw: f32, roll: f32) -> Quaternion;
#foreign fn QuaternionToEuler(q: Quaternion) -> Vector3;
#foreign fn QuaternionTransform(q: Quaternion, mat: Matrix) -> Quaternion;
#foreign fn QuaternionEquals(p: Quaternion, q: Quaternion) -> s32;
#foreign fn MatrixDecompose(mat: Matrix, translation: *mut Vector3, rotation: *mut Quaternion, scale: *mut Vector3) -> void;
