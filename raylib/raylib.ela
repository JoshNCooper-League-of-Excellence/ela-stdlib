/*
  These bindings were auto generated by 'ela-bindings-generator', from '/usr/local/include/raylib.h' at 2025-03-06 11:21:49. 
*/
#include "raymath.ela";

struct Color {
  r: u8,
  g: u8,
  b: u8,
  a: u8,
};

struct Rectangle {
  x: f32,
  y: f32,
  width: f32,
  height: f32,
};

struct Image {
  data: *const void,
  width: s32,
  height: s32,
  mipmaps: s32,
  format: s32,
};
struct Texture {
  id: u32,
  width: s32,
  height: s32,
  mipmaps: s32,
  format: s32,
};
type Texture2D :: Texture;
type TextureCubemap :: Texture;
struct RenderTexture {
  id: u32,
  texture: Texture,
  depth: Texture,
};
type RenderTexture2D :: RenderTexture;
struct NPatchInfo {
  source: Rectangle,
  left: s32,
  top: s32,
  right: s32,
  bottom: s32,
  layout: s32,
};
struct GlyphInfo {
  value: s32,
  offsetX: s32,
  offsetY: s32,
  advanceX: s32,
  image: Image,
};
struct Font {
  baseSize: s32,
  glyphCount: s32,
  glyphPadding: s32,
  texture: Texture2D,
  recs: *const Rectangle,
  glyphs: *const GlyphInfo,
};

struct Camera3D {
  position: Vector3,
  target: Vector3,
  up: Vector3,
  fovy: f32,
  projection: s32,
};

type Camera :: Camera3D;

struct Camera2D {
  offset: Vector2,
  target: Vector2,
  rotation: f32,
  zoom: f32,
};

struct Mesh {
  vertexCount: s32,
  triangleCount: s32,
  vertices: *const f32,
  texcoords: *const f32,
  texcoords2: *const f32,
  normals: *const f32,
  tangents: *const f32,
  colors: *const u8,
  indices: *const u16,
  animVertices: *const f32,
  animNormals: *const f32,
  boneIds: *const u8,
  boneWeights: *const f32,
  boneMatrices: *const Matrix,
  boneCount: s32,
  vaoId: u32,
  vboId: *const u32,
};
struct Shader {
  id: u32,
  locs: *const s32,
};
struct MaterialMap {
  texture: Texture2D,
  color: Color,
  value: f32,
};
struct Material {
  shader: Shader,
  maps: *const MaterialMap,
  params: [f32; 4],
};
struct Transform {
  translation: Vector3,
  rotation: Quaternion,
  scale: Vector3,
};
struct BoneInfo {
  name: [u8; 32],
  parent: s32,
};
struct Model {
  transform: Matrix,
  meshCount: s32,
  materialCount: s32,
  meshes: *const Mesh,
  materials: *const Material,
  meshMaterial: *const s32,
  boneCount: s32,
  bones: *const BoneInfo,
  bindPose: *const Transform,
};
struct ModelAnimation {
  boneCount: s32,
  frameCount: s32,
  bones: *const BoneInfo,
  framePoses: *const *const Transform,
  name: [u8; 32],
};
struct Ray {
  position: Vector3,
  direction: Vector3,
};
struct RayCollision {
  hit: bool,
  distance: f32,
  point: Vector3,
  normal: Vector3,
};
struct BoundingBox {
  min: Vector3,
  max: Vector3,
};
struct Wave {
  frameCount: u32,
  sampleRate: u32,
  sampleSize: u32,
  channels: u32,
  data: *const void,
};
struct rAudioBuffer {
};
struct rAudioProcessor {
};
struct AudioStream {
  buffer: *const rAudioBuffer,
  processor: *const rAudioProcessor,
  sampleRate: u32,
  sampleSize: u32,
  channels: u32,
};
struct Sound {
  stream: AudioStream,
  frameCount: u32,
};
struct Music {
  stream: AudioStream,
  frameCount: u32,
  looping: bool,
  ctxType: s32,
  ctxData: *const void,
};
struct VrDeviceInfo {
  hResolution: s32,
  vResolution: s32,
  hScreenSize: f32,
  vScreenSize: f32,
  eyeToScreenDistance: f32,
  lensSeparationDistance: f32,
  interpupillaryDistance: f32,
  lensDistortionValues: [f32; 4],
  chromaAbCorrection: [f32; 4],
};
struct VrStereoConfig {
  projection: [Matrix; 2],
  viewOffset: [Matrix; 2],
  leftLensCenter: [f32; 2],
  rightLensCenter: [f32; 2],
  leftScreenCenter: [f32; 2],
  rightScreenCenter: [f32; 2],
  scale: [f32; 2],
  scaleIn: [f32; 2],
};
struct FilePathList {
  capacity: u32,
  count: u32,
  paths: *const *const u8,
};
struct AutomationEvent {
  frame: u32,
  _type: u32,
  params: [s32; 4],
};
struct AutomationEventList {
  capacity: u32,
  count: u32,
  events: *const AutomationEvent,
};
enum ConfigFlags {
  FLAG_VSYNC_HINT = 64,
  FLAG_FULLSCREEN_MODE = 2,
  FLAG_WINDOW_RESIZABLE = 4,
  FLAG_WINDOW_UNDECORATED = 8,
  FLAG_WINDOW_HIDDEN = 128,
  FLAG_WINDOW_MINIMIZED = 512,
  FLAG_WINDOW_MAXIMIZED = 1024,
  FLAG_WINDOW_UNFOCUSED = 2048,
  FLAG_WINDOW_TOPMOST = 4096,
  FLAG_WINDOW_ALWAYS_RUN = 256,
  FLAG_WINDOW_TRANSPARENT = 16,
  FLAG_WINDOW_HIGHDPI = 8192,
  FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384,
  FLAG_BORDERLESS_WINDOWED_MODE = 32768,
  FLAG_MSAA_4X_HINT = 32,
  FLAG_INTERLACED_HINT = 65536,
};
enum TraceLogLevel {
  LOG_ALL = 0,
  LOG_TRACE = 1,
  LOG_DEBUG = 2,
  LOG_INFO = 3,
  LOG_WARNING = 4,
  LOG_ERROR = 5,
  LOG_FATAL = 6,
  LOG_NONE = 7,
};
enum KeyboardKey {
  KEY_NULL = 0,
  KEY_APOSTROPHE = 39,
  KEY_COMMA = 44,
  KEY_MINUS = 45,
  KEY_PERIOD = 46,
  KEY_SLASH = 47,
  KEY_ZERO = 48,
  KEY_ONE = 49,
  KEY_TWO = 50,
  KEY_THREE = 51,
  KEY_FOUR = 52,
  KEY_FIVE = 53,
  KEY_SIX = 54,
  KEY_SEVEN = 55,
  KEY_EIGHT = 56,
  KEY_NINE = 57,
  KEY_SEMICOLON = 59,
  KEY_EQUAL = 61,
  KEY_A = 65,
  KEY_B = 66,
  KEY_C = 67,
  KEY_D = 68,
  KEY_E = 69,
  KEY_F = 70,
  KEY_G = 71,
  KEY_H = 72,
  KEY_I = 73,
  KEY_J = 74,
  KEY_K = 75,
  KEY_L = 76,
  KEY_M = 77,
  KEY_N = 78,
  KEY_O = 79,
  KEY_P = 80,
  KEY_Q = 81,
  KEY_R = 82,
  KEY_S = 83,
  KEY_T = 84,
  KEY_U = 85,
  KEY_V = 86,
  KEY_W = 87,
  KEY_X = 88,
  KEY_Y = 89,
  KEY_Z = 90,
  KEY_LEFT_BRACKET = 91,
  KEY_BACKSLASH = 92,
  KEY_RIGHT_BRACKET = 93,
  KEY_GRAVE = 96,
  KEY_SPACE = 32,
  KEY_ESCAPE = 256,
  KEY_ENTER = 257,
  KEY_TAB = 258,
  KEY_BACKSPACE = 259,
  KEY_INSERT = 260,
  KEY_DELETE = 261,
  KEY_RIGHT = 262,
  KEY_LEFT = 263,
  KEY_DOWN = 264,
  KEY_UP = 265,
  KEY_PAGE_UP = 266,
  KEY_PAGE_DOWN = 267,
  KEY_HOME = 268,
  KEY_END = 269,
  KEY_CAPS_LOCK = 280,
  KEY_SCROLL_LOCK = 281,
  KEY_NUM_LOCK = 282,
  KEY_PRINT_SCREEN = 283,
  KEY_PAUSE = 284,
  KEY_F1 = 290,
  KEY_F2 = 291,
  KEY_F3 = 292,
  KEY_F4 = 293,
  KEY_F5 = 294,
  KEY_F6 = 295,
  KEY_F7 = 296,
  KEY_F8 = 297,
  KEY_F9 = 298,
  KEY_F10 = 299,
  KEY_F11 = 300,
  KEY_F12 = 301,
  KEY_LEFT_SHIFT = 340,
  KEY_LEFT_CONTROL = 341,
  KEY_LEFT_ALT = 342,
  KEY_LEFT_SUPER = 343,
  KEY_RIGHT_SHIFT = 344,
  KEY_RIGHT_CONTROL = 345,
  KEY_RIGHT_ALT = 346,
  KEY_RIGHT_SUPER = 347,
  KEY_KB_MENU = 348,
  KEY_KP_0 = 320,
  KEY_KP_1 = 321,
  KEY_KP_2 = 322,
  KEY_KP_3 = 323,
  KEY_KP_4 = 324,
  KEY_KP_5 = 325,
  KEY_KP_6 = 326,
  KEY_KP_7 = 327,
  KEY_KP_8 = 328,
  KEY_KP_9 = 329,
  KEY_KP_DECIMAL = 330,
  KEY_KP_DIVIDE = 331,
  KEY_KP_MULTIPLY = 332,
  KEY_KP_SUBTRACT = 333,
  KEY_KP_ADD = 334,
  KEY_KP_ENTER = 335,
  KEY_KP_EQUAL = 336,
  KEY_BACK = 4,
  KEY_MENU = 5,
  KEY_VOLUME_UP = 24,
  KEY_VOLUME_DOWN = 25,
};
enum MouseButton {
  MOUSE_BUTTON_LEFT = 0,
  MOUSE_BUTTON_RIGHT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
  MOUSE_BUTTON_SIDE = 3,
  MOUSE_BUTTON_EXTRA = 4,
  MOUSE_BUTTON_FORWARD = 5,
  MOUSE_BUTTON_BACK = 6,
};
enum MouseCursor {
  MOUSE_CURSOR_DEFAULT = 0,
  MOUSE_CURSOR_ARROW = 1,
  MOUSE_CURSOR_IBEAM = 2,
  MOUSE_CURSOR_CROSSHAIR = 3,
  MOUSE_CURSOR_POINTING_HAND = 4,
  MOUSE_CURSOR_RESIZE_EW = 5,
  MOUSE_CURSOR_RESIZE_NS = 6,
  MOUSE_CURSOR_RESIZE_NWSE = 7,
  MOUSE_CURSOR_RESIZE_NESW = 8,
  MOUSE_CURSOR_RESIZE_ALL = 9,
  MOUSE_CURSOR_NOT_ALLOWED = 10,
};
enum GamepadButton {
  GAMEPAD_BUTTON_UNKNOWN = 0,
  GAMEPAD_BUTTON_LEFT_FACE_UP = 1,
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2,
  GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3,
  GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4,
  GAMEPAD_BUTTON_RIGHT_FACE_UP = 5,
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6,
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7,
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8,
  GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9,
  GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12,
  GAMEPAD_BUTTON_MIDDLE_LEFT = 13,
  GAMEPAD_BUTTON_MIDDLE = 14,
  GAMEPAD_BUTTON_MIDDLE_RIGHT = 15,
  GAMEPAD_BUTTON_LEFT_THUMB = 16,
  GAMEPAD_BUTTON_RIGHT_THUMB = 17,
};
enum GamepadAxis {
  GAMEPAD_AXIS_LEFT_X = 0,
  GAMEPAD_AXIS_LEFT_Y = 1,
  GAMEPAD_AXIS_RIGHT_X = 2,
  GAMEPAD_AXIS_RIGHT_Y = 3,
  GAMEPAD_AXIS_LEFT_TRIGGER = 4,
  GAMEPAD_AXIS_RIGHT_TRIGGER = 5,
};
enum MaterialMapIndex {
  MATERIAL_MAP_ALBEDO = 0,
  MATERIAL_MAP_METALNESS = 1,
  MATERIAL_MAP_NORMAL = 2,
  MATERIAL_MAP_ROUGHNESS = 3,
  MATERIAL_MAP_OCCLUSION = 4,
  MATERIAL_MAP_EMISSION = 5,
  MATERIAL_MAP_HEIGHT = 6,
  MATERIAL_MAP_CUBEMAP = 7,
  MATERIAL_MAP_IRRADIANCE = 8,
  MATERIAL_MAP_PREFILTER = 9,
  MATERIAL_MAP_BRDF = 10,
};
enum ShaderLocationIndex {
  SHADER_LOC_VERTEX_POSITION = 0,
  SHADER_LOC_VERTEX_TEXCOORD01 = 1,
  SHADER_LOC_VERTEX_TEXCOORD02 = 2,
  SHADER_LOC_VERTEX_NORMAL = 3,
  SHADER_LOC_VERTEX_TANGENT = 4,
  SHADER_LOC_VERTEX_COLOR = 5,
  SHADER_LOC_MATRIX_MVP = 6,
  SHADER_LOC_MATRIX_VIEW = 7,
  SHADER_LOC_MATRIX_PROJECTION = 8,
  SHADER_LOC_MATRIX_MODEL = 9,
  SHADER_LOC_MATRIX_NORMAL = 10,
  SHADER_LOC_VECTOR_VIEW = 11,
  SHADER_LOC_COLOR_DIFFUSE = 12,
  SHADER_LOC_COLOR_SPECULAR = 13,
  SHADER_LOC_COLOR_AMBIENT = 14,
  SHADER_LOC_MAP_ALBEDO = 15,
  SHADER_LOC_MAP_METALNESS = 16,
  SHADER_LOC_MAP_NORMAL = 17,
  SHADER_LOC_MAP_ROUGHNESS = 18,
  SHADER_LOC_MAP_OCCLUSION = 19,
  SHADER_LOC_MAP_EMISSION = 20,
  SHADER_LOC_MAP_HEIGHT = 21,
  SHADER_LOC_MAP_CUBEMAP = 22,
  SHADER_LOC_MAP_IRRADIANCE = 23,
  SHADER_LOC_MAP_PREFILTER = 24,
  SHADER_LOC_MAP_BRDF = 25,
  SHADER_LOC_VERTEX_BONEIDS = 26,
  SHADER_LOC_VERTEX_BONEWEIGHTS = 27,
  SHADER_LOC_BONE_MATRICES = 28,
  SHADER_LOC_VERTEX_INSTANCE_TX = 29,
};
enum ShaderUniformDataType {
  SHADER_UNIFORM_FLOAT = 0,
  SHADER_UNIFORM_VEC2 = 1,
  SHADER_UNIFORM_VEC3 = 2,
  SHADER_UNIFORM_VEC4 = 3,
  SHADER_UNIFORM_INT = 4,
  SHADER_UNIFORM_IVEC2 = 5,
  SHADER_UNIFORM_IVEC3 = 6,
  SHADER_UNIFORM_IVEC4 = 7,
  SHADER_UNIFORM_UINT = 8,
  SHADER_UNIFORM_UIVEC2 = 9,
  SHADER_UNIFORM_UIVEC3 = 10,
  SHADER_UNIFORM_UIVEC4 = 11,
  SHADER_UNIFORM_SAMPLER2D = 12,
};
enum ShaderAttributeDataType {
  SHADER_ATTRIB_FLOAT = 0,
  SHADER_ATTRIB_VEC2 = 1,
  SHADER_ATTRIB_VEC3 = 2,
  SHADER_ATTRIB_VEC4 = 3,
};
enum PixelFormat {
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2,
  PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4,
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5,
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7,
  PIXELFORMAT_UNCOMPRESSED_R32 = 8,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10,
  PIXELFORMAT_UNCOMPRESSED_R16 = 11,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13,
  PIXELFORMAT_COMPRESSED_DXT1_RGB = 14,
  PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15,
  PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16,
  PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17,
  PIXELFORMAT_COMPRESSED_ETC1_RGB = 18,
  PIXELFORMAT_COMPRESSED_ETC2_RGB = 19,
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20,
  PIXELFORMAT_COMPRESSED_PVRT_RGB = 21,
  PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22,
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23,
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24,
};
enum TextureFilter {
  TEXTURE_FILTER_POINT = 0,
  TEXTURE_FILTER_BILINEAR = 1,
  TEXTURE_FILTER_TRILINEAR = 2,
  TEXTURE_FILTER_ANISOTROPIC_4X = 3,
  TEXTURE_FILTER_ANISOTROPIC_8X = 4,
  TEXTURE_FILTER_ANISOTROPIC_16X = 5,
};
enum TextureWrap {
  TEXTURE_WRAP_REPEAT = 0,
  TEXTURE_WRAP_CLAMP = 1,
  TEXTURE_WRAP_MIRROR_REPEAT = 2,
  TEXTURE_WRAP_MIRROR_CLAMP = 3,
};
enum CubemapLayout {
  CUBEMAP_LAYOUT_AUTO_DETECT = 0,
  CUBEMAP_LAYOUT_LINE_VERTICAL = 1,
  CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2,
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3,
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4,
};
enum FontType {
  FONT_DEFAULT = 0,
  FONT_BITMAP = 1,
  FONT_SDF = 2,
};
enum BlendMode {
  BLEND_ALPHA = 0,
  BLEND_ADDITIVE = 1,
  BLEND_MULTIPLIED = 2,
  BLEND_ADD_COLORS = 3,
  BLEND_SUBTRACT_COLORS = 4,
  BLEND_ALPHA_PREMULTIPLY = 5,
  BLEND_CUSTOM = 6,
  BLEND_CUSTOM_SEPARATE = 7,
};
enum Gesture {
  GESTURE_NONE = 0,
  GESTURE_TAP = 1,
  GESTURE_DOUBLETAP = 2,
  GESTURE_HOLD = 4,
  GESTURE_DRAG = 8,
  GESTURE_SWIPE_RIGHT = 16,
  GESTURE_SWIPE_LEFT = 32,
  GESTURE_SWIPE_UP = 64,
  GESTURE_SWIPE_DOWN = 128,
  GESTURE_PINCH_IN = 256,
  GESTURE_PINCH_OUT = 512,
};
enum CameraMode {
  CAMERA_CUSTOM = 0,
  CAMERA_FREE = 1,
  CAMERA_ORBITAL = 2,
  CAMERA_FIRST_PERSON = 3,
  CAMERA_THIRD_PERSON = 4,
};
enum CameraProjection {
  CAMERA_PERSPECTIVE = 0,
  CAMERA_ORTHOGRAPHIC = 1,
};
enum NPatchLayout {
  NPATCH_NINE_PATCH = 0,
  NPATCH_THREE_PATCH_VERTICAL = 1,
  NPATCH_THREE_PATCH_HORIZONTAL = 2,
};
type TraceLogCallback :: fn(s32, *const u8) -> void;
type LoadFileDataCallback :: fn(*const u8, *const s32) -> *const u8;
type SaveFileDataCallback :: fn(*const u8, *const void, s32) -> bool;
type LoadFileTextCallback :: fn(*const u8) -> *const u8;
type SaveFileTextCallback :: fn(*const u8, *const u8) -> bool;
extern fn InitWindow(width: s32, height: s32, title: *const u8) -> void;
extern fn CloseWindow() -> void;
extern fn WindowShouldClose() -> bool;
extern fn IsWindowReady() -> bool;
extern fn IsWindowFullscreen() -> bool;
extern fn IsWindowHidden() -> bool;
extern fn IsWindowMinimized() -> bool;
extern fn IsWindowMaximized() -> bool;
extern fn IsWindowFocused() -> bool;
extern fn IsWindowResized() -> bool;
extern fn IsWindowState(flag: u32) -> bool;
extern fn SetWindowState(flags: u32) -> void;
extern fn ClearWindowState(flags: u32) -> void;
extern fn ToggleFullscreen() -> void;
extern fn ToggleBorderlessWindowed() -> void;
extern fn MaximizeWindow() -> void;
extern fn MinimizeWindow() -> void;
extern fn RestoreWindow() -> void;
extern fn SetWindowIcon(image: Image) -> void;
extern fn SetWindowIcons(images: *const Image, count: s32) -> void;
extern fn SetWindowTitle(title: *const u8) -> void;
extern fn SetWindowPosition(x: s32, y: s32) -> void;
extern fn SetWindowMonitor(monitor: s32) -> void;
extern fn SetWindowMinSize(width: s32, height: s32) -> void;
extern fn SetWindowMaxSize(width: s32, height: s32) -> void;
extern fn SetWindowSize(width: s32, height: s32) -> void;
extern fn SetWindowOpacity(opacity: f32) -> void;
extern fn SetWindowFocused() -> void;
extern fn GetWindowHandle() -> *const void;
extern fn GetScreenWidth() -> s32;
extern fn GetScreenHeight() -> s32;
extern fn GetRenderWidth() -> s32;
extern fn GetRenderHeight() -> s32;
extern fn GetMonitorCount() -> s32;
extern fn GetCurrentMonitor() -> s32;
extern fn GetMonitorPosition(monitor: s32) -> Vector2;
extern fn GetMonitorWidth(monitor: s32) -> s32;
extern fn GetMonitorHeight(monitor: s32) -> s32;
extern fn GetMonitorPhysicalWidth(monitor: s32) -> s32;
extern fn GetMonitorPhysicalHeight(monitor: s32) -> s32;
extern fn GetMonitorRefreshRate(monitor: s32) -> s32;
extern fn GetWindowPosition() -> Vector2;
extern fn GetWindowScaleDPI() -> Vector2;
extern fn GetMonitorName(monitor: s32) -> *const u8;
extern fn SetClipboardText(text: *const u8) -> void;
extern fn GetClipboardText() -> *const u8;
extern fn GetClipboardImage() -> Image;
extern fn EnableEventWaiting() -> void;
extern fn DisableEventWaiting() -> void;
extern fn ShowCursor() -> void;
extern fn HideCursor() -> void;
extern fn IsCursorHidden() -> bool;
extern fn EnableCursor() -> void;
extern fn DisableCursor() -> void;
extern fn IsCursorOnScreen() -> bool;
extern fn ClearBackground(color: Color) -> void;
extern fn BeginDrawing() -> void;
extern fn EndDrawing() -> void;
extern fn BeginMode2D(camera: Camera2D) -> void;
extern fn EndMode2D() -> void;
extern fn BeginMode3D(camera: Camera3D) -> void;
extern fn EndMode3D() -> void;
extern fn BeginTextureMode(target: RenderTexture2D) -> void;
extern fn EndTextureMode() -> void;
extern fn BeginShaderMode(shader: Shader) -> void;
extern fn EndShaderMode() -> void;
extern fn BeginBlendMode(mode: s32) -> void;
extern fn EndBlendMode() -> void;
extern fn BeginScissorMode(x: s32, y: s32, width: s32, height: s32) -> void;
extern fn EndScissorMode() -> void;
extern fn BeginVrStereoMode(config: VrStereoConfig) -> void;
extern fn EndVrStereoMode() -> void;
extern fn LoadVrStereoConfig(device: VrDeviceInfo) -> VrStereoConfig;
extern fn UnloadVrStereoConfig(config: VrStereoConfig) -> void;
extern fn LoadShader(vsFileName: *const u8, fsFileName: *const u8) -> Shader;
extern fn LoadShaderFromMemory(vsCode: *const u8, fsCode: *const u8) -> Shader;
extern fn IsShaderValid(shader: Shader) -> bool;
extern fn GetShaderLocation(shader: Shader, uniformName: *const u8) -> s32;
extern fn GetShaderLocationAttrib(shader: Shader, attribName: *const u8) -> s32;
extern fn SetShaderValue(shader: Shader, locIndex: s32, value: *const void, uniformType: s32) -> void;
extern fn SetShaderValueV(shader: Shader, locIndex: s32, value: *const void, uniformType: s32, count: s32) -> void;
extern fn SetShaderValueMatrix(shader: Shader, locIndex: s32, mat: Matrix) -> void;
extern fn SetShaderValueTexture(shader: Shader, locIndex: s32, texture: Texture2D) -> void;
extern fn UnloadShader(shader: Shader) -> void;
extern fn GetScreenToWorldRay(position: Vector2, camera: Camera) -> Ray;
extern fn GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: s32, height: s32) -> Ray;
extern fn GetWorldToScreen(position: Vector3, camera: Camera) -> Vector2;
extern fn GetWorldToScreenEx(position: Vector3, camera: Camera, width: s32, height: s32) -> Vector2;
extern fn GetWorldToScreen2D(position: Vector2, camera: Camera2D) -> Vector2;
extern fn GetScreenToWorld2D(position: Vector2, camera: Camera2D) -> Vector2;
extern fn GetCameraMatrix(camera: Camera) -> Matrix;
extern fn GetCameraMatrix2D(camera: Camera2D) -> Matrix;
extern fn SetTargetFPS(fps: s32) -> void;
extern fn GetFrameTime() -> f32;
extern fn GetTime() -> f64;
extern fn GetFPS() -> s32;
extern fn SwapScreenBuffer() -> void;
extern fn PollInputEvents() -> void;
extern fn WaitTime(seconds: f64) -> void;
extern fn SetRandomSeed(seed: u32) -> void;
extern fn GetRandomValue(min: s32, max: s32) -> s32;
extern fn LoadRandomSequence(count: u32, min: s32, max: s32) -> *const s32;
extern fn UnloadRandomSequence(sequence: *const s32) -> void;
extern fn TakeScreenshot(fileName: *const u8) -> void;
extern fn SetConfigFlags(flags: u32) -> void;
extern fn OpenURL(url: *const u8) -> void;
extern fn TraceLog(logLevel: s32, text: *const u8) -> void;
extern fn SetTraceLogLevel(logLevel: s32) -> void;
extern fn MemAlloc(size: u32) -> *const void;
extern fn MemRealloc(ptr: *const void, size: u32) -> *const void;
extern fn MemFree(ptr: *const void) -> void;
extern fn SetTraceLogCallback(callback: TraceLogCallback) -> void;
extern fn SetLoadFileDataCallback(callback: LoadFileDataCallback) -> void;
extern fn SetSaveFileDataCallback(callback: SaveFileDataCallback) -> void;
extern fn SetLoadFileTextCallback(callback: LoadFileTextCallback) -> void;
extern fn SetSaveFileTextCallback(callback: SaveFileTextCallback) -> void;
extern fn LoadFileData(fileName: *const u8, dataSize: *const s32) -> *const u8;
extern fn UnloadFileData(data: *const u8) -> void;
extern fn SaveFileData(fileName: *const u8, data: *const void, dataSize: s32) -> bool;
extern fn ExportDataAsCode(data: *const u8, dataSize: s32, fileName: *const u8) -> bool;
extern fn LoadFileText(fileName: *const u8) -> *const u8;
extern fn UnloadFileText(text: *const u8) -> void;
extern fn SaveFileText(fileName: *const u8, text: *const u8) -> bool;
extern fn FileExists(fileName: *const u8) -> bool;
extern fn DirectoryExists(dirPath: *const u8) -> bool;
extern fn IsFileExtension(fileName: *const u8, ext: *const u8) -> bool;
extern fn GetFileLength(fileName: *const u8) -> s32;
extern fn GetFileExtension(fileName: *const u8) -> *const u8;
extern fn GetFileName(filePath: *const u8) -> *const u8;
extern fn GetFileNameWithoutExt(filePath: *const u8) -> *const u8;
extern fn GetDirectoryPath(filePath: *const u8) -> *const u8;
extern fn GetPrevDirectoryPath(dirPath: *const u8) -> *const u8;
extern fn GetWorkingDirectory() -> *const u8;
extern fn GetApplicationDirectory() -> *const u8;
extern fn MakeDirectory(dirPath: *const u8) -> s32;
extern fn ChangeDirectory(dir: *const u8) -> bool;
extern fn IsPathFile(path: *const u8) -> bool;
extern fn IsFileNameValid(fileName: *const u8) -> bool;
extern fn LoadDirectoryFiles(dirPath: *const u8) -> FilePathList;
extern fn LoadDirectoryFilesEx(basePath: *const u8, filter: *const u8, scanSubdirs: bool) -> FilePathList;
extern fn UnloadDirectoryFiles(files: FilePathList) -> void;
extern fn IsFileDropped() -> bool;
extern fn LoadDroppedFiles() -> FilePathList;
extern fn UnloadDroppedFiles(files: FilePathList) -> void;
extern fn GetFileModTime(fileName: *const u8) -> s64;
extern fn CompressData(data: *const u8, dataSize: s32, compDataSize: *const s32) -> *const u8;
extern fn DecompressData(compData: *const u8, compDataSize: s32, dataSize: *const s32) -> *const u8;
extern fn EncodeDataBase64(data: *const u8, dataSize: s32, outputSize: *const s32) -> *const u8;
extern fn DecodeDataBase64(data: *const u8, outputSize: *const s32) -> *const u8;
extern fn ComputeCRC32(data: *const u8, dataSize: s32) -> u32;
extern fn ComputeMD5(data: *const u8, dataSize: s32) -> *const u32;
extern fn ComputeSHA1(data: *const u8, dataSize: s32) -> *const u32;
extern fn LoadAutomationEventList(fileName: *const u8) -> AutomationEventList;
extern fn UnloadAutomationEventList(list: AutomationEventList) -> void;
extern fn ExportAutomationEventList(list: AutomationEventList, fileName: *const u8) -> bool;
extern fn SetAutomationEventList(list: *const AutomationEventList) -> void;
extern fn SetAutomationEventBaseFrame(frame: s32) -> void;
extern fn StartAutomationEventRecording() -> void;
extern fn StopAutomationEventRecording() -> void;
extern fn PlayAutomationEvent(event: AutomationEvent) -> void;
extern fn IsKeyPressed(key: s32) -> bool;
extern fn IsKeyPressedRepeat(key: s32) -> bool;
extern fn IsKeyDown(key: s32) -> bool;
extern fn IsKeyReleased(key: s32) -> bool;
extern fn IsKeyUp(key: s32) -> bool;
extern fn GetKeyPressed() -> s32;
extern fn GetCharPressed() -> s32;
extern fn GetKeyName(key: s32) -> *const u8;
extern fn SetExitKey(key: s32) -> void;
extern fn IsGamepadAvailable(gamepad: s32) -> bool;
extern fn GetGamepadName(gamepad: s32) -> *const u8;
extern fn IsGamepadButtonPressed(gamepad: s32, button: s32) -> bool;
extern fn IsGamepadButtonDown(gamepad: s32, button: s32) -> bool;
extern fn IsGamepadButtonReleased(gamepad: s32, button: s32) -> bool;
extern fn IsGamepadButtonUp(gamepad: s32, button: s32) -> bool;
extern fn GetGamepadButtonPressed() -> s32;
extern fn GetGamepadAxisCount(gamepad: s32) -> s32;
extern fn GetGamepadAxisMovement(gamepad: s32, axis: s32) -> f32;
extern fn SetGamepadMappings(mappings: *const u8) -> s32;
extern fn SetGamepadVibration(gamepad: s32, leftMotor: f32, rightMotor: f32, duration: f32) -> void;
extern fn IsMouseButtonPressed(button: s32) -> bool;
extern fn IsMouseButtonDown(button: s32) -> bool;
extern fn IsMouseButtonReleased(button: s32) -> bool;
extern fn IsMouseButtonUp(button: s32) -> bool;
extern fn GetMouseX() -> s32;
extern fn GetMouseY() -> s32;
extern fn GetMousePosition() -> Vector2;
extern fn GetMouseDelta() -> Vector2;
extern fn SetMousePosition(x: s32, y: s32) -> void;
extern fn SetMouseOffset(offsetX: s32, offsetY: s32) -> void;
extern fn SetMouseScale(scaleX: f32, scaleY: f32) -> void;
extern fn GetMouseWheelMove() -> f32;
extern fn GetMouseWheelMoveV() -> Vector2;
extern fn SetMouseCursor(cursor: s32) -> void;
extern fn GetTouchX() -> s32;
extern fn GetTouchY() -> s32;
extern fn GetTouchPosition(index: s32) -> Vector2;
extern fn GetTouchPointId(index: s32) -> s32;
extern fn GetTouchPointCount() -> s32;
extern fn SetGesturesEnabled(flags: u32) -> void;
extern fn IsGestureDetected(gesture: u32) -> bool;
extern fn GetGestureDetected() -> s32;
extern fn GetGestureHoldDuration() -> f32;
extern fn GetGestureDragVector() -> Vector2;
extern fn GetGestureDragAngle() -> f32;
extern fn GetGesturePinchVector() -> Vector2;
extern fn GetGesturePinchAngle() -> f32;
extern fn UpdateCamera(camera: *const Camera, mode: s32) -> void;
extern fn UpdateCameraPro(camera: *const Camera, movement: Vector3, rotation: Vector3, zoom: f32) -> void;
extern fn SetShapesTexture(texture: Texture2D, source: Rectangle) -> void;
extern fn GetShapesTexture() -> Texture2D;
extern fn GetShapesTextureRectangle() -> Rectangle;
extern fn DrawPixel(posX: s32, posY: s32, color: Color) -> void;
extern fn DrawPixelV(position: Vector2, color: Color) -> void;
extern fn DrawLine(startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color) -> void;
extern fn DrawLineV(startPos: Vector2, endPos: Vector2, color: Color) -> void;
extern fn DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32, color: Color) -> void;
extern fn DrawLineStrip(points: *const Vector2, pointCount: s32, color: Color) -> void;
extern fn DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color) -> void;
extern fn DrawCircle(centerX: s32, centerY: s32, radius: f32, color: Color) -> void;
extern fn DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
extern fn DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
extern fn DrawCircleGradient(centerX: s32, centerY: s32, radius: f32, inner: Color, outer: Color) -> void;
extern fn DrawCircleV(center: Vector2, radius: f32, color: Color) -> void;
extern fn DrawCircleLines(centerX: s32, centerY: s32, radius: f32, color: Color) -> void;
extern fn DrawCircleLinesV(center: Vector2, radius: f32, color: Color) -> void;
extern fn DrawEllipse(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color) -> void;
extern fn DrawEllipseLines(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color) -> void;
extern fn DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
extern fn DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
extern fn DrawRectangle(posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
extern fn DrawRectangleV(position: Vector2, size: Vector2, color: Color) -> void;
extern fn DrawRectangleRec(rec: Rectangle, color: Color) -> void;
extern fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color) -> void;
extern fn DrawRectangleGradientV(posX: s32, posY: s32, width: s32, height: s32, top: Color, bottom: Color) -> void;
extern fn DrawRectangleGradientH(posX: s32, posY: s32, width: s32, height: s32, left: Color, right: Color) -> void;
extern fn DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color) -> void;
extern fn DrawRectangleLines(posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
extern fn DrawRectangleLinesEx(rec: Rectangle, lineThick: f32, color: Color) -> void;
extern fn DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: s32, color: Color) -> void;
extern fn DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: s32, color: Color) -> void;
extern fn DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: f32, segments: s32, lineThick: f32, color: Color) -> void;
extern fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
extern fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
extern fn DrawTriangleFan(points: *const Vector2, pointCount: s32, color: Color) -> void;
extern fn DrawTriangleStrip(points: *const Vector2, pointCount: s32, color: Color) -> void;
extern fn DrawPoly(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color) -> void;
extern fn DrawPolyLines(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color) -> void;
extern fn DrawPolyLinesEx(center: Vector2, sides: s32, radius: f32, rotation: f32, lineThick: f32, color: Color) -> void;
extern fn DrawSplineLinear(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
extern fn DrawSplineBasis(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
extern fn DrawSplineCatmullRom(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
extern fn DrawSplineBezierQuadratic(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
extern fn DrawSplineBezierCubic(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
extern fn DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: f32, color: Color) -> void;
extern fn DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color) -> void;
extern fn DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color) -> void;
extern fn DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: f32, color: Color) -> void;
extern fn DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: f32, color: Color) -> void;
extern fn GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: f32) -> Vector2;
extern fn GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) -> Vector2;
extern fn GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) -> Vector2;
extern fn GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: f32) -> Vector2;
extern fn GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: f32) -> Vector2;
extern fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool;
extern fn CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) -> bool;
extern fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle) -> bool;
extern fn CheckCollisionCircleLine(center: Vector2, radius: f32, p1: Vector2, p2: Vector2) -> bool;
extern fn CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool;
extern fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32) -> bool;
extern fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;
extern fn CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: s32) -> bool;
extern fn CheckCollisionPointPoly(point: Vector2, points: *const Vector2, pointCount: s32) -> bool;
extern fn CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: *const Vector2) -> bool;
extern fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
extern fn LoadImage(fileName: *const u8) -> Image;
extern fn LoadImageRaw(fileName: *const u8, width: s32, height: s32, format: s32, headerSize: s32) -> Image;
extern fn LoadImageAnim(fileName: *const u8, frames: *const s32) -> Image;
extern fn LoadImageAnimFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32, frames: *const s32) -> Image;
extern fn LoadImageFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32) -> Image;
extern fn LoadImageFromTexture(texture: Texture2D) -> Image;
extern fn LoadImageFromScreen() -> Image;
extern fn IsImageValid(image: Image) -> bool;
extern fn UnloadImage(image: Image) -> void;
extern fn ExportImage(image: Image, fileName: *const u8) -> bool;
extern fn ExportImageToMemory(image: Image, fileType: *const u8, fileSize: *const s32) -> *const u8;
extern fn ExportImageAsCode(image: Image, fileName: *const u8) -> bool;
extern fn GenImageColor(width: s32, height: s32, color: Color) -> Image;
extern fn GenImageGradientLinear(width: s32, height: s32, direction: s32, start: Color, end: Color) -> Image;
extern fn GenImageGradientRadial(width: s32, height: s32, density: f32, inner: Color, outer: Color) -> Image;
extern fn GenImageGradientSquare(width: s32, height: s32, density: f32, inner: Color, outer: Color) -> Image;
extern fn GenImageChecked(width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) -> Image;
extern fn GenImageWhiteNoise(width: s32, height: s32, factor: f32) -> Image;
extern fn GenImagePerlinNoise(width: s32, height: s32, offsetX: s32, offsetY: s32, scale: f32) -> Image;
extern fn GenImageCellular(width: s32, height: s32, tileSize: s32) -> Image;
extern fn GenImageText(width: s32, height: s32, text: *const u8) -> Image;
extern fn ImageCopy(image: Image) -> Image;
extern fn ImageFromImage(image: Image, rec: Rectangle) -> Image;
extern fn ImageFromChannel(image: Image, selectedChannel: s32) -> Image;
extern fn ImageText(text: *const u8, fontSize: s32, color: Color) -> Image;
extern fn ImageTextEx(font: Font, text: *const u8, fontSize: f32, spacing: f32, tint: Color) -> Image;
extern fn ImageFormat(image: *const Image, newFormat: s32) -> void;
extern fn ImageToPOT(image: *const Image, fill: Color) -> void;
extern fn ImageCrop(image: *const Image, crop: Rectangle) -> void;
extern fn ImageAlphaCrop(image: *const Image, threshold: f32) -> void;
extern fn ImageAlphaClear(image: *const Image, color: Color, threshold: f32) -> void;
extern fn ImageAlphaMask(image: *const Image, alphaMask: Image) -> void;
extern fn ImageAlphaPremultiply(image: *const Image) -> void;
extern fn ImageBlurGaussian(image: *const Image, blurSize: s32) -> void;
extern fn ImageKernelConvolution(image: *const Image, kernel: *const f32, kernelSize: s32) -> void;
extern fn ImageResize(image: *const Image, newWidth: s32, newHeight: s32) -> void;
extern fn ImageResizeNN(image: *const Image, newWidth: s32, newHeight: s32) -> void;
extern fn ImageResizeCanvas(image: *const Image, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, fill: Color) -> void;
extern fn ImageMipmaps(image: *const Image) -> void;
extern fn ImageDither(image: *const Image, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32) -> void;
extern fn ImageFlipVertical(image: *const Image) -> void;
extern fn ImageFlipHorizontal(image: *const Image) -> void;
extern fn ImageRotate(image: *const Image, degrees: s32) -> void;
extern fn ImageRotateCW(image: *const Image) -> void;
extern fn ImageRotateCCW(image: *const Image) -> void;
extern fn ImageColorTint(image: *const Image, color: Color) -> void;
extern fn ImageColorInvert(image: *const Image) -> void;
extern fn ImageColorGrayscale(image: *const Image) -> void;
extern fn ImageColorContrast(image: *const Image, contrast: f32) -> void;
extern fn ImageColorBrightness(image: *const Image, brightness: s32) -> void;
extern fn ImageColorReplace(image: *const Image, color: Color, replace: Color) -> void;
extern fn LoadImageColors(image: Image) -> *const Color;
extern fn LoadImagePalette(image: Image, maxPaletteSize: s32, colorCount: *const s32) -> *const Color;
extern fn UnloadImageColors(colors: *const Color) -> void;
extern fn UnloadImagePalette(colors: *const Color) -> void;
extern fn GetImageAlphaBorder(image: Image, threshold: f32) -> Rectangle;
extern fn GetImageColor(image: Image, x: s32, y: s32) -> Color;
extern fn ImageClearBackground(dst: *const Image, color: Color) -> void;
extern fn ImageDrawPixel(dst: *const Image, posX: s32, posY: s32, color: Color) -> void;
extern fn ImageDrawPixelV(dst: *const Image, position: Vector2, color: Color) -> void;
extern fn ImageDrawLine(dst: *const Image, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color) -> void;
extern fn ImageDrawLineV(dst: *const Image, start: Vector2, end: Vector2, color: Color) -> void;
extern fn ImageDrawLineEx(dst: *const Image, start: Vector2, end: Vector2, thick: s32, color: Color) -> void;
extern fn ImageDrawCircle(dst: *const Image, centerX: s32, centerY: s32, radius: s32, color: Color) -> void;
extern fn ImageDrawCircleV(dst: *const Image, center: Vector2, radius: s32, color: Color) -> void;
extern fn ImageDrawCircleLines(dst: *const Image, centerX: s32, centerY: s32, radius: s32, color: Color) -> void;
extern fn ImageDrawCircleLinesV(dst: *const Image, center: Vector2, radius: s32, color: Color) -> void;
extern fn ImageDrawRectangle(dst: *const Image, posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
extern fn ImageDrawRectangleV(dst: *const Image, position: Vector2, size: Vector2, color: Color) -> void;
extern fn ImageDrawRectangleRec(dst: *const Image, rec: Rectangle, color: Color) -> void;
extern fn ImageDrawRectangleLines(dst: *const Image, rec: Rectangle, thick: s32, color: Color) -> void;
extern fn ImageDrawTriangle(dst: *const Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
extern fn ImageDrawTriangleEx(dst: *const Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color) -> void;
extern fn ImageDrawTriangleLines(dst: *const Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
extern fn ImageDrawTriangleFan(dst: *const Image, points: *const Vector2, pointCount: s32, color: Color) -> void;
extern fn ImageDrawTriangleStrip(dst: *const Image, points: *const Vector2, pointCount: s32, color: Color) -> void;
extern fn ImageDraw(dst: *const Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color) -> void;
extern fn ImageDrawText(dst: *const Image, text: *const u8, posX: s32, posY: s32, fontSize: s32, color: Color) -> void;
extern fn ImageDrawTextEx(dst: *const Image, font: Font, text: *const u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void;
extern fn LoadTexture(fileName: *const u8) -> Texture2D;
extern fn LoadTextureFromImage(image: Image) -> Texture2D;
extern fn LoadTextureCubemap(image: Image, layout: s32) -> TextureCubemap;
extern fn LoadRenderTexture(width: s32, height: s32) -> RenderTexture2D;
extern fn IsTextureValid(texture: Texture2D) -> bool;
extern fn UnloadTexture(texture: Texture2D) -> void;
extern fn IsRenderTextureValid(target: RenderTexture2D) -> bool;
extern fn UnloadRenderTexture(target: RenderTexture2D) -> void;
extern fn UpdateTexture(texture: Texture2D, pixels: *const void) -> void;
extern fn UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: *const void) -> void;
extern fn GenTextureMipmaps(texture: *const Texture2D) -> void;
extern fn SetTextureFilter(texture: Texture2D, filter: s32) -> void;
extern fn SetTextureWrap(texture: Texture2D, wrap: s32) -> void;
extern fn DrawTexture(texture: Texture2D, posX: s32, posY: s32, tint: Color) -> void;
extern fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color) -> void;
extern fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color) -> void;
extern fn DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) -> void;
extern fn DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) -> void;
extern fn DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) -> void;
extern fn ColorIsEqual(col1: Color, col2: Color) -> bool;
extern fn Fade(color: Color, alpha: f32) -> Color;
extern fn ColorToInt(color: Color) -> s32;
extern fn ColorNormalize(color: Color) -> Vector4;
extern fn ColorFromNormalized(normalized: Vector4) -> Color;
extern fn ColorToHSV(color: Color) -> Vector3;
extern fn ColorFromHSV(hue: f32, saturation: f32, value: f32) -> Color;
extern fn ColorTint(color: Color, tint: Color) -> Color;
extern fn ColorBrightness(color: Color, factor: f32) -> Color;
extern fn ColorContrast(color: Color, contrast: f32) -> Color;
extern fn ColorAlpha(color: Color, alpha: f32) -> Color;
extern fn ColorAlphaBlend(dst: Color, src: Color, tint: Color) -> Color;
extern fn ColorLerp(color1: Color, color2: Color, factor: f32) -> Color;
extern fn GetColor(hexValue: u32) -> Color;
extern fn GetPixelColor(srcPtr: *const void, format: s32) -> Color;
extern fn SetPixelColor(dstPtr: *const void, color: Color, format: s32) -> void;
extern fn GetPixelDataSize(width: s32, height: s32, format: s32) -> s32;
extern fn GetFontDefault() -> Font;
extern fn LoadFont(fileName: *const u8) -> Font;
extern fn LoadFontEx(fileName: *const u8, fontSize: s32, codepoints: *const s32, codepointCount: s32) -> Font;
extern fn LoadFontFromImage(image: Image, key: Color, firstChar: s32) -> Font;
extern fn LoadFontFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32, fontSize: s32, codepoints: *const s32, codepointCount: s32) -> Font;
extern fn IsFontValid(font: Font) -> bool;
extern fn LoadFontData(fileData: *const u8, dataSize: s32, fontSize: s32, codepoints: *const s32, codepointCount: s32, _type: s32) -> *const GlyphInfo;
extern fn GenImageFontAtlas(glyphs: *const GlyphInfo, glyphRecs: *const *const Rectangle, glyphCount: s32, fontSize: s32, padding: s32, packMethod: s32) -> Image;
extern fn UnloadFontData(glyphs: *const GlyphInfo, glyphCount: s32) -> void;
extern fn UnloadFont(font: Font) -> void;
extern fn ExportFontAsCode(font: Font, fileName: *const u8) -> bool;
extern fn DrawFPS(posX: s32, posY: s32) -> void;
extern fn DrawText(text: *const u8, posX: s32, posY: s32, fontSize: s32, color: Color) -> void;
extern fn DrawTextEx(font: Font, text: *const u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void;
extern fn DrawTextPro(font: Font, text: *const u8, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color) -> void;
extern fn DrawTextCodepoint(font: Font, codepoint: s32, position: Vector2, fontSize: f32, tint: Color) -> void;
extern fn DrawTextCodepoints(font: Font, codepoints: *const s32, codepointCount: s32, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void;
extern fn SetTextLineSpacing(spacing: s32) -> void;
extern fn MeasureText(text: *const u8, fontSize: s32) -> s32;
extern fn MeasureTextEx(font: Font, text: *const u8, fontSize: f32, spacing: f32) -> Vector2;
extern fn GetGlyphIndex(font: Font, codepoint: s32) -> s32;
extern fn GetGlyphInfo(font: Font, codepoint: s32) -> GlyphInfo;
extern fn GetGlyphAtlasRec(font: Font, codepoint: s32) -> Rectangle;
extern fn LoadUTF8(codepoints: *const s32, length: s32) -> *const u8;
extern fn UnloadUTF8(text: *const u8) -> void;
extern fn LoadCodepoints(text: *const u8, count: *const s32) -> *const s32;
extern fn UnloadCodepoints(codepoints: *const s32) -> void;
extern fn GetCodepointCount(text: *const u8) -> s32;
extern fn GetCodepoint(text: *const u8, codepointSize: *const s32) -> s32;
extern fn GetCodepointNext(text: *const u8, codepointSize: *const s32) -> s32;
extern fn GetCodepointPrevious(text: *const u8, codepointSize: *const s32) -> s32;
extern fn CodepointToUTF8(codepoint: s32, utf8Size: *const s32) -> *const u8;
extern fn TextCopy(dst: *const u8, src: *const u8) -> s32;
extern fn TextIsEqual(text1: *const u8, text2: *const u8) -> bool;
extern fn TextLength(text: *const u8) -> u32;
extern fn TextFormat(text: *const u8) -> *const u8;
extern fn TextSubtext(text: *const u8, position: s32, length: s32) -> *const u8;
extern fn TextReplace(text: *const u8, replace: *const u8, by: *const u8) -> *const u8;
extern fn TextInsert(text: *const u8, insert: *const u8, position: s32) -> *const u8;
extern fn TextJoin(textList: *const *const u8, count: s32, delimiter: *const u8) -> *const u8;
extern fn TextSplit(text: *const u8, delimiter: u8, count: *const s32) -> *const *const u8;
extern fn TextAppend(text: *const u8, append: *const u8, position: *const s32) -> void;
extern fn TextFindIndex(text: *const u8, find: *const u8) -> s32;
extern fn TextToUpper(text: *const u8) -> *const u8;
extern fn TextToLower(text: *const u8) -> *const u8;
extern fn TextToPascal(text: *const u8) -> *const u8;
extern fn TextToSnake(text: *const u8) -> *const u8;
extern fn TextToCamel(text: *const u8) -> *const u8;
extern fn TextToInteger(text: *const u8) -> s32;
extern fn TextToFloat(text: *const u8) -> f32;
extern fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color) -> void;
extern fn DrawPoint3D(position: Vector3, color: Color) -> void;
extern fn DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color) -> void;
extern fn DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color) -> void;
extern fn DrawTriangleStrip3D(points: *const Vector3, pointCount: s32, color: Color) -> void;
extern fn DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color) -> void;
extern fn DrawCubeV(position: Vector3, size: Vector3, color: Color) -> void;
extern fn DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color) -> void;
extern fn DrawCubeWiresV(position: Vector3, size: Vector3, color: Color) -> void;
extern fn DrawSphere(centerPos: Vector3, radius: f32, color: Color) -> void;
extern fn DrawSphereEx(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color) -> void;
extern fn DrawSphereWires(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color) -> void;
extern fn DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color) -> void;
extern fn DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color) -> void;
extern fn DrawCylinderWires(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color) -> void;
extern fn DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color) -> void;
extern fn DrawCapsule(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color) -> void;
extern fn DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color) -> void;
extern fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color) -> void;
extern fn DrawRay(ray: Ray, color: Color) -> void;
extern fn DrawGrid(slices: s32, spacing: f32) -> void;
extern fn LoadModel(fileName: *const u8) -> Model;
extern fn LoadModelFromMesh(mesh: Mesh) -> Model;
extern fn IsModelValid(model: Model) -> bool;
extern fn UnloadModel(model: Model) -> void;
extern fn GetModelBoundingBox(model: Model) -> BoundingBox;
extern fn DrawModel(model: Model, position: Vector3, scale: f32, tint: Color) -> void;
extern fn DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void;
extern fn DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color) -> void;
extern fn DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void;
extern fn DrawModelPoints(model: Model, position: Vector3, scale: f32, tint: Color) -> void;
extern fn DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void;
extern fn DrawBoundingBox(box: BoundingBox, color: Color) -> void;
extern fn DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color) -> void;
extern fn DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> void;
extern fn DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color) -> void;
extern fn UploadMesh(mesh: *const Mesh, dynamic: bool) -> void;
extern fn UpdateMeshBuffer(mesh: Mesh, index: s32, data: *const void, dataSize: s32, offset: s32) -> void;
extern fn UnloadMesh(mesh: Mesh) -> void;
extern fn DrawMesh(mesh: Mesh, material: Material, transform: Matrix) -> void;
extern fn DrawMeshInstanced(mesh: Mesh, material: Material, transforms: *const Matrix, instances: s32) -> void;
extern fn GetMeshBoundingBox(mesh: Mesh) -> BoundingBox;
extern fn GenMeshTangents(mesh: *const Mesh) -> void;
extern fn ExportMesh(mesh: Mesh, fileName: *const u8) -> bool;
extern fn ExportMeshAsCode(mesh: Mesh, fileName: *const u8) -> bool;
extern fn GenMeshPoly(sides: s32, radius: f32) -> Mesh;
extern fn GenMeshPlane(width: f32, length: f32, resX: s32, resZ: s32) -> Mesh;
extern fn GenMeshCube(width: f32, height: f32, length: f32) -> Mesh;
extern fn GenMeshSphere(radius: f32, rings: s32, slices: s32) -> Mesh;
extern fn GenMeshHemiSphere(radius: f32, rings: s32, slices: s32) -> Mesh;
extern fn GenMeshCylinder(radius: f32, height: f32, slices: s32) -> Mesh;
extern fn GenMeshCone(radius: f32, height: f32, slices: s32) -> Mesh;
extern fn GenMeshTorus(radius: f32, size: f32, radSeg: s32, sides: s32) -> Mesh;
extern fn GenMeshKnot(radius: f32, size: f32, radSeg: s32, sides: s32) -> Mesh;
extern fn GenMeshHeightmap(heightmap: Image, size: Vector3) -> Mesh;
extern fn GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh;
extern fn LoadMaterials(fileName: *const u8, materialCount: *const s32) -> *const Material;
extern fn LoadMaterialDefault() -> Material;
extern fn IsMaterialValid(material: Material) -> bool;
extern fn UnloadMaterial(material: Material) -> void;
extern fn SetMaterialTexture(material: *const Material, mapType: s32, texture: Texture2D) -> void;
extern fn SetModelMeshMaterial(model: *const Model, meshId: s32, materialId: s32) -> void;
extern fn LoadModelAnimations(fileName: *const u8, animCount: *const s32) -> *const ModelAnimation;
extern fn UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: s32) -> void;
extern fn UpdateModelAnimationBones(model: Model, anim: ModelAnimation, frame: s32) -> void;
extern fn UnloadModelAnimation(anim: ModelAnimation) -> void;
extern fn UnloadModelAnimations(animations: *const ModelAnimation, animCount: s32) -> void;
extern fn IsModelAnimationValid(model: Model, anim: ModelAnimation) -> bool;
extern fn CheckCollisionSpheres(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) -> bool;
extern fn CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool;
extern fn CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: f32) -> bool;
extern fn GetRayCollisionSphere(ray: Ray, center: Vector3, radius: f32) -> RayCollision;
extern fn GetRayCollisionBox(ray: Ray, box: BoundingBox) -> RayCollision;
extern fn GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision;
extern fn GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision;
extern fn GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision;
type AudioCallback :: fn(*const void, u32) -> void;
extern fn InitAudioDevice() -> void;
extern fn CloseAudioDevice() -> void;
extern fn IsAudioDeviceReady() -> bool;
extern fn SetMasterVolume(volume: f32) -> void;
extern fn GetMasterVolume() -> f32;
extern fn LoadWave(fileName: *const u8) -> Wave;
extern fn LoadWaveFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32) -> Wave;
extern fn IsWaveValid(wave: Wave) -> bool;
extern fn LoadSound(fileName: *const u8) -> Sound;
extern fn LoadSoundFromWave(wave: Wave) -> Sound;
extern fn LoadSoundAlias(source: Sound) -> Sound;
extern fn IsSoundValid(sound: Sound) -> bool;
extern fn UpdateSound(sound: Sound, data: *const void, sampleCount: s32) -> void;
extern fn UnloadWave(wave: Wave) -> void;
extern fn UnloadSound(sound: Sound) -> void;
extern fn UnloadSoundAlias(_alias: Sound) -> void;
extern fn ExportWave(wave: Wave, fileName: *const u8) -> bool;
extern fn ExportWaveAsCode(wave: Wave, fileName: *const u8) -> bool;
extern fn PlaySound(sound: Sound) -> void;
extern fn StopSound(sound: Sound) -> void;
extern fn PauseSound(sound: Sound) -> void;
extern fn ResumeSound(sound: Sound) -> void;
extern fn IsSoundPlaying(sound: Sound) -> bool;
extern fn SetSoundVolume(sound: Sound, volume: f32) -> void;
extern fn SetSoundPitch(sound: Sound, pitch: f32) -> void;
extern fn SetSoundPan(sound: Sound, pan: f32) -> void;
extern fn WaveCopy(wave: Wave) -> Wave;
extern fn WaveCrop(wave: *const Wave, initFrame: s32, finalFrame: s32) -> void;
extern fn WaveFormat(wave: *const Wave, sampleRate: s32, sampleSize: s32, channels: s32) -> void;
extern fn LoadWaveSamples(wave: Wave) -> *const f32;
extern fn UnloadWaveSamples(samples: *const f32) -> void;
extern fn LoadMusicStream(fileName: *const u8) -> Music;
extern fn LoadMusicStreamFromMemory(fileType: *const u8, data: *const u8, dataSize: s32) -> Music;
extern fn IsMusicValid(music: Music) -> bool;
extern fn UnloadMusicStream(music: Music) -> void;
extern fn PlayMusicStream(music: Music) -> void;
extern fn IsMusicStreamPlaying(music: Music) -> bool;
extern fn UpdateMusicStream(music: Music) -> void;
extern fn StopMusicStream(music: Music) -> void;
extern fn PauseMusicStream(music: Music) -> void;
extern fn ResumeMusicStream(music: Music) -> void;
extern fn SeekMusicStream(music: Music, position: f32) -> void;
extern fn SetMusicVolume(music: Music, volume: f32) -> void;
extern fn SetMusicPitch(music: Music, pitch: f32) -> void;
extern fn SetMusicPan(music: Music, pan: f32) -> void;
extern fn GetMusicTimeLength(music: Music) -> f32;
extern fn GetMusicTimePlayed(music: Music) -> f32;
extern fn LoadAudioStream(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream;
extern fn IsAudioStreamValid(stream: AudioStream) -> bool;
extern fn UnloadAudioStream(stream: AudioStream) -> void;
extern fn UpdateAudioStream(stream: AudioStream, data: *const void, frameCount: s32) -> void;
extern fn IsAudioStreamProcessed(stream: AudioStream) -> bool;
extern fn PlayAudioStream(stream: AudioStream) -> void;
extern fn PauseAudioStream(stream: AudioStream) -> void;
extern fn ResumeAudioStream(stream: AudioStream) -> void;
extern fn IsAudioStreamPlaying(stream: AudioStream) -> bool;
extern fn StopAudioStream(stream: AudioStream) -> void;
extern fn SetAudioStreamVolume(stream: AudioStream, volume: f32) -> void;
extern fn SetAudioStreamPitch(stream: AudioStream, pitch: f32) -> void;
extern fn SetAudioStreamPan(stream: AudioStream, pan: f32) -> void;
extern fn SetAudioStreamBufferSizeDefault(size: s32) -> void;
extern fn SetAudioStreamCallback(stream: AudioStream, callback: AudioCallback) -> void;
extern fn AttachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback) -> void;
extern fn DetachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback) -> void;
extern fn AttachAudioMixedProcessor(processor: AudioCallback) -> void;
extern fn DetachAudioMixedProcessor(processor: AudioCallback) -> void;


extern fn rlSetClipPlanes(near: f64, far: f64);