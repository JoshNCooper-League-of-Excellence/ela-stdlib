/*
  These bindings were auto generated by 'ela-bindings-generator', from '/usr/local/include/raylib.h' at 2025-03-06 11:21:49. 
*/
#include "raymath.ela";

struct Color {
  r: u8,
  g: u8,
  b: u8,
  a: u8,
};

struct Rectangle {
  x: f32,
  y: f32,
  width: f32,
  height: f32,
};

struct Image {
  data: *const void,
  width: s32,
  height: s32,
  mipmaps: s32,
  format: s32,
};
struct Texture {
  id: u32,
  width: s32,
  height: s32,
  mipmaps: s32,
  format: s32,
};
alias Texture2D :: Texture;
alias TextureCubemap :: Texture;
struct RenderTexture {
  id: u32,
  texture: Texture,
  depth: Texture,
};
alias RenderTexture2D :: RenderTexture;
struct NPatchInfo {
  source: Rectangle,
  left: s32,
  top: s32,
  right: s32,
  bottom: s32,
  layout: s32,
};
struct GlyphInfo {
  value: s32,
  offsetX: s32,
  offsetY: s32,
  advanceX: s32,
  image: Image,
};
struct Font {
  baseSize: s32,
  glyphCount: s32,
  glyphPadding: s32,
  texture: Texture2D,
  recs: *const Rectangle,
  glyphs: *const GlyphInfo,
};

struct Camera3D {
  position: Vector3,
  target: Vector3,
  up: Vector3,
  fovy: f32,
  projection: s32,
};

alias Camera :: Camera3D;

struct Camera2D {
  offset: Vector2,
  target: Vector2,
  rotation: f32,
  zoom: f32,
};

struct Mesh {
  vertexCount: s32,
  triangleCount: s32,
  vertices: *const f32,
  texcoords: *const f32,
  texcoords2: *const f32,
  normals: *const f32,
  tangents: *const f32,
  colors: *const u8,
  indices: *const u16,
  animVertices: *const f32,
  animNormals: *const f32,
  boneIds: *const u8,
  boneWeights: *const f32,
  boneMatrices: *const Matrix,
  boneCount: s32,
  vaoId: u32,
  vboId: *const u32,
};
struct Shader {
  id: u32,
  locs: *const s32,
};
struct MaterialMap {
  texture: Texture2D,
  color: Color,
  value: f32,
};
struct Material {
  shader: Shader,
  maps: *const MaterialMap,
  params: f32[4],
};
struct Transform {
  translation: Vector3,
  rotation: Quaternion,
  scale: Vector3,
};
struct BoneInfo {
  name: u8[32],
  parent: s32,
};
struct Model {
  transform: Matrix,
  meshCount: s32,
  materialCount: s32,
  meshes: *const Mesh,
  materials: *const Material,
  meshMaterial: *const s32,
  boneCount: s32,
  bones: *const BoneInfo,
  bindPose: *const Transform,
};
struct ModelAnimation {
  boneCount: s32,
  frameCount: s32,
  bones: *const BoneInfo,
  framePoses: *const *const Transform,
  name: u8[32],
};
struct Ray {
  position: Vector3,
  direction: Vector3,
};
struct RayCollision {
  hit: bool,
  distance: f32,
  point: Vector3,
  normal: Vector3,
};
struct BoundingBox {
  min: Vector3,
  max: Vector3,
};
struct Wave {
  frameCount: u32,
  sampleRate: u32,
  sampleSize: u32,
  channels: u32,
  data: *const void,
};
struct rAudioBuffer {
};
struct rAudioProcessor {
};
struct AudioStream {
  buffer: *const rAudioBuffer,
  processor: *const rAudioProcessor,
  sampleRate: u32,
  sampleSize: u32,
  channels: u32,
};
struct Sound {
  stream: AudioStream,
  frameCount: u32,
};
struct Music {
  stream: AudioStream,
  frameCount: u32,
  looping: bool,
  ctxType: s32,
  ctxData: *const void,
};
struct VrDeviceInfo {
  hResolution: s32,
  vResolution: s32,
  hScreenSize: f32,
  vScreenSize: f32,
  eyeToScreenDistance: f32,
  lensSeparationDistance: f32,
  interpupillaryDistance: f32,
  lensDistortionValues: f32[4],
  chromaAbCorrection: f32[4],
};
struct VrStereoConfig {
  projection: Matrix[2],
  viewOffset: Matrix[2],
  leftLensCenter: f32[2],
  rightLensCenter: f32[2],
  leftScreenCenter: f32[2],
  rightScreenCenter: f32[2],
  scale: f32[2],
  scaleIn: f32[2],
};
struct FilePathList {
  capacity: u32,
  count: u32,
  paths: *const *const u8,
};
struct AutomationEvent {
  frame: u32,
  type: u32,
  params: s32[4],
};
struct AutomationEventList {
  capacity: u32,
  count: u32,
  events: *const AutomationEvent,
};
enum ConfigFlags {
  FLAG_VSYNC_HINT = 64,
  FLAG_FULLSCREEN_MODE = 2,
  FLAG_WINDOW_RESIZABLE = 4,
  FLAG_WINDOW_UNDECORATED = 8,
  FLAG_WINDOW_HIDDEN = 128,
  FLAG_WINDOW_MINIMIZED = 512,
  FLAG_WINDOW_MAXIMIZED = 1024,
  FLAG_WINDOW_UNFOCUSED = 2048,
  FLAG_WINDOW_TOPMOST = 4096,
  FLAG_WINDOW_ALWAYS_RUN = 256,
  FLAG_WINDOW_TRANSPARENT = 16,
  FLAG_WINDOW_HIGHDPI = 8192,
  FLAG_WINDOW_MOUSE_PASSTHROUGH = 16384,
  FLAG_BORDERLESS_WINDOWED_MODE = 32768,
  FLAG_MSAA_4X_HINT = 32,
  FLAG_INTERLACED_HINT = 65536,
};
enum TraceLogLevel {
  LOG_ALL = 0,
  LOG_TRACE = 1,
  LOG_DEBUG = 2,
  LOG_INFO = 3,
  LOG_WARNING = 4,
  LOG_ERROR = 5,
  LOG_FATAL = 6,
  LOG_NONE = 7,
};
enum KeyboardKey {
  KEY_NULL = 0,
  KEY_APOSTROPHE = 39,
  KEY_COMMA = 44,
  KEY_MINUS = 45,
  KEY_PERIOD = 46,
  KEY_SLASH = 47,
  KEY_ZERO = 48,
  KEY_ONE = 49,
  KEY_TWO = 50,
  KEY_THREE = 51,
  KEY_FOUR = 52,
  KEY_FIVE = 53,
  KEY_SIX = 54,
  KEY_SEVEN = 55,
  KEY_EIGHT = 56,
  KEY_NINE = 57,
  KEY_SEMICOLON = 59,
  KEY_EQUAL = 61,
  KEY_A = 65,
  KEY_B = 66,
  KEY_C = 67,
  KEY_D = 68,
  KEY_E = 69,
  KEY_F = 70,
  KEY_G = 71,
  KEY_H = 72,
  KEY_I = 73,
  KEY_J = 74,
  KEY_K = 75,
  KEY_L = 76,
  KEY_M = 77,
  KEY_N = 78,
  KEY_O = 79,
  KEY_P = 80,
  KEY_Q = 81,
  KEY_R = 82,
  KEY_S = 83,
  KEY_T = 84,
  KEY_U = 85,
  KEY_V = 86,
  KEY_W = 87,
  KEY_X = 88,
  KEY_Y = 89,
  KEY_Z = 90,
  KEY_LEFT_BRACKET = 91,
  KEY_BACKSLASH = 92,
  KEY_RIGHT_BRACKET = 93,
  KEY_GRAVE = 96,
  KEY_SPACE = 32,
  KEY_ESCAPE = 256,
  KEY_ENTER = 257,
  KEY_TAB = 258,
  KEY_BACKSPACE = 259,
  KEY_INSERT = 260,
  KEY_DELETE = 261,
  KEY_RIGHT = 262,
  KEY_LEFT = 263,
  KEY_DOWN = 264,
  KEY_UP = 265,
  KEY_PAGE_UP = 266,
  KEY_PAGE_DOWN = 267,
  KEY_HOME = 268,
  KEY_END = 269,
  KEY_CAPS_LOCK = 280,
  KEY_SCROLL_LOCK = 281,
  KEY_NUM_LOCK = 282,
  KEY_PRINT_SCREEN = 283,
  KEY_PAUSE = 284,
  KEY_F1 = 290,
  KEY_F2 = 291,
  KEY_F3 = 292,
  KEY_F4 = 293,
  KEY_F5 = 294,
  KEY_F6 = 295,
  KEY_F7 = 296,
  KEY_F8 = 297,
  KEY_F9 = 298,
  KEY_F10 = 299,
  KEY_F11 = 300,
  KEY_F12 = 301,
  KEY_LEFT_SHIFT = 340,
  KEY_LEFT_CONTROL = 341,
  KEY_LEFT_ALT = 342,
  KEY_LEFT_SUPER = 343,
  KEY_RIGHT_SHIFT = 344,
  KEY_RIGHT_CONTROL = 345,
  KEY_RIGHT_ALT = 346,
  KEY_RIGHT_SUPER = 347,
  KEY_KB_MENU = 348,
  KEY_KP_0 = 320,
  KEY_KP_1 = 321,
  KEY_KP_2 = 322,
  KEY_KP_3 = 323,
  KEY_KP_4 = 324,
  KEY_KP_5 = 325,
  KEY_KP_6 = 326,
  KEY_KP_7 = 327,
  KEY_KP_8 = 328,
  KEY_KP_9 = 329,
  KEY_KP_DECIMAL = 330,
  KEY_KP_DIVIDE = 331,
  KEY_KP_MULTIPLY = 332,
  KEY_KP_SUBTRACT = 333,
  KEY_KP_ADD = 334,
  KEY_KP_ENTER = 335,
  KEY_KP_EQUAL = 336,
  KEY_BACK = 4,
  KEY_MENU = 5,
  KEY_VOLUME_UP = 24,
  KEY_VOLUME_DOWN = 25,
};
enum MouseButton {
  MOUSE_BUTTON_LEFT = 0,
  MOUSE_BUTTON_RIGHT = 1,
  MOUSE_BUTTON_MIDDLE = 2,
  MOUSE_BUTTON_SIDE = 3,
  MOUSE_BUTTON_EXTRA = 4,
  MOUSE_BUTTON_FORWARD = 5,
  MOUSE_BUTTON_BACK = 6,
};
enum MouseCursor {
  MOUSE_CURSOR_DEFAULT = 0,
  MOUSE_CURSOR_ARROW = 1,
  MOUSE_CURSOR_IBEAM = 2,
  MOUSE_CURSOR_CROSSHAIR = 3,
  MOUSE_CURSOR_POINTING_HAND = 4,
  MOUSE_CURSOR_RESIZE_EW = 5,
  MOUSE_CURSOR_RESIZE_NS = 6,
  MOUSE_CURSOR_RESIZE_NWSE = 7,
  MOUSE_CURSOR_RESIZE_NESW = 8,
  MOUSE_CURSOR_RESIZE_ALL = 9,
  MOUSE_CURSOR_NOT_ALLOWED = 10,
};
enum GamepadButton {
  GAMEPAD_BUTTON_UNKNOWN = 0,
  GAMEPAD_BUTTON_LEFT_FACE_UP = 1,
  GAMEPAD_BUTTON_LEFT_FACE_RIGHT = 2,
  GAMEPAD_BUTTON_LEFT_FACE_DOWN = 3,
  GAMEPAD_BUTTON_LEFT_FACE_LEFT = 4,
  GAMEPAD_BUTTON_RIGHT_FACE_UP = 5,
  GAMEPAD_BUTTON_RIGHT_FACE_RIGHT = 6,
  GAMEPAD_BUTTON_RIGHT_FACE_DOWN = 7,
  GAMEPAD_BUTTON_RIGHT_FACE_LEFT = 8,
  GAMEPAD_BUTTON_LEFT_TRIGGER_1 = 9,
  GAMEPAD_BUTTON_LEFT_TRIGGER_2 = 10,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_1 = 11,
  GAMEPAD_BUTTON_RIGHT_TRIGGER_2 = 12,
  GAMEPAD_BUTTON_MIDDLE_LEFT = 13,
  GAMEPAD_BUTTON_MIDDLE = 14,
  GAMEPAD_BUTTON_MIDDLE_RIGHT = 15,
  GAMEPAD_BUTTON_LEFT_THUMB = 16,
  GAMEPAD_BUTTON_RIGHT_THUMB = 17,
};
enum GamepadAxis {
  GAMEPAD_AXIS_LEFT_X = 0,
  GAMEPAD_AXIS_LEFT_Y = 1,
  GAMEPAD_AXIS_RIGHT_X = 2,
  GAMEPAD_AXIS_RIGHT_Y = 3,
  GAMEPAD_AXIS_LEFT_TRIGGER = 4,
  GAMEPAD_AXIS_RIGHT_TRIGGER = 5,
};
enum MaterialMapIndex {
  MATERIAL_MAP_ALBEDO = 0,
  MATERIAL_MAP_METALNESS = 1,
  MATERIAL_MAP_NORMAL = 2,
  MATERIAL_MAP_ROUGHNESS = 3,
  MATERIAL_MAP_OCCLUSION = 4,
  MATERIAL_MAP_EMISSION = 5,
  MATERIAL_MAP_HEIGHT = 6,
  MATERIAL_MAP_CUBEMAP = 7,
  MATERIAL_MAP_IRRADIANCE = 8,
  MATERIAL_MAP_PREFILTER = 9,
  MATERIAL_MAP_BRDF = 10,
};
enum ShaderLocationIndex {
  SHADER_LOC_VERTEX_POSITION = 0,
  SHADER_LOC_VERTEX_TEXCOORD01 = 1,
  SHADER_LOC_VERTEX_TEXCOORD02 = 2,
  SHADER_LOC_VERTEX_NORMAL = 3,
  SHADER_LOC_VERTEX_TANGENT = 4,
  SHADER_LOC_VERTEX_COLOR = 5,
  SHADER_LOC_MATRIX_MVP = 6,
  SHADER_LOC_MATRIX_VIEW = 7,
  SHADER_LOC_MATRIX_PROJECTION = 8,
  SHADER_LOC_MATRIX_MODEL = 9,
  SHADER_LOC_MATRIX_NORMAL = 10,
  SHADER_LOC_VECTOR_VIEW = 11,
  SHADER_LOC_COLOR_DIFFUSE = 12,
  SHADER_LOC_COLOR_SPECULAR = 13,
  SHADER_LOC_COLOR_AMBIENT = 14,
  SHADER_LOC_MAP_ALBEDO = 15,
  SHADER_LOC_MAP_METALNESS = 16,
  SHADER_LOC_MAP_NORMAL = 17,
  SHADER_LOC_MAP_ROUGHNESS = 18,
  SHADER_LOC_MAP_OCCLUSION = 19,
  SHADER_LOC_MAP_EMISSION = 20,
  SHADER_LOC_MAP_HEIGHT = 21,
  SHADER_LOC_MAP_CUBEMAP = 22,
  SHADER_LOC_MAP_IRRADIANCE = 23,
  SHADER_LOC_MAP_PREFILTER = 24,
  SHADER_LOC_MAP_BRDF = 25,
  SHADER_LOC_VERTEX_BONEIDS = 26,
  SHADER_LOC_VERTEX_BONEWEIGHTS = 27,
  SHADER_LOC_BONE_MATRICES = 28,
  SHADER_LOC_VERTEX_INSTANCE_TX = 29,
};
enum ShaderUniformDataType {
  SHADER_UNIFORM_FLOAT = 0,
  SHADER_UNIFORM_VEC2 = 1,
  SHADER_UNIFORM_VEC3 = 2,
  SHADER_UNIFORM_VEC4 = 3,
  SHADER_UNIFORM_INT = 4,
  SHADER_UNIFORM_IVEC2 = 5,
  SHADER_UNIFORM_IVEC3 = 6,
  SHADER_UNIFORM_IVEC4 = 7,
  SHADER_UNIFORM_UINT = 8,
  SHADER_UNIFORM_UIVEC2 = 9,
  SHADER_UNIFORM_UIVEC3 = 10,
  SHADER_UNIFORM_UIVEC4 = 11,
  SHADER_UNIFORM_SAMPLER2D = 12,
};
enum ShaderAttributeDataType {
  SHADER_ATTRIB_FLOAT = 0,
  SHADER_ATTRIB_VEC2 = 1,
  SHADER_ATTRIB_VEC3 = 2,
  SHADER_ATTRIB_VEC4 = 3,
};
enum PixelFormat {
  PIXELFORMAT_UNCOMPRESSED_GRAYSCALE = 1,
  PIXELFORMAT_UNCOMPRESSED_GRAY_ALPHA = 2,
  PIXELFORMAT_UNCOMPRESSED_R5G6B5 = 3,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8 = 4,
  PIXELFORMAT_UNCOMPRESSED_R5G5B5A1 = 5,
  PIXELFORMAT_UNCOMPRESSED_R4G4B4A4 = 6,
  PIXELFORMAT_UNCOMPRESSED_R8G8B8A8 = 7,
  PIXELFORMAT_UNCOMPRESSED_R32 = 8,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32 = 9,
  PIXELFORMAT_UNCOMPRESSED_R32G32B32A32 = 10,
  PIXELFORMAT_UNCOMPRESSED_R16 = 11,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16 = 12,
  PIXELFORMAT_UNCOMPRESSED_R16G16B16A16 = 13,
  PIXELFORMAT_COMPRESSED_DXT1_RGB = 14,
  PIXELFORMAT_COMPRESSED_DXT1_RGBA = 15,
  PIXELFORMAT_COMPRESSED_DXT3_RGBA = 16,
  PIXELFORMAT_COMPRESSED_DXT5_RGBA = 17,
  PIXELFORMAT_COMPRESSED_ETC1_RGB = 18,
  PIXELFORMAT_COMPRESSED_ETC2_RGB = 19,
  PIXELFORMAT_COMPRESSED_ETC2_EAC_RGBA = 20,
  PIXELFORMAT_COMPRESSED_PVRT_RGB = 21,
  PIXELFORMAT_COMPRESSED_PVRT_RGBA = 22,
  PIXELFORMAT_COMPRESSED_ASTC_4x4_RGBA = 23,
  PIXELFORMAT_COMPRESSED_ASTC_8x8_RGBA = 24,
};
enum TextureFilter {
  TEXTURE_FILTER_POINT = 0,
  TEXTURE_FILTER_BILINEAR = 1,
  TEXTURE_FILTER_TRILINEAR = 2,
  TEXTURE_FILTER_ANISOTROPIC_4X = 3,
  TEXTURE_FILTER_ANISOTROPIC_8X = 4,
  TEXTURE_FILTER_ANISOTROPIC_16X = 5,
};
enum TextureWrap {
  TEXTURE_WRAP_REPEAT = 0,
  TEXTURE_WRAP_CLAMP = 1,
  TEXTURE_WRAP_MIRROR_REPEAT = 2,
  TEXTURE_WRAP_MIRROR_CLAMP = 3,
};
enum CubemapLayout {
  CUBEMAP_LAYOUT_AUTO_DETECT = 0,
  CUBEMAP_LAYOUT_LINE_VERTICAL = 1,
  CUBEMAP_LAYOUT_LINE_HORIZONTAL = 2,
  CUBEMAP_LAYOUT_CROSS_THREE_BY_FOUR = 3,
  CUBEMAP_LAYOUT_CROSS_FOUR_BY_THREE = 4,
};
enum FontType {
  FONT_DEFAULT = 0,
  FONT_BITMAP = 1,
  FONT_SDF = 2,
};
enum BlendMode {
  BLEND_ALPHA = 0,
  BLEND_ADDITIVE = 1,
  BLEND_MULTIPLIED = 2,
  BLEND_ADD_COLORS = 3,
  BLEND_SUBTRACT_COLORS = 4,
  BLEND_ALPHA_PREMULTIPLY = 5,
  BLEND_CUSTOM = 6,
  BLEND_CUSTOM_SEPARATE = 7,
};
enum Gesture {
  GESTURE_NONE = 0,
  GESTURE_TAP = 1,
  GESTURE_DOUBLETAP = 2,
  GESTURE_HOLD = 4,
  GESTURE_DRAG = 8,
  GESTURE_SWIPE_RIGHT = 16,
  GESTURE_SWIPE_LEFT = 32,
  GESTURE_SWIPE_UP = 64,
  GESTURE_SWIPE_DOWN = 128,
  GESTURE_PINCH_IN = 256,
  GESTURE_PINCH_OUT = 512,
};
enum CameraMode {
  CAMERA_CUSTOM = 0,
  CAMERA_FREE = 1,
  CAMERA_ORBITAL = 2,
  CAMERA_FIRST_PERSON = 3,
  CAMERA_THIRD_PERSON = 4,
};
enum CameraProjection {
  CAMERA_PERSPECTIVE = 0,
  CAMERA_ORTHOGRAPHIC = 1,
};
enum NPatchLayout {
  NPATCH_NINE_PATCH = 0,
  NPATCH_THREE_PATCH_VERTICAL = 1,
  NPATCH_THREE_PATCH_HORIZONTAL = 2,
};
alias TraceLogCallback :: fn*(s32, *const u8) -> void;
alias LoadFileDataCallback :: fn*(*const u8, *const s32) -> *const u8;
alias SaveFileDataCallback :: fn*(*const u8, *const void, s32) -> bool;
alias LoadFileTextCallback :: fn*(*const u8) -> *const u8;
alias SaveFileTextCallback :: fn*(*const u8, *const u8) -> bool;
#foreign fn InitWindow(width: s32, height: s32, title: *const u8) -> void;
#foreign fn CloseWindow() -> void;
#foreign fn WindowShouldClose() -> bool;
#foreign fn IsWindowReady() -> bool;
#foreign fn IsWindowFullscreen() -> bool;
#foreign fn IsWindowHidden() -> bool;
#foreign fn IsWindowMinimized() -> bool;
#foreign fn IsWindowMaximized() -> bool;
#foreign fn IsWindowFocused() -> bool;
#foreign fn IsWindowResized() -> bool;
#foreign fn IsWindowState(flag: u32) -> bool;
#foreign fn SetWindowState(flags: u32) -> void;
#foreign fn ClearWindowState(flags: u32) -> void;
#foreign fn ToggleFullscreen() -> void;
#foreign fn ToggleBorderlessWindowed() -> void;
#foreign fn MaximizeWindow() -> void;
#foreign fn MinimizeWindow() -> void;
#foreign fn RestoreWindow() -> void;
#foreign fn SetWindowIcon(image: Image) -> void;
#foreign fn SetWindowIcons(images: *const Image, count: s32) -> void;
#foreign fn SetWindowTitle(title: *const u8) -> void;
#foreign fn SetWindowPosition(x: s32, y: s32) -> void;
#foreign fn SetWindowMonitor(monitor: s32) -> void;
#foreign fn SetWindowMinSize(width: s32, height: s32) -> void;
#foreign fn SetWindowMaxSize(width: s32, height: s32) -> void;
#foreign fn SetWindowSize(width: s32, height: s32) -> void;
#foreign fn SetWindowOpacity(opacity: f32) -> void;
#foreign fn SetWindowFocused() -> void;
#foreign fn GetWindowHandle() -> *const void;
#foreign fn GetScreenWidth() -> s32;
#foreign fn GetScreenHeight() -> s32;
#foreign fn GetRenderWidth() -> s32;
#foreign fn GetRenderHeight() -> s32;
#foreign fn GetMonitorCount() -> s32;
#foreign fn GetCurrentMonitor() -> s32;
#foreign fn GetMonitorPosition(monitor: s32) -> Vector2;
#foreign fn GetMonitorWidth(monitor: s32) -> s32;
#foreign fn GetMonitorHeight(monitor: s32) -> s32;
#foreign fn GetMonitorPhysicalWidth(monitor: s32) -> s32;
#foreign fn GetMonitorPhysicalHeight(monitor: s32) -> s32;
#foreign fn GetMonitorRefreshRate(monitor: s32) -> s32;
#foreign fn GetWindowPosition() -> Vector2;
#foreign fn GetWindowScaleDPI() -> Vector2;
#foreign fn GetMonitorName(monitor: s32) -> *const u8;
#foreign fn SetClipboardText(text: *const u8) -> void;
#foreign fn GetClipboardText() -> *const u8;
#foreign fn GetClipboardImage() -> Image;
#foreign fn EnableEventWaiting() -> void;
#foreign fn DisableEventWaiting() -> void;
#foreign fn ShowCursor() -> void;
#foreign fn HideCursor() -> void;
#foreign fn IsCursorHidden() -> bool;
#foreign fn EnableCursor() -> void;
#foreign fn DisableCursor() -> void;
#foreign fn IsCursorOnScreen() -> bool;
#foreign fn ClearBackground(color: Color) -> void;
#foreign fn BeginDrawing() -> void;
#foreign fn EndDrawing() -> void;
#foreign fn BeginMode2D(camera: Camera2D) -> void;
#foreign fn EndMode2D() -> void;
#foreign fn BeginMode3D(camera: Camera3D) -> void;
#foreign fn EndMode3D() -> void;
#foreign fn BeginTextureMode(target: RenderTexture2D) -> void;
#foreign fn EndTextureMode() -> void;
#foreign fn BeginShaderMode(shader: Shader) -> void;
#foreign fn EndShaderMode() -> void;
#foreign fn BeginBlendMode(mode: s32) -> void;
#foreign fn EndBlendMode() -> void;
#foreign fn BeginScissorMode(x: s32, y: s32, width: s32, height: s32) -> void;
#foreign fn EndScissorMode() -> void;
#foreign fn BeginVrStereoMode(config: VrStereoConfig) -> void;
#foreign fn EndVrStereoMode() -> void;
#foreign fn LoadVrStereoConfig(device: VrDeviceInfo) -> VrStereoConfig;
#foreign fn UnloadVrStereoConfig(config: VrStereoConfig) -> void;
#foreign fn LoadShader(vsFileName: *const u8, fsFileName: *const u8) -> Shader;
#foreign fn LoadShaderFromMemory(vsCode: *const u8, fsCode: *const u8) -> Shader;
#foreign fn IsShaderValid(shader: Shader) -> bool;
#foreign fn GetShaderLocation(shader: Shader, uniformName: *const u8) -> s32;
#foreign fn GetShaderLocationAttrib(shader: Shader, attribName: *const u8) -> s32;
#foreign fn SetShaderValue(shader: Shader, locIndex: s32, value: *const void, uniformType: s32) -> void;
#foreign fn SetShaderValueV(shader: Shader, locIndex: s32, value: *const void, uniformType: s32, count: s32) -> void;
#foreign fn SetShaderValueMatrix(shader: Shader, locIndex: s32, mat: Matrix) -> void;
#foreign fn SetShaderValueTexture(shader: Shader, locIndex: s32, texture: Texture2D) -> void;
#foreign fn UnloadShader(shader: Shader) -> void;
#foreign fn GetScreenToWorldRay(position: Vector2, camera: Camera) -> Ray;
#foreign fn GetScreenToWorldRayEx(position: Vector2, camera: Camera, width: s32, height: s32) -> Ray;
#foreign fn GetWorldToScreen(position: Vector3, camera: Camera) -> Vector2;
#foreign fn GetWorldToScreenEx(position: Vector3, camera: Camera, width: s32, height: s32) -> Vector2;
#foreign fn GetWorldToScreen2D(position: Vector2, camera: Camera2D) -> Vector2;
#foreign fn GetScreenToWorld2D(position: Vector2, camera: Camera2D) -> Vector2;
#foreign fn GetCameraMatrix(camera: Camera) -> Matrix;
#foreign fn GetCameraMatrix2D(camera: Camera2D) -> Matrix;
#foreign fn SetTargetFPS(fps: s32) -> void;
#foreign fn GetFrameTime() -> f32;
#foreign fn GetTime() -> f64;
#foreign fn GetFPS() -> s32;
#foreign fn SwapScreenBuffer() -> void;
#foreign fn PollInputEvents() -> void;
#foreign fn WaitTime(seconds: f64) -> void;
#foreign fn SetRandomSeed(seed: u32) -> void;
#foreign fn GetRandomValue(min: s32, max: s32) -> s32;
#foreign fn LoadRandomSequence(count: u32, min: s32, max: s32) -> *const s32;
#foreign fn UnloadRandomSequence(sequence: *const s32) -> void;
#foreign fn TakeScreenshot(fileName: *const u8) -> void;
#foreign fn SetConfigFlags(flags: u32) -> void;
#foreign fn OpenURL(url: *const u8) -> void;
#foreign fn TraceLog(logLevel: s32, text: *const u8) -> void;
#foreign fn SetTraceLogLevel(logLevel: s32) -> void;
#foreign fn MemAlloc(size: u32) -> *const void;
#foreign fn MemRealloc(ptr: *const void, size: u32) -> *const void;
#foreign fn MemFree(ptr: *const void) -> void;
#foreign fn SetTraceLogCallback(callback: TraceLogCallback) -> void;
#foreign fn SetLoadFileDataCallback(callback: LoadFileDataCallback) -> void;
#foreign fn SetSaveFileDataCallback(callback: SaveFileDataCallback) -> void;
#foreign fn SetLoadFileTextCallback(callback: LoadFileTextCallback) -> void;
#foreign fn SetSaveFileTextCallback(callback: SaveFileTextCallback) -> void;
#foreign fn LoadFileData(fileName: *const u8, dataSize: *const s32) -> *const u8;
#foreign fn UnloadFileData(data: *const u8) -> void;
#foreign fn SaveFileData(fileName: *const u8, data: *const void, dataSize: s32) -> bool;
#foreign fn ExportDataAsCode(data: *const u8, dataSize: s32, fileName: *const u8) -> bool;
#foreign fn LoadFileText(fileName: *const u8) -> *const u8;
#foreign fn UnloadFileText(text: *const u8) -> void;
#foreign fn SaveFileText(fileName: *const u8, text: *const u8) -> bool;
#foreign fn FileExists(fileName: *const u8) -> bool;
#foreign fn DirectoryExists(dirPath: *const u8) -> bool;
#foreign fn IsFileExtension(fileName: *const u8, ext: *const u8) -> bool;
#foreign fn GetFileLength(fileName: *const u8) -> s32;
#foreign fn GetFileExtension(fileName: *const u8) -> *const u8;
#foreign fn GetFileName(filePath: *const u8) -> *const u8;
#foreign fn GetFileNameWithoutExt(filePath: *const u8) -> *const u8;
#foreign fn GetDirectoryPath(filePath: *const u8) -> *const u8;
#foreign fn GetPrevDirectoryPath(dirPath: *const u8) -> *const u8;
#foreign fn GetWorkingDirectory() -> *const u8;
#foreign fn GetApplicationDirectory() -> *const u8;
#foreign fn MakeDirectory(dirPath: *const u8) -> s32;
#foreign fn ChangeDirectory(dir: *const u8) -> bool;
#foreign fn IsPathFile(path: *const u8) -> bool;
#foreign fn IsFileNameValid(fileName: *const u8) -> bool;
#foreign fn LoadDirectoryFiles(dirPath: *const u8) -> FilePathList;
#foreign fn LoadDirectoryFilesEx(basePath: *const u8, filter: *const u8, scanSubdirs: bool) -> FilePathList;
#foreign fn UnloadDirectoryFiles(files: FilePathList) -> void;
#foreign fn IsFileDropped() -> bool;
#foreign fn LoadDroppedFiles() -> FilePathList;
#foreign fn UnloadDroppedFiles(files: FilePathList) -> void;
#foreign fn GetFileModTime(fileName: *const u8) -> s64;
#foreign fn CompressData(data: *const u8, dataSize: s32, compDataSize: *const s32) -> *const u8;
#foreign fn DecompressData(compData: *const u8, compDataSize: s32, dataSize: *const s32) -> *const u8;
#foreign fn EncodeDataBase64(data: *const u8, dataSize: s32, outputSize: *const s32) -> *const u8;
#foreign fn DecodeDataBase64(data: *const u8, outputSize: *const s32) -> *const u8;
#foreign fn ComputeCRC32(data: *const u8, dataSize: s32) -> u32;
#foreign fn ComputeMD5(data: *const u8, dataSize: s32) -> *const u32;
#foreign fn ComputeSHA1(data: *const u8, dataSize: s32) -> *const u32;
#foreign fn LoadAutomationEventList(fileName: *const u8) -> AutomationEventList;
#foreign fn UnloadAutomationEventList(list: AutomationEventList) -> void;
#foreign fn ExportAutomationEventList(list: AutomationEventList, fileName: *const u8) -> bool;
#foreign fn SetAutomationEventList(list: *const AutomationEventList) -> void;
#foreign fn SetAutomationEventBaseFrame(frame: s32) -> void;
#foreign fn StartAutomationEventRecording() -> void;
#foreign fn StopAutomationEventRecording() -> void;
#foreign fn PlayAutomationEvent(event: AutomationEvent) -> void;
#foreign fn IsKeyPressed(key: s32) -> bool;
#foreign fn IsKeyPressedRepeat(key: s32) -> bool;
#foreign fn IsKeyDown(key: s32) -> bool;
#foreign fn IsKeyReleased(key: s32) -> bool;
#foreign fn IsKeyUp(key: s32) -> bool;
#foreign fn GetKeyPressed() -> s32;
#foreign fn GetCharPressed() -> s32;
#foreign fn GetKeyName(key: s32) -> *const u8;
#foreign fn SetExitKey(key: s32) -> void;
#foreign fn IsGamepadAvailable(gamepad: s32) -> bool;
#foreign fn GetGamepadName(gamepad: s32) -> *const u8;
#foreign fn IsGamepadButtonPressed(gamepad: s32, button: s32) -> bool;
#foreign fn IsGamepadButtonDown(gamepad: s32, button: s32) -> bool;
#foreign fn IsGamepadButtonReleased(gamepad: s32, button: s32) -> bool;
#foreign fn IsGamepadButtonUp(gamepad: s32, button: s32) -> bool;
#foreign fn GetGamepadButtonPressed() -> s32;
#foreign fn GetGamepadAxisCount(gamepad: s32) -> s32;
#foreign fn GetGamepadAxisMovement(gamepad: s32, axis: s32) -> f32;
#foreign fn SetGamepadMappings(mappings: *const u8) -> s32;
#foreign fn SetGamepadVibration(gamepad: s32, leftMotor: f32, rightMotor: f32, duration: f32) -> void;
#foreign fn IsMouseButtonPressed(button: s32) -> bool;
#foreign fn IsMouseButtonDown(button: s32) -> bool;
#foreign fn IsMouseButtonReleased(button: s32) -> bool;
#foreign fn IsMouseButtonUp(button: s32) -> bool;
#foreign fn GetMouseX() -> s32;
#foreign fn GetMouseY() -> s32;
#foreign fn GetMousePosition() -> Vector2;
#foreign fn GetMouseDelta() -> Vector2;
#foreign fn SetMousePosition(x: s32, y: s32) -> void;
#foreign fn SetMouseOffset(offsetX: s32, offsetY: s32) -> void;
#foreign fn SetMouseScale(scaleX: f32, scaleY: f32) -> void;
#foreign fn GetMouseWheelMove() -> f32;
#foreign fn GetMouseWheelMoveV() -> Vector2;
#foreign fn SetMouseCursor(cursor: s32) -> void;
#foreign fn GetTouchX() -> s32;
#foreign fn GetTouchY() -> s32;
#foreign fn GetTouchPosition(index: s32) -> Vector2;
#foreign fn GetTouchPointId(index: s32) -> s32;
#foreign fn GetTouchPointCount() -> s32;
#foreign fn SetGesturesEnabled(flags: u32) -> void;
#foreign fn IsGestureDetected(gesture: u32) -> bool;
#foreign fn GetGestureDetected() -> s32;
#foreign fn GetGestureHoldDuration() -> f32;
#foreign fn GetGestureDragVector() -> Vector2;
#foreign fn GetGestureDragAngle() -> f32;
#foreign fn GetGesturePinchVector() -> Vector2;
#foreign fn GetGesturePinchAngle() -> f32;
#foreign fn UpdateCamera(camera: *const Camera, mode: s32) -> void;
#foreign fn UpdateCameraPro(camera: *const Camera, movement: Vector3, rotation: Vector3, zoom: f32) -> void;
#foreign fn SetShapesTexture(texture: Texture2D, source: Rectangle) -> void;
#foreign fn GetShapesTexture() -> Texture2D;
#foreign fn GetShapesTextureRectangle() -> Rectangle;
#foreign fn DrawPixel(posX: s32, posY: s32, color: Color) -> void;
#foreign fn DrawPixelV(position: Vector2, color: Color) -> void;
#foreign fn DrawLine(startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color) -> void;
#foreign fn DrawLineV(startPos: Vector2, endPos: Vector2, color: Color) -> void;
#foreign fn DrawLineEx(startPos: Vector2, endPos: Vector2, thick: f32, color: Color) -> void;
#foreign fn DrawLineStrip(points: *const Vector2, pointCount: s32, color: Color) -> void;
#foreign fn DrawLineBezier(startPos: Vector2, endPos: Vector2, thick: f32, color: Color) -> void;
#foreign fn DrawCircle(centerX: s32, centerY: s32, radius: f32, color: Color) -> void;
#foreign fn DrawCircleSector(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
#foreign fn DrawCircleSectorLines(center: Vector2, radius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
#foreign fn DrawCircleGradient(centerX: s32, centerY: s32, radius: f32, inner: Color, outer: Color) -> void;
#foreign fn DrawCircleV(center: Vector2, radius: f32, color: Color) -> void;
#foreign fn DrawCircleLines(centerX: s32, centerY: s32, radius: f32, color: Color) -> void;
#foreign fn DrawCircleLinesV(center: Vector2, radius: f32, color: Color) -> void;
#foreign fn DrawEllipse(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color) -> void;
#foreign fn DrawEllipseLines(centerX: s32, centerY: s32, radiusH: f32, radiusV: f32, color: Color) -> void;
#foreign fn DrawRing(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
#foreign fn DrawRingLines(center: Vector2, innerRadius: f32, outerRadius: f32, startAngle: f32, endAngle: f32, segments: s32, color: Color) -> void;
#foreign fn DrawRectangle(posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
#foreign fn DrawRectangleV(position: Vector2, size: Vector2, color: Color) -> void;
#foreign fn DrawRectangleRec(rec: Rectangle, color: Color) -> void;
#foreign fn DrawRectanglePro(rec: Rectangle, origin: Vector2, rotation: f32, color: Color) -> void;
#foreign fn DrawRectangleGradientV(posX: s32, posY: s32, width: s32, height: s32, top: Color, bottom: Color) -> void;
#foreign fn DrawRectangleGradientH(posX: s32, posY: s32, width: s32, height: s32, left: Color, right: Color) -> void;
#foreign fn DrawRectangleGradientEx(rec: Rectangle, topLeft: Color, bottomLeft: Color, topRight: Color, bottomRight: Color) -> void;
#foreign fn DrawRectangleLines(posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
#foreign fn DrawRectangleLinesEx(rec: Rectangle, lineThick: f32, color: Color) -> void;
#foreign fn DrawRectangleRounded(rec: Rectangle, roundness: f32, segments: s32, color: Color) -> void;
#foreign fn DrawRectangleRoundedLines(rec: Rectangle, roundness: f32, segments: s32, color: Color) -> void;
#foreign fn DrawRectangleRoundedLinesEx(rec: Rectangle, roundness: f32, segments: s32, lineThick: f32, color: Color) -> void;
#foreign fn DrawTriangle(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign fn DrawTriangleLines(v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign fn DrawTriangleFan(points: *const Vector2, pointCount: s32, color: Color) -> void;
#foreign fn DrawTriangleStrip(points: *const Vector2, pointCount: s32, color: Color) -> void;
#foreign fn DrawPoly(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color) -> void;
#foreign fn DrawPolyLines(center: Vector2, sides: s32, radius: f32, rotation: f32, color: Color) -> void;
#foreign fn DrawPolyLinesEx(center: Vector2, sides: s32, radius: f32, rotation: f32, lineThick: f32, color: Color) -> void;
#foreign fn DrawSplineLinear(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
#foreign fn DrawSplineBasis(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
#foreign fn DrawSplineCatmullRom(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
#foreign fn DrawSplineBezierQuadratic(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
#foreign fn DrawSplineBezierCubic(points: *const Vector2, pointCount: s32, thick: f32, color: Color) -> void;
#foreign fn DrawSplineSegmentLinear(p1: Vector2, p2: Vector2, thick: f32, color: Color) -> void;
#foreign fn DrawSplineSegmentBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color) -> void;
#foreign fn DrawSplineSegmentCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, thick: f32, color: Color) -> void;
#foreign fn DrawSplineSegmentBezierQuadratic(p1: Vector2, c2: Vector2, p3: Vector2, thick: f32, color: Color) -> void;
#foreign fn DrawSplineSegmentBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, thick: f32, color: Color) -> void;
#foreign fn GetSplinePointLinear(startPos: Vector2, endPos: Vector2, t: f32) -> Vector2;
#foreign fn GetSplinePointBasis(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) -> Vector2;
#foreign fn GetSplinePointCatmullRom(p1: Vector2, p2: Vector2, p3: Vector2, p4: Vector2, t: f32) -> Vector2;
#foreign fn GetSplinePointBezierQuad(p1: Vector2, c2: Vector2, p3: Vector2, t: f32) -> Vector2;
#foreign fn GetSplinePointBezierCubic(p1: Vector2, c2: Vector2, c3: Vector2, p4: Vector2, t: f32) -> Vector2;
#foreign fn CheckCollisionRecs(rec1: Rectangle, rec2: Rectangle) -> bool;
#foreign fn CheckCollisionCircles(center1: Vector2, radius1: f32, center2: Vector2, radius2: f32) -> bool;
#foreign fn CheckCollisionCircleRec(center: Vector2, radius: f32, rec: Rectangle) -> bool;
#foreign fn CheckCollisionCircleLine(center: Vector2, radius: f32, p1: Vector2, p2: Vector2) -> bool;
#foreign fn CheckCollisionPointRec(point: Vector2, rec: Rectangle) -> bool;
#foreign fn CheckCollisionPointCircle(point: Vector2, center: Vector2, radius: f32) -> bool;
#foreign fn CheckCollisionPointTriangle(point: Vector2, p1: Vector2, p2: Vector2, p3: Vector2) -> bool;
#foreign fn CheckCollisionPointLine(point: Vector2, p1: Vector2, p2: Vector2, threshold: s32) -> bool;
#foreign fn CheckCollisionPointPoly(point: Vector2, points: *const Vector2, pointCount: s32) -> bool;
#foreign fn CheckCollisionLines(startPos1: Vector2, endPos1: Vector2, startPos2: Vector2, endPos2: Vector2, collisionPoint: *const Vector2) -> bool;
#foreign fn GetCollisionRec(rec1: Rectangle, rec2: Rectangle) -> Rectangle;
#foreign fn LoadImage(fileName: *const u8) -> Image;
#foreign fn LoadImageRaw(fileName: *const u8, width: s32, height: s32, format: s32, headerSize: s32) -> Image;
#foreign fn LoadImageAnim(fileName: *const u8, frames: *const s32) -> Image;
#foreign fn LoadImageAnimFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32, frames: *const s32) -> Image;
#foreign fn LoadImageFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32) -> Image;
#foreign fn LoadImageFromTexture(texture: Texture2D) -> Image;
#foreign fn LoadImageFromScreen() -> Image;
#foreign fn IsImageValid(image: Image) -> bool;
#foreign fn UnloadImage(image: Image) -> void;
#foreign fn ExportImage(image: Image, fileName: *const u8) -> bool;
#foreign fn ExportImageToMemory(image: Image, fileType: *const u8, fileSize: *const s32) -> *const u8;
#foreign fn ExportImageAsCode(image: Image, fileName: *const u8) -> bool;
#foreign fn GenImageColor(width: s32, height: s32, color: Color) -> Image;
#foreign fn GenImageGradientLinear(width: s32, height: s32, direction: s32, start: Color, end: Color) -> Image;
#foreign fn GenImageGradientRadial(width: s32, height: s32, density: f32, inner: Color, outer: Color) -> Image;
#foreign fn GenImageGradientSquare(width: s32, height: s32, density: f32, inner: Color, outer: Color) -> Image;
#foreign fn GenImageChecked(width: s32, height: s32, checksX: s32, checksY: s32, col1: Color, col2: Color) -> Image;
#foreign fn GenImageWhiteNoise(width: s32, height: s32, factor: f32) -> Image;
#foreign fn GenImagePerlinNoise(width: s32, height: s32, offsetX: s32, offsetY: s32, scale: f32) -> Image;
#foreign fn GenImageCellular(width: s32, height: s32, tileSize: s32) -> Image;
#foreign fn GenImageText(width: s32, height: s32, text: *const u8) -> Image;
#foreign fn ImageCopy(image: Image) -> Image;
#foreign fn ImageFromImage(image: Image, rec: Rectangle) -> Image;
#foreign fn ImageFromChannel(image: Image, selectedChannel: s32) -> Image;
#foreign fn ImageText(text: *const u8, fontSize: s32, color: Color) -> Image;
#foreign fn ImageTextEx(font: Font, text: *const u8, fontSize: f32, spacing: f32, tint: Color) -> Image;
#foreign fn ImageFormat(image: *const Image, newFormat: s32) -> void;
#foreign fn ImageToPOT(image: *const Image, fill: Color) -> void;
#foreign fn ImageCrop(image: *const Image, crop: Rectangle) -> void;
#foreign fn ImageAlphaCrop(image: *const Image, threshold: f32) -> void;
#foreign fn ImageAlphaClear(image: *const Image, color: Color, threshold: f32) -> void;
#foreign fn ImageAlphaMask(image: *const Image, alphaMask: Image) -> void;
#foreign fn ImageAlphaPremultiply(image: *const Image) -> void;
#foreign fn ImageBlurGaussian(image: *const Image, blurSize: s32) -> void;
#foreign fn ImageKernelConvolution(image: *const Image, kernel: *const f32, kernelSize: s32) -> void;
#foreign fn ImageResize(image: *const Image, newWidth: s32, newHeight: s32) -> void;
#foreign fn ImageResizeNN(image: *const Image, newWidth: s32, newHeight: s32) -> void;
#foreign fn ImageResizeCanvas(image: *const Image, newWidth: s32, newHeight: s32, offsetX: s32, offsetY: s32, fill: Color) -> void;
#foreign fn ImageMipmaps(image: *const Image) -> void;
#foreign fn ImageDither(image: *const Image, rBpp: s32, gBpp: s32, bBpp: s32, aBpp: s32) -> void;
#foreign fn ImageFlipVertical(image: *const Image) -> void;
#foreign fn ImageFlipHorizontal(image: *const Image) -> void;
#foreign fn ImageRotate(image: *const Image, degrees: s32) -> void;
#foreign fn ImageRotateCW(image: *const Image) -> void;
#foreign fn ImageRotateCCW(image: *const Image) -> void;
#foreign fn ImageColorTint(image: *const Image, color: Color) -> void;
#foreign fn ImageColorInvert(image: *const Image) -> void;
#foreign fn ImageColorGrayscale(image: *const Image) -> void;
#foreign fn ImageColorContrast(image: *const Image, contrast: f32) -> void;
#foreign fn ImageColorBrightness(image: *const Image, brightness: s32) -> void;
#foreign fn ImageColorReplace(image: *const Image, color: Color, replace: Color) -> void;
#foreign fn LoadImageColors(image: Image) -> *const Color;
#foreign fn LoadImagePalette(image: Image, maxPaletteSize: s32, colorCount: *const s32) -> *const Color;
#foreign fn UnloadImageColors(colors: *const Color) -> void;
#foreign fn UnloadImagePalette(colors: *const Color) -> void;
#foreign fn GetImageAlphaBorder(image: Image, threshold: f32) -> Rectangle;
#foreign fn GetImageColor(image: Image, x: s32, y: s32) -> Color;
#foreign fn ImageClearBackground(dst: *const Image, color: Color) -> void;
#foreign fn ImageDrawPixel(dst: *const Image, posX: s32, posY: s32, color: Color) -> void;
#foreign fn ImageDrawPixelV(dst: *const Image, position: Vector2, color: Color) -> void;
#foreign fn ImageDrawLine(dst: *const Image, startPosX: s32, startPosY: s32, endPosX: s32, endPosY: s32, color: Color) -> void;
#foreign fn ImageDrawLineV(dst: *const Image, start: Vector2, end: Vector2, color: Color) -> void;
#foreign fn ImageDrawLineEx(dst: *const Image, start: Vector2, end: Vector2, thick: s32, color: Color) -> void;
#foreign fn ImageDrawCircle(dst: *const Image, centerX: s32, centerY: s32, radius: s32, color: Color) -> void;
#foreign fn ImageDrawCircleV(dst: *const Image, center: Vector2, radius: s32, color: Color) -> void;
#foreign fn ImageDrawCircleLines(dst: *const Image, centerX: s32, centerY: s32, radius: s32, color: Color) -> void;
#foreign fn ImageDrawCircleLinesV(dst: *const Image, center: Vector2, radius: s32, color: Color) -> void;
#foreign fn ImageDrawRectangle(dst: *const Image, posX: s32, posY: s32, width: s32, height: s32, color: Color) -> void;
#foreign fn ImageDrawRectangleV(dst: *const Image, position: Vector2, size: Vector2, color: Color) -> void;
#foreign fn ImageDrawRectangleRec(dst: *const Image, rec: Rectangle, color: Color) -> void;
#foreign fn ImageDrawRectangleLines(dst: *const Image, rec: Rectangle, thick: s32, color: Color) -> void;
#foreign fn ImageDrawTriangle(dst: *const Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign fn ImageDrawTriangleEx(dst: *const Image, v1: Vector2, v2: Vector2, v3: Vector2, c1: Color, c2: Color, c3: Color) -> void;
#foreign fn ImageDrawTriangleLines(dst: *const Image, v1: Vector2, v2: Vector2, v3: Vector2, color: Color) -> void;
#foreign fn ImageDrawTriangleFan(dst: *const Image, points: *const Vector2, pointCount: s32, color: Color) -> void;
#foreign fn ImageDrawTriangleStrip(dst: *const Image, points: *const Vector2, pointCount: s32, color: Color) -> void;
#foreign fn ImageDraw(dst: *const Image, src: Image, srcRec: Rectangle, dstRec: Rectangle, tint: Color) -> void;
#foreign fn ImageDrawText(dst: *const Image, text: *const u8, posX: s32, posY: s32, fontSize: s32, color: Color) -> void;
#foreign fn ImageDrawTextEx(dst: *const Image, font: Font, text: *const u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void;
#foreign fn LoadTexture(fileName: *const u8) -> Texture2D;
#foreign fn LoadTextureFromImage(image: Image) -> Texture2D;
#foreign fn LoadTextureCubemap(image: Image, layout: s32) -> TextureCubemap;
#foreign fn LoadRenderTexture(width: s32, height: s32) -> RenderTexture2D;
#foreign fn IsTextureValid(texture: Texture2D) -> bool;
#foreign fn UnloadTexture(texture: Texture2D) -> void;
#foreign fn IsRenderTextureValid(target: RenderTexture2D) -> bool;
#foreign fn UnloadRenderTexture(target: RenderTexture2D) -> void;
#foreign fn UpdateTexture(texture: Texture2D, pixels: *const void) -> void;
#foreign fn UpdateTextureRec(texture: Texture2D, rec: Rectangle, pixels: *const void) -> void;
#foreign fn GenTextureMipmaps(texture: *const Texture2D) -> void;
#foreign fn SetTextureFilter(texture: Texture2D, filter: s32) -> void;
#foreign fn SetTextureWrap(texture: Texture2D, wrap: s32) -> void;
#foreign fn DrawTexture(texture: Texture2D, posX: s32, posY: s32, tint: Color) -> void;
#foreign fn DrawTextureV(texture: Texture2D, position: Vector2, tint: Color) -> void;
#foreign fn DrawTextureEx(texture: Texture2D, position: Vector2, rotation: f32, scale: f32, tint: Color) -> void;
#foreign fn DrawTextureRec(texture: Texture2D, source: Rectangle, position: Vector2, tint: Color) -> void;
#foreign fn DrawTexturePro(texture: Texture2D, source: Rectangle, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) -> void;
#foreign fn DrawTextureNPatch(texture: Texture2D, nPatchInfo: NPatchInfo, dest: Rectangle, origin: Vector2, rotation: f32, tint: Color) -> void;
#foreign fn ColorIsEqual(col1: Color, col2: Color) -> bool;
#foreign fn Fade(color: Color, alpha: f32) -> Color;
#foreign fn ColorToInt(color: Color) -> s32;
#foreign fn ColorNormalize(color: Color) -> Vector4;
#foreign fn ColorFromNormalized(normalized: Vector4) -> Color;
#foreign fn ColorToHSV(color: Color) -> Vector3;
#foreign fn ColorFromHSV(hue: f32, saturation: f32, value: f32) -> Color;
#foreign fn ColorTint(color: Color, tint: Color) -> Color;
#foreign fn ColorBrightness(color: Color, factor: f32) -> Color;
#foreign fn ColorContrast(color: Color, contrast: f32) -> Color;
#foreign fn ColorAlpha(color: Color, alpha: f32) -> Color;
#foreign fn ColorAlphaBlend(dst: Color, src: Color, tint: Color) -> Color;
#foreign fn ColorLerp(color1: Color, color2: Color, factor: f32) -> Color;
#foreign fn GetColor(hexValue: u32) -> Color;
#foreign fn GetPixelColor(srcPtr: *const void, format: s32) -> Color;
#foreign fn SetPixelColor(dstPtr: *const void, color: Color, format: s32) -> void;
#foreign fn GetPixelDataSize(width: s32, height: s32, format: s32) -> s32;
#foreign fn GetFontDefault() -> Font;
#foreign fn LoadFont(fileName: *const u8) -> Font;
#foreign fn LoadFontEx(fileName: *const u8, fontSize: s32, codepoints: *const s32, codepointCount: s32) -> Font;
#foreign fn LoadFontFromImage(image: Image, key: Color, firstChar: s32) -> Font;
#foreign fn LoadFontFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32, fontSize: s32, codepoints: *const s32, codepointCount: s32) -> Font;
#foreign fn IsFontValid(font: Font) -> bool;
#foreign fn LoadFontData(fileData: *const u8, dataSize: s32, fontSize: s32, codepoints: *const s32, codepointCount: s32, type: s32) -> *const GlyphInfo;
#foreign fn GenImageFontAtlas(glyphs: *const GlyphInfo, glyphRecs: *const *const Rectangle, glyphCount: s32, fontSize: s32, padding: s32, packMethod: s32) -> Image;
#foreign fn UnloadFontData(glyphs: *const GlyphInfo, glyphCount: s32) -> void;
#foreign fn UnloadFont(font: Font) -> void;
#foreign fn ExportFontAsCode(font: Font, fileName: *const u8) -> bool;
#foreign fn DrawFPS(posX: s32, posY: s32) -> void;
#foreign fn DrawText(text: *const u8, posX: s32, posY: s32, fontSize: s32, color: Color) -> void;
#foreign fn DrawTextEx(font: Font, text: *const u8, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void;
#foreign fn DrawTextPro(font: Font, text: *const u8, position: Vector2, origin: Vector2, rotation: f32, fontSize: f32, spacing: f32, tint: Color) -> void;
#foreign fn DrawTextCodepoint(font: Font, codepoint: s32, position: Vector2, fontSize: f32, tint: Color) -> void;
#foreign fn DrawTextCodepoints(font: Font, codepoints: *const s32, codepointCount: s32, position: Vector2, fontSize: f32, spacing: f32, tint: Color) -> void;
#foreign fn SetTextLineSpacing(spacing: s32) -> void;
#foreign fn MeasureText(text: *const u8, fontSize: s32) -> s32;
#foreign fn MeasureTextEx(font: Font, text: *const u8, fontSize: f32, spacing: f32) -> Vector2;
#foreign fn GetGlyphIndex(font: Font, codepoint: s32) -> s32;
#foreign fn GetGlyphInfo(font: Font, codepoint: s32) -> GlyphInfo;
#foreign fn GetGlyphAtlasRec(font: Font, codepoint: s32) -> Rectangle;
#foreign fn LoadUTF8(codepoints: *const s32, length: s32) -> *const u8;
#foreign fn UnloadUTF8(text: *const u8) -> void;
#foreign fn LoadCodepoints(text: *const u8, count: *const s32) -> *const s32;
#foreign fn UnloadCodepoints(codepoints: *const s32) -> void;
#foreign fn GetCodepointCount(text: *const u8) -> s32;
#foreign fn GetCodepoint(text: *const u8, codepointSize: *const s32) -> s32;
#foreign fn GetCodepointNext(text: *const u8, codepointSize: *const s32) -> s32;
#foreign fn GetCodepointPrevious(text: *const u8, codepointSize: *const s32) -> s32;
#foreign fn CodepointToUTF8(codepoint: s32, utf8Size: *const s32) -> *const u8;
#foreign fn TextCopy(dst: *const u8, src: *const u8) -> s32;
#foreign fn TextIsEqual(text1: *const u8, text2: *const u8) -> bool;
#foreign fn TextLength(text: *const u8) -> u32;
#foreign fn TextFormat(text: *const u8) -> *const u8;
#foreign fn TextSubtext(text: *const u8, position: s32, length: s32) -> *const u8;
#foreign fn TextReplace(text: *const u8, replace: *const u8, by: *const u8) -> *const u8;
#foreign fn TextInsert(text: *const u8, insert: *const u8, position: s32) -> *const u8;
#foreign fn TextJoin(textList: *const *const u8, count: s32, delimiter: *const u8) -> *const u8;
#foreign fn TextSplit(text: *const u8, delimiter: u8, count: *const s32) -> *const *const u8;
#foreign fn TextAppend(text: *const u8, append: *const u8, position: *const s32) -> void;
#foreign fn TextFindIndex(text: *const u8, find: *const u8) -> s32;
#foreign fn TextToUpper(text: *const u8) -> *const u8;
#foreign fn TextToLower(text: *const u8) -> *const u8;
#foreign fn TextToPascal(text: *const u8) -> *const u8;
#foreign fn TextToSnake(text: *const u8) -> *const u8;
#foreign fn TextToCamel(text: *const u8) -> *const u8;
#foreign fn TextToInteger(text: *const u8) -> s32;
#foreign fn TextToFloat(text: *const u8) -> f32;
#foreign fn DrawLine3D(startPos: Vector3, endPos: Vector3, color: Color) -> void;
#foreign fn DrawPoint3D(position: Vector3, color: Color) -> void;
#foreign fn DrawCircle3D(center: Vector3, radius: f32, rotationAxis: Vector3, rotationAngle: f32, color: Color) -> void;
#foreign fn DrawTriangle3D(v1: Vector3, v2: Vector3, v3: Vector3, color: Color) -> void;
#foreign fn DrawTriangleStrip3D(points: *const Vector3, pointCount: s32, color: Color) -> void;
#foreign fn DrawCube(position: Vector3, width: f32, height: f32, length: f32, color: Color) -> void;
#foreign fn DrawCubeV(position: Vector3, size: Vector3, color: Color) -> void;
#foreign fn DrawCubeWires(position: Vector3, width: f32, height: f32, length: f32, color: Color) -> void;
#foreign fn DrawCubeWiresV(position: Vector3, size: Vector3, color: Color) -> void;
#foreign fn DrawSphere(centerPos: Vector3, radius: f32, color: Color) -> void;
#foreign fn DrawSphereEx(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color) -> void;
#foreign fn DrawSphereWires(centerPos: Vector3, radius: f32, rings: s32, slices: s32, color: Color) -> void;
#foreign fn DrawCylinder(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color) -> void;
#foreign fn DrawCylinderEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color) -> void;
#foreign fn DrawCylinderWires(position: Vector3, radiusTop: f32, radiusBottom: f32, height: f32, slices: s32, color: Color) -> void;
#foreign fn DrawCylinderWiresEx(startPos: Vector3, endPos: Vector3, startRadius: f32, endRadius: f32, sides: s32, color: Color) -> void;
#foreign fn DrawCapsule(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color) -> void;
#foreign fn DrawCapsuleWires(startPos: Vector3, endPos: Vector3, radius: f32, slices: s32, rings: s32, color: Color) -> void;
#foreign fn DrawPlane(centerPos: Vector3, size: Vector2, color: Color) -> void;
#foreign fn DrawRay(ray: Ray, color: Color) -> void;
#foreign fn DrawGrid(slices: s32, spacing: f32) -> void;
#foreign fn LoadModel(fileName: *const u8) -> Model;
#foreign fn LoadModelFromMesh(mesh: Mesh) -> Model;
#foreign fn IsModelValid(model: Model) -> bool;
#foreign fn UnloadModel(model: Model) -> void;
#foreign fn GetModelBoundingBox(model: Model) -> BoundingBox;
#foreign fn DrawModel(model: Model, position: Vector3, scale: f32, tint: Color) -> void;
#foreign fn DrawModelEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void;
#foreign fn DrawModelWires(model: Model, position: Vector3, scale: f32, tint: Color) -> void;
#foreign fn DrawModelWiresEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void;
#foreign fn DrawModelPoints(model: Model, position: Vector3, scale: f32, tint: Color) -> void;
#foreign fn DrawModelPointsEx(model: Model, position: Vector3, rotationAxis: Vector3, rotationAngle: f32, scale: Vector3, tint: Color) -> void;
#foreign fn DrawBoundingBox(box: BoundingBox, color: Color) -> void;
#foreign fn DrawBillboard(camera: Camera, texture: Texture2D, position: Vector3, scale: f32, tint: Color) -> void;
#foreign fn DrawBillboardRec(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, size: Vector2, tint: Color) -> void;
#foreign fn DrawBillboardPro(camera: Camera, texture: Texture2D, source: Rectangle, position: Vector3, up: Vector3, size: Vector2, origin: Vector2, rotation: f32, tint: Color) -> void;
#foreign fn UploadMesh(mesh: *const Mesh, dynamic: bool) -> void;
#foreign fn UpdateMeshBuffer(mesh: Mesh, index: s32, data: *const void, dataSize: s32, offset: s32) -> void;
#foreign fn UnloadMesh(mesh: Mesh) -> void;
#foreign fn DrawMesh(mesh: Mesh, material: Material, transform: Matrix) -> void;
#foreign fn DrawMeshInstanced(mesh: Mesh, material: Material, transforms: *const Matrix, instances: s32) -> void;
#foreign fn GetMeshBoundingBox(mesh: Mesh) -> BoundingBox;
#foreign fn GenMeshTangents(mesh: *const Mesh) -> void;
#foreign fn ExportMesh(mesh: Mesh, fileName: *const u8) -> bool;
#foreign fn ExportMeshAsCode(mesh: Mesh, fileName: *const u8) -> bool;
#foreign fn GenMeshPoly(sides: s32, radius: f32) -> Mesh;
#foreign fn GenMeshPlane(width: f32, length: f32, resX: s32, resZ: s32) -> Mesh;
#foreign fn GenMeshCube(width: f32, height: f32, length: f32) -> Mesh;
#foreign fn GenMeshSphere(radius: f32, rings: s32, slices: s32) -> Mesh;
#foreign fn GenMeshHemiSphere(radius: f32, rings: s32, slices: s32) -> Mesh;
#foreign fn GenMeshCylinder(radius: f32, height: f32, slices: s32) -> Mesh;
#foreign fn GenMeshCone(radius: f32, height: f32, slices: s32) -> Mesh;
#foreign fn GenMeshTorus(radius: f32, size: f32, radSeg: s32, sides: s32) -> Mesh;
#foreign fn GenMeshKnot(radius: f32, size: f32, radSeg: s32, sides: s32) -> Mesh;
#foreign fn GenMeshHeightmap(heightmap: Image, size: Vector3) -> Mesh;
#foreign fn GenMeshCubicmap(cubicmap: Image, cubeSize: Vector3) -> Mesh;
#foreign fn LoadMaterials(fileName: *const u8, materialCount: *const s32) -> *const Material;
#foreign fn LoadMaterialDefault() -> Material;
#foreign fn IsMaterialValid(material: Material) -> bool;
#foreign fn UnloadMaterial(material: Material) -> void;
#foreign fn SetMaterialTexture(material: *const Material, mapType: s32, texture: Texture2D) -> void;
#foreign fn SetModelMeshMaterial(model: *const Model, meshId: s32, materialId: s32) -> void;
#foreign fn LoadModelAnimations(fileName: *const u8, animCount: *const s32) -> *const ModelAnimation;
#foreign fn UpdateModelAnimation(model: Model, anim: ModelAnimation, frame: s32) -> void;
#foreign fn UpdateModelAnimationBones(model: Model, anim: ModelAnimation, frame: s32) -> void;
#foreign fn UnloadModelAnimation(anim: ModelAnimation) -> void;
#foreign fn UnloadModelAnimations(animations: *const ModelAnimation, animCount: s32) -> void;
#foreign fn IsModelAnimationValid(model: Model, anim: ModelAnimation) -> bool;
#foreign fn CheckCollisionSpheres(center1: Vector3, radius1: f32, center2: Vector3, radius2: f32) -> bool;
#foreign fn CheckCollisionBoxes(box1: BoundingBox, box2: BoundingBox) -> bool;
#foreign fn CheckCollisionBoxSphere(box: BoundingBox, center: Vector3, radius: f32) -> bool;
#foreign fn GetRayCollisionSphere(ray: Ray, center: Vector3, radius: f32) -> RayCollision;
#foreign fn GetRayCollisionBox(ray: Ray, box: BoundingBox) -> RayCollision;
#foreign fn GetRayCollisionMesh(ray: Ray, mesh: Mesh, transform: Matrix) -> RayCollision;
#foreign fn GetRayCollisionTriangle(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3) -> RayCollision;
#foreign fn GetRayCollisionQuad(ray: Ray, p1: Vector3, p2: Vector3, p3: Vector3, p4: Vector3) -> RayCollision;
alias AudioCallback :: fn*(*const void, u32) -> void;
#foreign fn InitAudioDevice() -> void;
#foreign fn CloseAudioDevice() -> void;
#foreign fn IsAudioDeviceReady() -> bool;
#foreign fn SetMasterVolume(volume: f32) -> void;
#foreign fn GetMasterVolume() -> f32;
#foreign fn LoadWave(fileName: *const u8) -> Wave;
#foreign fn LoadWaveFromMemory(fileType: *const u8, fileData: *const u8, dataSize: s32) -> Wave;
#foreign fn IsWaveValid(wave: Wave) -> bool;
#foreign fn LoadSound(fileName: *const u8) -> Sound;
#foreign fn LoadSoundFromWave(wave: Wave) -> Sound;
#foreign fn LoadSoundAlias(source: Sound) -> Sound;
#foreign fn IsSoundValid(sound: Sound) -> bool;
#foreign fn UpdateSound(sound: Sound, data: *const void, sampleCount: s32) -> void;
#foreign fn UnloadWave(wave: Wave) -> void;
#foreign fn UnloadSound(sound: Sound) -> void;
#foreign fn UnloadSoundAlias(_alias: Sound) -> void;
#foreign fn ExportWave(wave: Wave, fileName: *const u8) -> bool;
#foreign fn ExportWaveAsCode(wave: Wave, fileName: *const u8) -> bool;
#foreign fn PlaySound(sound: Sound) -> void;
#foreign fn StopSound(sound: Sound) -> void;
#foreign fn PauseSound(sound: Sound) -> void;
#foreign fn ResumeSound(sound: Sound) -> void;
#foreign fn IsSoundPlaying(sound: Sound) -> bool;
#foreign fn SetSoundVolume(sound: Sound, volume: f32) -> void;
#foreign fn SetSoundPitch(sound: Sound, pitch: f32) -> void;
#foreign fn SetSoundPan(sound: Sound, pan: f32) -> void;
#foreign fn WaveCopy(wave: Wave) -> Wave;
#foreign fn WaveCrop(wave: *const Wave, initFrame: s32, finalFrame: s32) -> void;
#foreign fn WaveFormat(wave: *const Wave, sampleRate: s32, sampleSize: s32, channels: s32) -> void;
#foreign fn LoadWaveSamples(wave: Wave) -> *const f32;
#foreign fn UnloadWaveSamples(samples: *const f32) -> void;
#foreign fn LoadMusicStream(fileName: *const u8) -> Music;
#foreign fn LoadMusicStreamFromMemory(fileType: *const u8, data: *const u8, dataSize: s32) -> Music;
#foreign fn IsMusicValid(music: Music) -> bool;
#foreign fn UnloadMusicStream(music: Music) -> void;
#foreign fn PlayMusicStream(music: Music) -> void;
#foreign fn IsMusicStreamPlaying(music: Music) -> bool;
#foreign fn UpdateMusicStream(music: Music) -> void;
#foreign fn StopMusicStream(music: Music) -> void;
#foreign fn PauseMusicStream(music: Music) -> void;
#foreign fn ResumeMusicStream(music: Music) -> void;
#foreign fn SeekMusicStream(music: Music, position: f32) -> void;
#foreign fn SetMusicVolume(music: Music, volume: f32) -> void;
#foreign fn SetMusicPitch(music: Music, pitch: f32) -> void;
#foreign fn SetMusicPan(music: Music, pan: f32) -> void;
#foreign fn GetMusicTimeLength(music: Music) -> f32;
#foreign fn GetMusicTimePlayed(music: Music) -> f32;
#foreign fn LoadAudioStream(sampleRate: u32, sampleSize: u32, channels: u32) -> AudioStream;
#foreign fn IsAudioStreamValid(stream: AudioStream) -> bool;
#foreign fn UnloadAudioStream(stream: AudioStream) -> void;
#foreign fn UpdateAudioStream(stream: AudioStream, data: *const void, frameCount: s32) -> void;
#foreign fn IsAudioStreamProcessed(stream: AudioStream) -> bool;
#foreign fn PlayAudioStream(stream: AudioStream) -> void;
#foreign fn PauseAudioStream(stream: AudioStream) -> void;
#foreign fn ResumeAudioStream(stream: AudioStream) -> void;
#foreign fn IsAudioStreamPlaying(stream: AudioStream) -> bool;
#foreign fn StopAudioStream(stream: AudioStream) -> void;
#foreign fn SetAudioStreamVolume(stream: AudioStream, volume: f32) -> void;
#foreign fn SetAudioStreamPitch(stream: AudioStream, pitch: f32) -> void;
#foreign fn SetAudioStreamPan(stream: AudioStream, pan: f32) -> void;
#foreign fn SetAudioStreamBufferSizeDefault(size: s32) -> void;
#foreign fn SetAudioStreamCallback(stream: AudioStream, callback: AudioCallback) -> void;
#foreign fn AttachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback) -> void;
#foreign fn DetachAudioStreamProcessor(stream: AudioStream, processor: AudioCallback) -> void;
#foreign fn AttachAudioMixedProcessor(processor: AudioCallback) -> void;
#foreign fn DetachAudioMixedProcessor(processor: AudioCallback) -> void;


#foreign fn rlSetClipPlanes(near: f64, far: f64);