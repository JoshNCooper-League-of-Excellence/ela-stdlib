import raylib::*;
import fmt::*;
// * used for UI styling.
struct Style {
  foreground:           Color = WHITE,
  background:           Color = BLACK,
  highlighted:          Color = ORANGE,

  line_thickness:       f32 = 2,

  // Text stuff.
  font_size:            s32 = 16,
  font_spacing:         f32 = 1,
  font_color_override:  Option!<Color> = Some(GRAY),
  font:                 Font = GetFontDefault(),
}

impl Style {
  fn default() -> Style {
    return .{
      foreground: WHITE,
      background: BLACK,
      highlighted: ORANGE,
      font_color_override: Some(GRAY),
      font_size: 16,
      line_thickness: 2,
      font: GetFontDefault(),
    };
  }
}

fn draw_textf!<Tuple>(fmt: str, tuple: Tuple, position: Vector2, style: Style, format_options: FormatOptions = FormatOptions::default()) where Tuple: IsTuple {
  text := format(fmt, tuple, format_options);
  defer {
    text.deinit();
  }

  DrawTextEx(
    style.font, 
    text.data,
    position, 
    style.font_size, 
    style.font_spacing, 
    style.font_color_override.or_else(style.foreground)
  );
}

fn draw_text!<Data>(text: Data, position: Vector2, style: Style) where Data: AsByteSlice {
  DrawTextEx(
    style.font, 
    text.as_byte_slice().data, 
    position, 
    style.font_size, 
    style.font_spacing, 
    style.font_color_override.or_else(style.foreground)
  );
}

// for drawing a single char. useful for custom text layouts.
fn draw_character(char: u8, position: Vector2, style: Style) {
  temp : u8[2] = .[char, '\0' as u8];
  slice := Slice!<u8>.{data: temp, length: 1};
  draw_text!<Slice!<u8>>(slice, position, style);
}

// * Measure the width of a jiggly text of 'text' and 'style'
@[inline]
fn measure_jiggly_text!<Data>(text: Data, style: Style) -> f32 where Data: AsByteSlice {
  slice := text.as_byte_slice();
  if slice.length == 0 then return 0.0;
  mut total_width: f32 = 0.0;
  for i in 0 as u64..slice.length {
    total_width += style.font_size;
  }
  return total_width;
}

// * Draw wavy jiggly text.
@[inline]
fn jiggly_text!<Data>(
  data: Data, 
  rect: Rectangle, 
  style: Style,
  jiggle_intensity: f32 = 1.0, 
  jiggle_rate: f32 = 1.0
) where Data: AsByteSlice {
  time: f32 = GetTime() as f32;
  text := data.as_byte_slice();

  for i in 0..text.length {
    pos_x: s32 = (rect.x + (i * style.font_size) as f32) as s32;
    pos_y: s32 = (rect.y + jiggle_intensity * sin(jiggle_rate * time + (i as f32))) as s32;
    draw_character(text.data[i], pos_x, pos_y, style);
  }
}

// * Draw a button with that returns true for clicked, false for not clicked.
@[inline]
fn button!<Data>(text: Data, rect: Rectangle, style: Style) -> bool where Data: AsByteSlice {
  text_bytes := text.as_byte_slice();

  mut position: Vector2 = .{
    x: rect.x,
    y: rect.y
  };

  mut size: Vector2 = .{
    x: rect.width,
    y: rect.height
  };

  mut text_width : f32;
  
  text_width = MeasureText(text_bytes.data, style.font_size);

  text_height : f32 = style.font_size;
  if text_width > rect.width {
    size.x = text_width;
    position.x = rect.x - (text_width - rect.width) / 2;
  }

  new_rect : Rectangle = .{
    x: position.x,
    y: position.y,
    width: size.x,
    height: size.y
  };

  mouse_over := CheckCollisionPointRec(GetMousePosition(), new_rect);

  if mouse_over {
    DrawRectangleV(position, size, style.highlighted);
    if (IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT)) then return true;
  } else {
    DrawRectangleV(position, size, style.background);
  }

  text_position: Vector2 = .{
    x: position.x + (size.x - text_width) / 2,
    y: position.y + (size.y - text_height) / 2,
  };

  draw_text(text, text_position, style);

  return false;
}

// * Draw a button with a click callback.
// * T* in the callback is a pointer to some of your state data, if you want to mutate it.
// * use 'button' if you don't want the callback system, or pass 'null, null' as the last two arguments.
@[inline]
fn button_pro!<Data, T>(text: Data, rect: Rectangle, style: Style, callback: fn* (*mut T), user_arg : *mut T) where Data: AsByteSlice {
  if button(text, rect, style) {
    callback(user_arg);
  }
}

struct SliderState!<T> {
  held : bool,
  min_value: T = 0,
  max_value: T = 1,
  value: *mut T,
}

/*
  draws a draggable slider, and adjusts a value of type $T.

  TODO: add vertical sliders.
*/
@[inline]
fn slider!<T>(
  text: Option!<String>,
  rectangle: Rectangle,
  style: Style,
  state: *mut SliderState!<T>,
  format_options: Option!<FormatOptions>,
) where T: IsNumeric {
  { // * Draw the slider.
    DrawRectangleRec(
      rectangle,
      style.background,
    );

    v_f := (*state.value) as f32;
    min_f := state.min_value as f32;
    max_f := state.max_value as f32;

    slider_width: f32 = rectangle.width * clamp(abs(v_f - min_f) / abs(max_f - min_f), 0.0, 1.0);

    slider_rect: Rectangle = .{
      x: rectangle.x,
      y: rectangle.y,
      width: slider_width,
      height: rectangle.height
    };

    DrawRectangleRec(slider_rect, style.foreground);

    DrawRectangleLinesEx(
      rectangle,
      style.line_thickness,
      style.foreground
    );

    mut font_color: Color = style.font_color_override.or_else(style.foreground);

    mut text_position: Vector2;
    if text.is_some() {
      the_text := text.unwrap();

      text_position = .{
        x: (rectangle.x - 15 + (rectangle.width - MeasureText(the_text.data, style.font_size)) / 2),
        y: (rectangle.y + (rectangle.height - style.font_size) / 2),
      };

      draw_text(
        the_text,
        text_position,
        style,
      );
    }

    mut options: FormatOptions;

    if format_options.is_some() {
      options = format_options.unwrap();
    } else {
      options = *FormatOptions::current();
    }

    mut value_text := format("%", (*state.value,), options);
    defer {
      value_text.deinit();
    }

    // 10 pixels padding
    text_position = .{
      x: text_position.x + 30 + MeasureText(value_text.data, style.font_size),
      y: text_position.y,
    };

    draw_text(value_text, text_position, style);
  }

  { // * Update the slider.
    mut increment: T;
    if IsKeyDown(KeyboardKey::KEY_LEFT_SHIFT) {
      increment = (state.max_value - state.min_value) / 100;
    } else {
      increment = (state.max_value - state.min_value) / 50;
    }

    if IsKeyPressed(KeyboardKey::KEY_RIGHT) {
      *state.value = clamp(*state.value + increment, state.min_value, state.max_value);
    } else if IsKeyPressed(KeyboardKey::KEY_LEFT) {
      *state.value = clamp(*state.value - increment, state.min_value, state.max_value);
    }

    // Handle mouse input
    mouse_pos := GetMousePosition();

    if CheckCollisionPointRec(mouse_pos, rectangle) {
      if IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        state.held = true;
      }
    }

    if state.held {
      if !IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        state.held = false;
      } else {
        new_value := state.min_value + ((mouse_pos.x - rectangle.x) / rectangle.width) * (state.max_value - state.min_value);
        *state.value = clamp(new_value, min(state.min_value, state.max_value), max(state.min_value, state.max_value));
      }
    }
  }
}

/*
  Draws a check button, one that is stateful-- it stores whether it's 'on' or 'off'. a toggle button.

  NOTE:
    the 'allow_hold' parameter has significant effect on the behaviour of the button.

    if it is false:
      clicking once will toggle the button on (LMB).
      clicking it again, will toggle it off   (LMB).
      holding the button has no effect.

    if it is true:
      clicking the button will toggle the button on (LMB).
      mousing over the button while (LMB) is held down will toggle it on.
      clicking the button again, will toggle the button off (RMB)
      mousing over the button while (RMB) is held down will toggle it off.

    It's very likely you'd never utilize the 'allow_hold: true' behaviour, unless you're creating some grid of buttons,
    where  you want to quickly enable large ranges of them, or disable them alike. (such as the 'sequencer' project).

    perhaps we should remove this, but this is where this widget came from, and it was neccesary there.
*/
@[inline]
fn check_button(
  text: Option!<String>,
  rectangle: Rectangle,
  style: Style,
  allow_hold: bool,
  value: *mut bool,         // whether the button is toggled or not.
) {
  if *value {
    DrawRectangleRec(
      rectangle,
      style.highlighted
    );
  } else {
    DrawRectangleRec(rectangle, style.background);
  }

  if text.is_some() {
    the_text := text.unwrap();
    text_position: Vector2 = .{
      x: (rectangle.x + (rectangle.width - MeasureText(the_text.data, style.font_size)) / 2),
      y: (rectangle.y + (rectangle.height - style.font_size) / 2),
    };
    draw_text(the_text, text_position, style);
  }

  hit := CheckCollisionPointRec(GetMousePosition(), rectangle);

  if hit {
    DrawRectangleLinesEx(
      rectangle,
      style.line_thickness,
      ORANGE
    );
  }

  mut left := false;
  mut right := false;

  if allow_hold {
    left = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT);
    right = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_RIGHT);
    if hit && left {
      *value = true;
    } else if hit && right {
      *value = false;
    }
  } else if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
    *value = !*value;
  }
}

struct DropDownState!<O> where O: AsByteSlice {
  selected_index:     Option!<u32>, // Some(index) when one is selected, None when none are selected.
  is_open:            bool,
}

/*
  'prefer_selected_option'
    will prefer presenting the string value of the selected option when one is selected, over the label.
*/
@[inline]
fn drop_down!<O, UserArg>(
  text:                   Option!<String>,
  rectangle:              Rectangle,
  style:                  Style,
  prefer_selected_option: bool,
  state:                  *mut DropDownState!<O>,
  options:                List!<O>,
  on_option_selected:     fn * (O, *mut UserArg) -> void,
  user_arg:               *mut UserArg,
) {
  // Draw the DropDown box
  DrawRectangleRec(rectangle, style.background);

  // Draw the selected option, instead of the label text.
  if state.selected_index.is_some() && (text.is_none() || prefer_selected_option) {
    the_text := options[state.selected_index.unwrap()];
    text_position: Vector2 = . {
      x: (rectangle.x + (rectangle.width - MeasureText(the_text.as_byte_slice().data, style.font_size)) / 2),
      y: (rectangle.y + (rectangle.height - style.font_size) / 2),
    };
    draw_text(
      the_text, 
      text_position, 
      style
    );
  } else if text.is_some() {
    the_text := text.unwrap();
    text_position: Vector2 = . {
      x: (rectangle.x + (rectangle.width - MeasureText(the_text.as_byte_slice().data, style.font_size)) / 2),
      y: (rectangle.y + (rectangle.height - style.font_size) / 2),
    };
    draw_text(
      the_text, 
      text_position, 
      style
    );
  }

  hit := CheckCollisionPointRec(GetMousePosition(), rectangle);

  if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
    state.is_open = !state.is_open;
  }

  mut hit_option := false;
  if state.is_open {
    // copy for mutating.
    mut option_rect: Rectangle = rectangle;
    option_rect.y += rectangle.height;

    for i in 0..options.length {

      mut option_color := style.background;
      hit := CheckCollisionPointRec(GetMousePosition(), option_rect);
      if hit {
        option_color = style.highlighted;
        hit_option = true;
      }

      DrawRectangleRec(option_rect, option_color);

      text := options[i].as_byte_slice();
      text_position: Vector2 = .{
        x: option_rect.x + (option_rect.width - MeasureText(text.data, style.font_size)) / 2,
        y: option_rect.y + (option_rect.height - style.font_size) / 2,
      };

      draw_text(text, text_position, style);

      if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
        state.selected_index = Some(i as u32);
        state.is_open = false;
        if on_option_selected {
          on_option_selected(options[i], user_arg);
        }
      }

      option_rect.y += option_rect.height;
    }
  }

  if !hit && !hit_option {
    state.is_open = false;
  }
}

/* 
  used for managing hit masking primarily,
  maybe this will have more responsibilities later.
  generally, just a shared state object all the Widgets can use.
*/
struct Ctx {
  widgets:  List!<Widget>,
  //               id,  layer.
  hit_mask: List!<(u32, u16)>,
}

/*
  The following abstractions are made intentionally more restricted (in terms of generic types, etc)
  than the above. This is so we can use them in lists of 'dyn IWidget', or the `choice Widget` type,
  without having type arguments.

  It's a trade off, and I'm choosing the most dynamic one anyway. (just using String in most cases.)
*/
trait IWidget {
  // draw the widget it,
  // and inform the caller about the dimensions that this widget required to be drawn.
  fn draw(*mut self);
}

struct Button {
  label:        String,
  rectangle:    Rectangle,
  style:        Style,
  user_arg:     *mut void,
  on_clicked:   fn * (*mut void),
}

impl IWidget for Button {
  fn draw(*mut self) {
    if button(self.label, self.rectangle, self.style) && self.on_clicked {
      self.on_clicked(self.user_arg);
    }
  }

}

struct Slider {
  text:           Option!<String>,
  rectangle:      Rectangle,
  style:          Style,
  state:          *mut SliderState!<f32>,
  format_options: Option!<FormatOptions>,
}

impl IWidget for Slider {
  fn draw(*mut self) {
    slider!<f32>(
      self.text,
      self.rectangle,
      self.style,
      self.state,
      self.format_options,
    );
  }

  
}

/*
  NOTE:
  the 'allow_hold' parameter has significant effect on the behaviour of the button.

  if it is false:
    clicking once will toggle the button on (LMB).
    clicking it again, will toggle it off   (LMB).
    holding the button has no effect.

  if it is true:
    clicking the button will toggle the button on (LMB).
    mousing over the button while (LMB) is held down will toggle it on.
    clicking the button again, will toggle the button off (RMB)
    mousing over the button while (RMB) is held down will toggle it off.

  It's very likely you'd never utilize the 'allow_hold: true' behaviour, unless you're creating some grid of buttons,
  where  you want to quickly enable large ranges of them, or disable them alike. (such as the 'sequencer' project).

  perhaps we should remove this, but this is where this widget came from, and it was neccesary there.
*/
struct CheckButton {
  text:         Option!<String>,
  rectangle:    Rectangle,
  style:        Style,
  allow_hold:   bool,
  value:        bool,         // whether the button is toggled or not.
}

impl IWidget for CheckButton {
  fn draw(*mut self) {
    check_button(
      self.text,
      self.rectangle,
      self.style,
      self.allow_hold,
      &mut self.value,
    );
  }

}

struct DropDown {
  text:                   Option!<String>,
  rectangle:              Rectangle,
  style:                  Style,
  prefer_selected_option: bool,
  state:                  *mut DropDownState!<String>,
  options:                List!<String>,
  on_option_selected:     fn * (String, *mut void) -> void,
  user_arg:               *mut void,

                          // layer, id;
}

impl IWidget for DropDown {
  fn draw(*mut self) {
    drop_down!<String, void>(
      self.text,
      self.rectangle,
      self.style,
      self.prefer_selected_option,
      self.state,
      self.options,
      self.on_option_selected,
      self.user_arg,
    );
  }

}

struct LabelBase!<Data> where Data: AsByteSlice {
  data: Data,
  style: Style,
  rectangle: Rectangle,
}

impl!<Data> IWidget for LabelBase!<Data> {
  fn draw(*mut self) {
    x, y := (self.rectangle.x, self.rectangle.y);
    DrawRectangleRec(self.rectangle, self.style.background);
    draw_text!<Data>(
      self.data,
      .{x: x, y: y},
      self.style,
    );
  }
}

choice Widget {
  Button(Button),
  Slider(Slider),
  CheckButton(CheckButton),
  DropDown(DropDown),
}

impl Widget {
  fn draw(*mut self) {
    switch is self {
      Widget::Button(&mut btn) => btn.draw(),
      Widget::Slider(&mut slider) => slider.draw(),
      Widget::CheckButton(&mut chk_btn) => chk_btn.draw(),
      Widget::DropDown(&mut drp_dwn) => drp_dwn.draw(),
    }
  }
}

struct Window;

alias RenderHook :: fn * (*mut void)

enum RenderHookPriority {
  PreWidgetRender,
  PostWidgetRender
}

struct Window {
  widgets: List!<dyn IWidget>,
  background_color: Color,
  render_hooks: List!<(RenderHookPriority, RenderHook)>,
  init_hooks: List!<fn * (*mut void)>,
  // TODO: when we have default generics, we can have a default stub here. for now, just *mut void.
  user_context: *mut void, 
}

impl Window {
  fn new(title: str = "Rayui Window", 
        size: Vector2 = .{x: 800, y: 600}, 
        target_fps: u8 = 60, 
        background_color: Color = .{ r:0, g:0, b:0, a:255}) -> Window {
    InitWindow(size.x as s32, size.y as s32, title.data);
    SetTargetFPS(target_fps);
    return .{
      background_color: background_color
    };
  }

  fn run(*mut self) {

    for hook in self.init_hooks {
      hook(self.user_context);
    }

    while !WindowShouldClose() {
      BeginDrawing();
      ClearBackground(self.background_color);

      for priority, hook in self.render_hooks {
        if priority == RenderHookPriority::PreWidgetRender {
          hook(self.user_context);
        }
      }

      for widget in self.widgets.iter_mut() {
        widget.draw();
      }

      for priority, hook in self.render_hooks {
        if priority == RenderHookPriority::PostWidgetRender {
          hook(self.user_context);
        }
      }

      EndDrawing();
    }
  }

  fn add_widget!<T>(*mut self, t: *mut T) -> Window where T: IWidget {
    self.widgets.push(dynof(t, IWidget));
    return *self;
  }

  fn add_render_hook(*mut self, hook: RenderHook, priority: RenderHookPriority = RenderHookPriority::PreWidgetRender) -> Window {
    self.render_hooks.push((priority, hook));
    return *self;
  }

  fn set_user_context!<T>(*mut self, ctx: *mut T) -> Window {
    self.user_context = ctx as *mut void;
    return *self;
  }

  fn add_on_init_hook(*mut self, hook: RenderHook) -> Window {
    self.init_hooks.push(hook);
    return *self;
  }
}
