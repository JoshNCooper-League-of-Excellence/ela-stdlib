import raylib::*;
import fmt::*;


struct Style {
  foreground:           Color = WHITE,
  background:           Color = BLACK,
  highlighted:          Color = ORANGE,

  line_thickness:       f32 = 2,

  // Text stuff.
  font_size:            s32 = 16,
  font_spacing:         f32 = 1,
  font_color_override:  Option!<Color>,
  font:                 Font,

  // Layout stuff
  margin:               f32 = 10.0, // only really used for ListBox right now. Should've been added to all elements.
}

#flags enum InputState {
  None,
  Hovered,
  Pressed,
  Held,
}

#flags enum WidgetState {
  Inactive, // Completely off.
  Active,   // on.

  Disabled, // Uninteractable.
  Enabled,  // interactable.
}

#static widget_id: u32 = 0;

struct WidgetBase {
  // unique id.
  id:    u32 = widget_id++,
  // Z index.
  layer: u32,
  // various input states
  input_state: InputState = InputState::None,
  // general, option-like states.
  state: WidgetState = WidgetState::Active,
  // the general style of this.
  style: Style,
  // the bounds and position. (Do not modify! set the model_rectangle with 0 to 1 values, in percentage of screen space)
  rectangle: Rectangle,

  // a normalized screen space (0 to 1) rectangle representing the target size.
  // To read tha "Actual size" read `rectangle`.
  model_rectangle: Rectangle,

  on_pressed:   fn * (*mut WidgetBase, s32) -> bool,
  on_released:  fn * (*mut WidgetBase, s32) -> bool,
  on_hovered:   fn * (*mut WidgetBase, Vector2),

  children: List!<*mut WidgetBase>,
};

trait Widget {
  fn get_base(*const self) -> *mut WidgetBase {
    return &mut self.base;
  }

  fn is_hovered(*const self) -> bool {
    return (self.get_base().input_state & InputState::Hovered) != 0;
  }

  fn is_pressed(*const self) -> bool {
    return (self.get_base().input_state & InputState::Pressed) != 0;
  }

  fn is_held(*const self) -> bool {
    return (self.get_base().input_state & InputState::Held) != 0;
  }

  // Coordinates should be 0 to 1, a percentage of the screen.
  fn set_size(*mut self, rectangle: Rectangle) {
    self.base.model_rectangle = rectangle;
  }

  fn get_children(*const self) -> *mut List!<dyn Widget>;

  fn draw(*mut self);

  fn on_window_resized(*mut self, screen: Rectangle) {
    base := self.get_base()

    base.rectangle.x = base.model_rectangle.x * screen.width;
    base.rectangle.y = base.model_rectangle.y * screen.height;
    base.rectangle.width = base.model_rectangle.width * screen.width;
    base.rectangle.height = base.model_rectangle.height * screen.height;

    children := self.get_children();

    if children {
      for child in children.iter_mut() {
        child.on_window_resized(screen);
      }
    }
  }
}

choice Event {
  // dyn Widget field is always sender.
  MouseDown(MouseButton),
  MouseUp(MouseButton),
  MouseMoved(Vector2),
  KeyPressed(KeyboardKey),
}

struct Button!<UserArg> {
  base:         WidgetBase,
  label:        Option!<String>,

  // callback argument.
  user_arg:     *mut UserArg,
  on_clicked:   fn * (*mut UserArg),
}

struct Slider!<TString, T> where TString: AsByteSlice {
  base:             WidgetBase,
  text:             Option!<TString, >,
  format_options:   Option!<FormatOptions>,

  // is the mouse holding this ish.
  held:             bool,

  // numerical state.
  min_value:        T,
  max_value:        T,
  value:            *mut T,
}

struct CheckButton {
  base:         WidgetBase,
  // A possible label.
  text:         Option!<String>,
  // this has crazy behaviour. it should be removed.
  allow_hold:   bool,
  // is checked or not.
  value:        *mut bool,
}

struct DropDown!<TString, UserArg> where TString: AsByteSlice {
  base:                   WidgetBase,
  // optional label to show in the base rect.
  text:                   Option!<TString>,
  // list of the options that can be selected.
  // maybe this should be a list of widgets.s
  options:                List!<TString>,
  // Some(selected_index), None() none selected.
  selected_index:         Option!<u32>,
  // if this is enabled, the label will prefer the option that's selected, instead of a constant label.
  prefer_selected_option: bool,
  // is currently expanded.
  is_open:                bool,
  // a user arg that's used for the on_selected callback.
  user_arg:               *mut UserArg,
  // called when an option is selected via the dropdown.
  on_option_selected:     fn * (TString, *mut UserArg) -> void,
}

struct Label!<TString> where TString: AsByteSlice {
  base: WidgetBase,
  text: TString,
}

choice LayoutStyle {
  Vertical(),
  Horizontal(),
  Grid {
    // if both of these are zero, it will just do row first.
    items_per_row:    s32, // >0 for row-first, ==0 to ignore
    items_per_column: s32, // >0 for column-first, ==0 to ignore
  }
}

struct ListBox {
  base: WidgetBase,
  // 'items' would be a more apt name.
  children: List!<dyn Widget>,
  layout_style: LayoutStyle,
  scroll_offset: f32,
}

struct TextField {
  base:         WidgetBase,
  text:        *mut String,
  in_edit_mode: bool = false,
  style_override: Option!<Style>,
}

enum RenderHookPriority {
  PreWidgetRender,
  PostWidgetRender
}

struct Window!<Ctx> {
  background_color: Color,
  // TODO: when we have default generics, we can have a default stub here. for now, just *mut void.
  user_context: *mut Ctx,
  screen_size: Rectangle,
  widgets: List!<dyn Widget>,
  render_hooks: List!<(RenderHookPriority, fn*(*mut Ctx))>,
  init_hooks: List!<fn * (*mut void)>,
  on_resized_callbacks: List!<(*mut void, fn * (*mut void, Rectangle, Rectangle))>,
}

impl!<Ctx> Window!<Ctx> {
  alias RenderHook :: fn * (*mut Ctx);

  fn on_resized(*mut self, new_size: Rectangle) {
    for widget in self.widgets.iter_mut() {
      widget.on_window_resized(new_size);
    }
    for arg, callback in self.on_resized_callbacks {
      callback(arg, self.screen_size, new_size);
    }
    self.screen_size = new_size;
  }

  fn new(title: str = "Rayui Window",
        config_flags: ConfigFlags = 0,
        size: Vector2 = .{x: 800, y: 600},
        target_fps: u8 = 60,
        background_color: Color = .{ r:0, g:0, b:0, a:255}) -> #self {
    SetConfigFlags(config_flags);
    SetTargetFPS(target_fps);
    InitWindow(size.x as s32, size.y as s32, title.data);
    return .{
      screen_size: .{
        x: 0,
        y: 0,
        width: GetScreenWidth(),
        height: GetScreenHeight(),
      }
      background_color: background_color
    };
  }

  fn run(*mut self) {
    for hook in self.init_hooks {
      hook(self.user_context);
    }

    while !WindowShouldClose() {
      BeginDrawing();
      ClearBackground(self.background_color);

      if IsWindowResized() {
        self.on_resized(.{
          x: 0, y: 0,
          width: GetScreenWidth(),
          height: GetScreenHeight(),
        });
      }

      for priority, hook in self.render_hooks {
        if priority == RenderHookPriority::PreWidgetRender {
          hook(self.user_context);
        }
      }

      self.widgets.sort(fn(widget: *const dyn Widget) -> u32 {
        return widget.get_base().layer;
      });

      fn handle_events(mouse_position: Vector2, widget: *mut dyn Widget) -> bool {
        base := widget.get_base();
        mut hovered := false;
        mut lmb_pressed := false;
        mut rmb_pressed := false;

        was_pressed := base.input_state & InputState::Pressed;

        base.input_state = InputState::None;
        if CheckCollisionPointRec(mouse_position, base.rectangle) {
          base.input_state = InputState::Hovered;
          hovered = true;

          if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
            base.input_state |= InputState::Pressed;
            lmb_pressed = true;
          }
          if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_RIGHT) {
            base.input_state |= InputState::Pressed;
            rmb_pressed = true;
          }
        }

        children := widget.get_children();
        if children {
          for child in children.iter_mut() {
            if handle_events(mouse_position, child) {
              base.input_state = InputState::None;
            }
          }
        }
      
        if base.input_state & InputState::Hovered && base.on_hovered {
          base.on_hovered(widget.get_base(), mouse_position);
        }

        if was_pressed && base.input_state & InputState::Pressed == 0 && base.on_released {
          // ! THIS IS ALWAYS WRONG
          base.on_released(widget.get_base(), 0);
        }

        if base.input_state & InputState::Pressed && base.on_pressed {
          if lmb_pressed {
            base.on_pressed(widget.get_base(), MouseButton::MOUSE_BUTTON_LEFT);
          }
          if rmb_pressed {
            base.on_pressed(widget.get_base(), MouseButton::MOUSE_BUTTON_RIGHT);
          }
        }

        return hovered || lmb_pressed || rmb_pressed;
      }

      { // Handle events.
        mouse_position := GetMousePosition();
        for widget in self.widgets.iter_mut() {
          handle_events(mouse_position, widget);
        }
      }

      for widget in self.widgets.iter_mut() {
        widget.draw();
      }

      for priority, hook in self.render_hooks {
        if priority == RenderHookPriority::PostWidgetRender {
          hook(self.user_context);
        }
      }

      EndDrawing();
    }

    self.widgets.deinit();
    self.render_hooks.deinit();
    self.init_hooks.deinit();
    self.on_resized_callbacks.deinit();
  }

  fn add_widget!<T>(*mut self, t: *mut T) -> #self where T: Widget  {
    trait_obj := dynof(t, Widget);
    trait_obj.on_window_resized(.{
      x: 0, y: 0,
      width: GetScreenWidth(),
      height: GetScreenHeight(),
    });
    self.widgets.push(trait_obj);
    return *self;
  }

  fn add_render_hook(*mut self, hook: RenderHook, priority: RenderHookPriority = RenderHookPriority::PreWidgetRender) -> #self {
    self.render_hooks.push((priority, hook));
    return *self;
  }

  fn set_user_context(*mut self, ctx: *mut Ctx) -> #self {
    self.user_context = ctx;
    return *self;
  }

  fn add_on_init_hook(*mut self, hook: RenderHook) -> #self {
    self.init_hooks.push(hook);
    return *self;
  }
}

fn draw_textf!<Tuple>(fmt: str, tuple: Tuple, position: Vector2, style: Style, format_options: FormatOptions) where Tuple: IsTuple {
  text := format(fmt, tuple, format_options);
  defer {
    text.deinit();
  }
  DrawTextEx(
    style.font,
    text.data,
    position,
    style.font_size,
    style.font_spacing,
    style.font_color_override.or_else(style.foreground)
  );
}

fn draw_text!<Data>(text: Data, position: Vector2, style: Style) where Data: AsByteSlice {
  DrawTextEx(
    style.font,
    text.as_byte_slice().data,
    position,
    style.font_size,
    style.font_spacing,
    style.font_color_override.or_else(style.foreground)
  );
}

// for drawing a single char. useful for custom text layouts.
fn draw_character(char: u8, position: Vector2, style: Style) {
  temp : u8[2] = .[char, '\0' as u8];
  slice := Slice!<u8>.{data: temp, length: 1};
  draw_text!<Slice!<u8>>(slice, position, style);
}

impl!<UserArg> Widget for Button!<UserArg> {
  fn draw(*mut self) {
    mut position: Vector2 = .{
      x: self.base.rectangle.x,
      y: self.base.rectangle.y
    };

    mut size: Vector2 = .{
      x: self.base.rectangle.width,
      y: self.base.rectangle.height
    };

    if self.base.input_state & InputState::Hovered {
      DrawRectangleV(position, size, self.base.style.highlighted);
      if self.base.input_state & InputState::Pressed {
        self.on_clicked(self.user_arg);
      }
    } else {
      DrawRectangleV(position, size, self.base.style.background);
    }

    if self.label is Option!<String>::Some(text) {
      text_width: f32 = MeasureText(text.data, self.base.style.font_size);
      text_height: f32 = self.base.style.font_size;
      
      if text_width > self.base.rectangle.width {
        size.x = text_width;
        position.x = self.base.rectangle.x - (text_width - self.base.rectangle.width) / 2;
      }

      text_position: Vector2 = .{
        x: position.x + (size.x - text_width) / 2,
        y: position.y + (size.y - text_height) / 2,
      };

      draw_text(text, text_position, self.base.style);
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}

impl Widget for ListBox {
  fn draw(*mut self) {
    DrawRectangleRec(self.base.rectangle, self.base.style.background.with_alpha(20));
    DrawRectangleLinesEx(self.base.rectangle, self.base.style.line_thickness, self.base.style.background);

    count := self.children.length as f32;

    if count == 0 
      then return;

    rect := self.base.rectangle;

    switch is self.layout_style {
      LayoutStyle::Vertical(): {
        item_height := 64.0; // TODO: we need to style this.
        mut y := rect.y + self.base.style.margin - self.scroll_offset;
        for child in self.children.iter_mut() {
          base := child.get_base();
          base.rectangle = .{
            x: rect.x + self.base.style.margin,
            y: y,
            width: rect.width - 2 * self.base.style.margin,
            height: item_height,
          };
          y += item_height + self.base.style.margin;
          // Only draw if visible
          if base.rectangle.y + base.rectangle.height > rect.y && base.rectangle.y < rect.y + rect.height {
            child.draw();
          }
        }
      }
      LayoutStyle::Horizontal(): {
        item_width := 128.0; // TODO: we need this to come from style
        mut x := rect.x + self.base.style.margin - self.scroll_offset;
        for child in self.children.iter_mut() {
          base := child.get_base();
          base.rectangle = .{
            x: x,
            y: rect.y + self.base.style.margin,
            width: item_width,
            height: rect.height - 2 * self.base.style.margin,
          };
          x += item_width + self.base.style.margin;
          // Only draw if visible
          if base.rectangle.x + base.rectangle.width > rect.x && base.rectangle.x < rect.x + rect.width {
            child.draw();
          }
        }
      }
      LayoutStyle::Grid.{ items_per_row: items_per_row, items_per_column: items_per_column }: {
        // No scrolling for grid
        mut rows := 1;
        mut cols := 1;
        if items_per_row > 0 {
          cols = items_per_row;
          rows = (count + cols - 1) / cols;
        } else if items_per_column > 0 {
          rows = items_per_column;
          cols = (count + rows - 1) / rows;
        } else {
          cols = count;
          rows = 1;
        }
    
        item_width := (rect.width - (self.base.style.margin * (cols + 1))) / cols as f32;
        item_height := (rect.height - (self.base.style.margin * (rows + 1))) / rows as f32;
    
        for i, child in self.children.enumerate_mut() {
          row := i / cols;
          col := i % cols;
          base := child.get_base();
          base.rectangle = .{
            x: rect.x + self.base.style.margin + col as f32 * (item_width + self.base.style.margin),
            y: rect.y + self.base.style.margin + row as f32 * (item_height + self.base.style.margin),
            width: item_width,
            height: item_height,
          };
          child.draw();
        }
      }
    }
  }
  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return &mut self.children;
  }
}

impl ListBox {
  fn add_child!<T>(*mut self, widget: *mut T) where T: Widget {
    self.base.children.push(widget.get_base());
    self.children.push(dynof(widget, Widget));
  }
}

impl!<TString, T> Widget for Slider!<TString, T> where TString: AsByteSlice, T: IsNumeric {
  fn draw(*mut self) {
    // Draw the slider background
    DrawRectangleRec(
      self.base.rectangle,
      self.base.style.background,
    );

    v_f := (*self.value) as f32;
    min_f := self.min_value as f32;
    max_f := self.max_value as f32;

    slider_width: f32 = self.base.rectangle.width * clamp(abs(v_f - min_f) / abs(max_f - min_f), 0.0, 1.0);

    slider_rect: Rectangle = .{
      x: self.base.rectangle.x,
      y: self.base.rectangle.y,
      width: slider_width,
      height: self.base.rectangle.height
    };

    DrawRectangleRec(slider_rect, self.base.style.foreground);

    DrawRectangleLinesEx(
      self.base.rectangle,
      self.base.style.line_thickness,
      self.base.style.foreground
    );

    mut font_color: Color = self.base.style.font_color_override.or_else(self.base.style.foreground);

    mut text_position: Vector2 = .{ x: self.base.rectangle.x, y: self.base.rectangle.y };

    if self.text.is_some() {
      the_text := self.text.unwrap();

      text_position = .{
        x: (self.base.rectangle.x - 15 + (self.base.rectangle.width - MeasureText(the_text.as_byte_slice().data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };

      draw_text(
        the_text,
        text_position,
        self.base.style,
      );
    }

    mut options: FormatOptions;
    if self.format_options.is_some() {
      options = self.format_options.unwrap();
    } else {
      options = *FormatOptions::current();
    }

    mut value_text := format("%", (*self.value,), options);
    defer {
      value_text.deinit();
    }

    // 10 pixels padding
    text_position = .{
      x: text_position.x + 30 + MeasureText(value_text.data, self.base.style.font_size),
      y: text_position.y,
    };

    draw_text(value_text, text_position, self.base.style);

    // Update logic
    mut increment: T;
    if IsKeyDown(KeyboardKey::KEY_LEFT_SHIFT) {
      increment = (self.max_value - self.min_value) / 100;
    } else {
      increment = (self.max_value - self.min_value) / 50;
    }

    if IsKeyPressed(KeyboardKey::KEY_RIGHT) {
      *self.value = clamp(*self.value + increment, self.min_value, self.max_value);
    } else if IsKeyPressed(KeyboardKey::KEY_LEFT) {
      *self.value = clamp(*self.value - increment, self.min_value, self.max_value);
    }

    // Handle mouse input
    mouse_pos := GetMousePosition();

    if CheckCollisionPointRec(mouse_pos, self.base.rectangle) {
      if IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        self.held = true;
      }
    }

    if self.held {
      if !IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT) {
        self.held = false;
      } else {
        new_value := self.min_value + ((mouse_pos.x - self.base.rectangle.x) / self.base.rectangle.width) * (self.max_value - self.min_value);
        *self.value = clamp(new_value, min(self.min_value, self.max_value), max(self.min_value, self.max_value));
      }
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}

/*
  Draws a check button, one that is stateful-- it stores whether it's 'on' or 'off'. a toggle button.

  NOTE:
    the 'allow_hold' parameter has significant effect on the behaviour of the button.

    if it is false:
      clicking once will toggle the button on (LMB).
      clicking it again, will toggle it off   (LMB).
      holding the button has no effect.

    if it is true:
      clicking the button will toggle the button on (LMB).
      mousing over the button while (LMB) is held down will toggle it on.
      clicking the button again, will toggle the button off (RMB)
      mousing over the button while (RMB) is held down will toggle it off.

    It's very likely you'd never utilize the 'allow_hold: true' behaviour, unless you're creating some grid of buttons,
    where you want to quickly enable large ranges of them, or disable them alike. (such as the 'sequencer' project).

    perhaps we should remove this, but this is where this widget came from, and it was neccesary there.
*/
impl Widget for CheckButton {
  fn draw(*mut self) {
    if *self.value {
      DrawRectangleRec(
        self.base.rectangle,
        self.base.style.highlighted
      );
    } else {
      DrawRectangleRec(self.base.rectangle, self.base.style.background);
    }

    if self.text.is_some() {
      the_text := self.text.unwrap();
      text_position: Vector2 = .{
        x: (self.base.rectangle.x + (self.base.rectangle.width - MeasureText(the_text.data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };
      draw_text(the_text, text_position, self.base.style);
    }

    hit := CheckCollisionPointRec(GetMousePosition(), self.base.rectangle);

    if hit {
      DrawRectangleLinesEx(
        self.base.rectangle,
        self.base.style.line_thickness,
        ORANGE
      );
    }

    mut left := false;
    mut right := false;

    if self.allow_hold {
      left = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_LEFT);
      right = IsMouseButtonDown(MouseButton::MOUSE_BUTTON_RIGHT);
      if hit && left {
        *self.value = true;
      } else if hit && right {
        *self.value = false;
      }
    } else if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      *self.value = !*self.value;
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}

/*
  'prefer_selected_option'
    will prefer presenting the string value of the selected option when one is selected, over the label.
*/
impl!<TString, UserArg> Widget for DropDown!<TString, UserArg> where TString: AsByteSlice {
  fn draw(*mut self) {
    // Draw the DropDown box
    DrawRectangleRec(self.base.rectangle, self.base.style.background);

    // Draw the selected option, instead of the label text.
    if self.selected_index.is_some() && (self.text.is_none() || self.prefer_selected_option) {
      the_text := self.options[self.selected_index.unwrap()];
      text_position: Vector2 = .{
        x: (self.base.rectangle.x + (self.base.rectangle.width - MeasureText(the_text.as_byte_slice().data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };
      draw_text(
        the_text,
        text_position,
        self.base.style
      );
    } else if self.text.is_some() {
      the_text := self.text.unwrap();
      text_position: Vector2 = .{
        x: (self.base.rectangle.x + (self.base.rectangle.width - MeasureText(the_text.as_byte_slice().data, self.base.style.font_size)) / 2),
        y: (self.base.rectangle.y + (self.base.rectangle.height - self.base.style.font_size) / 2),
      };
      draw_text(
        the_text,
        text_position,
        self.base.style
      );
    }

    hit := CheckCollisionPointRec(GetMousePosition(), self.base.rectangle);

    if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      self.is_open = !self.is_open;
    }

    mut hit_option := false;
    if self.is_open {
      // copy for mutating.
      mut option_rect: Rectangle = self.base.rectangle;
      option_rect.y += self.base.rectangle.height;

      for i in 0..self.options.length {
        mut option_color := self.base.style.background;
        hit := CheckCollisionPointRec(GetMousePosition(), option_rect);
        if hit {
          option_color = self.base.style.highlighted;
          hit_option = true;
        }

        DrawRectangleRec(option_rect, option_color);

        text := self.options[i].as_byte_slice();
        text_position: Vector2 = .{
          x: option_rect.x + (option_rect.width - MeasureText(text.data, self.base.style.font_size)) / 2,
          y: option_rect.y + (option_rect.height - self.base.style.font_size) / 2,
        };

        draw_text(text, text_position, self.base.style);

        if hit && IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
          self.selected_index = Some(i as u32);
          self.is_open = false;
          if self.on_option_selected {
            self.on_option_selected(self.options[i], self.user_arg);
          }
        }

        option_rect.y += option_rect.height;
      }
    }

    if !hit && !hit_option {
      self.is_open = false;
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}

impl Widget for TextField {
  fn draw(*mut self) {
    fn enter_edit_mode(this: *mut TextField) {
      this.in_edit_mode = true;
      mut copy := this.base.style;
      copy.font_color_override = Some(WHITE);
      copy.background = YELLOW.with_alpha(25);
      copy.highlighted = CLEAR;
      this.style_override = Some(copy);
    }

    fn exit_edit_mode(this: *mut TextField) {
      this.in_edit_mode = false;
      this.style_override = None();
    }

    style := self.style_override.or_else(self.base.style);

    mut position: Vector2 = .{
      x: self.base.rectangle.x,
      y: self.base.rectangle.y
    };

    mut size: Vector2 = .{
      x: self.base.rectangle.width,
      y: self.base.rectangle.height
    };

    if self.base.input_state & InputState::Hovered {
      DrawRectangleLinesEx(self.base.rectangle, style.line_thickness, style.highlighted);

      if !self.in_edit_mode && self.base.input_state & InputState::Pressed {
        enter_edit_mode(self);
      }
    } else if IsMouseButtonPressed(MouseButton::MOUSE_BUTTON_LEFT) {
      exit_edit_mode(self);
    }

    if !self.text {
      return;
    }

    DrawRectangleV(position, size, style.background);

    text_width: f32 = MeasureText(self.text.data, style.font_size);
    text_height: f32 = style.font_size;
    
    if text_width > self.base.rectangle.width {
      size.x = text_width;
      position.x = self.base.rectangle.x - (text_width - self.base.rectangle.width) / 2;
    }

    text_position: Vector2 = .{
      x: position.x + (size.x - text_width) / 2,
      y: position.y + (size.y - text_height) / 2,
    };

    draw_text(*self.text, text_position, style);

    if !self.in_edit_mode && self.base.input_state & InputState::Hovered && IsKeyDown(KeyboardKey::KEY_F2) {
      enter_edit_mode(self);
    }

    if self.in_edit_mode && IsKeyPressed(KeyboardKey::KEY_ENTER) {
      exit_edit_mode(self);
    }

    if self.in_edit_mode {
      ch := GetCharPressed() as u8;
      if IsKeyPressed(KeyboardKey::KEY_BACKSPACE) {
        if !self.text.is_empty() {
          self.text.pop();
        }
      } else if IsKeyPressed(KeyboardKey::KEY_SPACE) {
        self.text.push(' ');
      } else if ch.is_alpha() || ch.is_ascii_punctuation() {
        self.text.push(ch);
      }
    }
  }

  fn get_children(*const self) -> *mut List!<dyn Widget> {
    return null;
  }
}